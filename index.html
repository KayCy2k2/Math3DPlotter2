<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" /> 
  <title>Math 3D Plotter</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.1.0/dist/chartjs-chart-matrix.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111827;
    }

    canvas {
      display: block;
    }

    select option {
      color: #d1d5db;
      /* Tailwind's text-gray-300 */
      background-color: #1f2937;
      /* Tailwind's bg-gray-800 */
    }

    .tab-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      text-align: left;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .tab-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .active-tab {
      background-color: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.2);
    }

    /* ·∫®n n·ªÅn thanh cu·ªôn cho Chrome, Edge, Safari */
    .custom-scroll::-webkit-scrollbar {
      width: 8px;
    }

    .custom-scroll::-webkit-scrollbar-track {
      background: transparent;
      /* n·ªÅn trong su·ªët */
    }

    .custom-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.3);
      /* thanh k√©o m·ªù nh·∫π */
      border-radius: 4px;
    }

    /* Cho Firefox */
    .custom-scroll {
      scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
      scrollbar-width: thin;
    }
  </style>
</head>

<body>

  <!-- N√∫t m·ªü mini form -->
  <div class="fixed bottom-4 right-4 z-20 text-right">
    <button onclick="toggleMiniForm()"
      class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-full shadow-lg">
      ‚öôÔ∏è C√¥ng C·ª•
    </button>

    <!-- Mini form v·ªõi tabs -->
    <div id="miniForm"
      class=" mt-3 p-4 bg-black/80 backdrop-blur-md rounded-2xl shadow-2xl w-[28rem] max-h-[70vh] overflow-y-auto text-white border border-white/10">
      <script>
        function toggleMiniForm() {
          const form = document.getElementById('miniForm');
          form.classList.toggle('hidden');
        }
      </script>
      <!-- Flex ch·ª©a n·ªôi dung v√† n√∫t tab d·ªçc -->
      <div class="flex space-x-4 text-left">

        <!-- N·ªôi dung tab b√™n tr√°i -->
        <div class="flex-1">
          <!-- Tab: Hi·ªÉn th·ªã -->
          <div id="tab-display" class="tab-content hidden space-y-3 custom-scroll overflow-auto max-h-80">
            <div class="space-y-6 text-xl font-medium text-white m-4">

              <div class="flex flex-wrap gap-2">
                <!-- N√∫t toggle auto rotate -->
                <div id="toggleContainer" class="flex flex-wrap gap-4 text-white font-mono"></div>

                <script>
                  const toggles = [
                    { id: "autoRotateToggle", label: "Auto-Rotate" },
                    { id: "formulaToggle", label: "Hi·ªÉn th·ªã C√¥ng Th·ª©c" },
                  ];

                  const toggleContainer = document.getElementById('toggleContainer');

                  toggles.forEach(({ id, label }) => {
                    const group = document.createElement('div');
                    group.className = 'flex items-center space-x-2';

                    const span = document.createElement('span');
                    span.textContent = label;

                    const button = document.createElement('button');
                    button.id = id;
                    button.className = 'px-3 py-1 rounded bg-green-600 hover:bg-green-700 text-white shadow';
                    button.textContent = 'On';

                    group.appendChild(span);
                    group.appendChild(button);
                    toggleContainer.appendChild(group);
                  });
                </script>

              </div>
              <button onclick="toggle(gridHelper)" class="border px-3 py-1 rounded">L∆∞·ªõi</button>
              <!-- <hr class="w-px h-auto border-l border-l border-gray-300 m-2" /> -->
              <hr class="my-2 border-t border-dashed border-gray-300" />
              <!-- Panel ƒëi·ªÅu khi·ªÉn tr·ª•c + ticks -->
              <div class="space-y-4 custom-scroll overflow-auto max-h-60 font-medium text-lg text-white m-2">
                <!-- Ch·ªçn tr·ª•c v√† nh√£n -->
                <div class="space-y-2">
                  <h2 class="font-bold">C·∫•u h√¨nh tr·ª•c</h2>

                  <div id="axisControls" class="space-y-2"></div>
                  <script>
                    const axisLabels = [
                      { axis: 'x', label: 'Tr·ª•c X:', placeholder: 'Nh√£n X (m·∫∑c ƒë·ªãnh: X)' },
                      { axis: 'y', label: 'Tr·ª•c Y:', placeholder: 'Nh√£n Y (m·∫∑c ƒë·ªãnh: Y)' },
                      { axis: 'z', label: 'Tr·ª•c Z:', placeholder: 'Nh√£n Z (m·∫∑c ƒë·ªãnh: Z)' }
                    ];

                    const axisContainer = document.getElementById('axisControls');

                    axisLabels.forEach(({ axis, label, placeholder }) => {
                      const wrapper = document.createElement('div');
                      wrapper.className = 'flex items-center gap-2';

                      wrapper.innerHTML = `
                        <input type="checkbox" class="axis-checkbox" value="${axis}" checked />
                        <label class="w-16">${label}</label>
                        <input id="label${axis.toUpperCase()}Input" type="text" placeholder="${placeholder}"
                          class="flex-1 px-2 py-1 text-black rounded" />
                      `;

                      axisContainer.appendChild(wrapper);
                    });

                  </script>
                </div>

                <!-- C·∫•u h√¨nh ticks -->
                <div class="space-y-2">
                  <h2 class="font-bold">C·∫•u h√¨nh ticks</h2>

                  <div id="ticksInputs" class="grid grid-cols-4 gap-2 text-lg text-white font-medium"></div>
                  <script>
                    const ticks = [
                      { id: 'axisLengthInput', label: 'ƒê·ªô d√†i tr·ª•c:', value: '50' },
                      { id: 'stepInput', label: 'B∆∞·ªõc:', value: '5' },
                      { id: 'minInput', label: 'Min', value: '-50' },
                      { id: 'maxInput', label: 'Max', value: '50' }
                    ];

                    const ticksContainer = document.getElementById('ticksInputs');
                    ticks.forEach(({ label, id, value }) => {
                      const div = document.createElement('label');
                      div.className = 'flex flex-col';
                      div.innerHTML = `${label} <input id="${id}" type="number" placeholder="${label}" value="${value}" class="text-black px-2 py-1 rounded-lg">`;
                      ticksContainer.appendChild(div);
                    });
                  </script>
                </div>

                <!-- T√πy ch·ªçn hi·ªÉn th·ªã -->
                <div class="space-y-2">
                  <h2 class="text-lg font-bold">T√πy ch·ªçn hi·ªÉn th·ªã</h2>
                  <div class="grid grid-cols-4 gap-4">

                    <label class="flex items-center gap-2">
                      <input id="showAxisLabels" type="checkbox" class="form-checkbox" checked />
                      Hi·ªÉn th·ªã nh√£n tr·ª•c
                    </label>
                    <label class="flex items-center gap-2">
                      <input id="showAxisTicks" type="checkbox" class="form-checkbox" checked />
                      Hi·ªÉn th·ªã ticks
                    </label>
                    <!-- M√†u tr·ª•c -->

                    <label class="flex items-center gap-2">M√†u tr·ª•c:
                      <input id="axisColorInput" type="color" value="#ffffff" class="w-32 rounded" /></label>
                    <!-- N√∫t c·∫≠p nh·∫≠t -->
                    <button onclick="updateAxisAll()"
                      class="bg-blue-600 hover:bg-blue-700 transition px-2 py-1 rounded-xl font-semibold">
                      C·∫≠p Nh·∫≠t Tr·ª•c & Ticks
                    </button>
                  </div>
                </div>
              </div>

              <hr class="my-4 border-t border-dashed border-gray-300" />

              <div class="text-sm text-gray-600">
                <!-- N·ªôi dung kh√°c -->
                <p>Th√¥ng tin b·ªï sung, ghi ch√∫ ho·∫∑c h∆∞·ªõng d·∫´n ·ªü ƒë√¢y.</p>
              </div>
            </div>
          </div>

          <div id="tab-sample" class="tab-content hidden space-y-3 custom-scroll overflow-auto max-h-80">
            <div class="space-y-6 text-sm font-medium text-white m-4">

            <!-- üé® Ch·ªçn kh·ªëi c∆° b·∫£n -->
            <div class="space-y-2">
              <h2 class="text-lg font-semibold">üé® Ch·ªçn Kh·ªëi 2D / 3D</h2>
              <div class="flex gap-2">
                <select id="primitiveShape" class="border bg-transparent text-white rounded px-3 py-1 text-sm flex-1">
                  <option value="none">Ch·ªçn kh·ªëi 2D/3D</option>
                  <option value="cube">H√¨nh L·∫≠p Ph∆∞∆°ng</option>
                  <option value="sphere">H√¨nh C·∫ßu</option>
                  <option value="cylinder">H√¨nh Tr·ª•</option>
                  <option value="cone">H√¨nh N√≥n</option>
                  <option value="circle">H√¨nh Tr√≤n 2D</option>
                  <option value="ellipse">Ellipse</option>
                  <option value="triangle">Tam Gi√°c 2D</option>
                  <option value="pentagon">Ng≈© Gi√°c 2D</option>
                  <option value="hexagon">L·ª•c Gi√°c 2D</option>
                  <option value="pyramid">H√¨nh Ch√≥p</option>
                  <option value="plane">M·∫∑t Ph·∫≥ng</option>
                </select>
                <button onclick="plotPrimitive()" class="border px-3 py-1 rounded">‚ûï Th√™m</button>
              </div>
            </div>
            <hr class="my-2 border-t border-dashed border-gray-300" />
            <!-- üåÄ Chuy·ªÉn ƒë·ªông -->
            <div class="space-y-2">
              <h2 class="text-lg font-semibold">üåÄ Hi·ªáu ·ª®ng Chuy·ªÉn ƒê·ªông</h2>
              <select id="motionEffect" class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full">
                <option value="">-- Kh√¥ng chuy·ªÉn ƒë·ªông --</option>
                <option value="rotateY">Quay quanh tr·ª•c Y</option>
                <option value="rotateX">Quay quanh tr·ª•c X</option>
                <option value="bounce">N·∫£y l√™n xu·ªëng</option>
                <option value="wave">G·ª£n s√≥ng</option>
                <option value="spin">Xoay li√™n t·ª•c</option>
                <option value="shake">L·∫Øc ngang</option>
                <option value="circle">Tr∆∞·ª£t tr√≤n</option>
                <option value="waveZ">G·ª£n s√≥ng tr·ª•c Z</option>
                <option value="float">Tr√¥i n·ªïi</option>
                <option value="rotate">Xoay</option>
                <option value="pulse">Ph·ªìng l√™n</option>
                <option value="orbit">Quay quanh t√¢m</option>
                <option value="flashColor">Ch·ªõp m√†u</option>
              </select>

              <div class="flex flex-col gap-1">
                <label class="text-sm" for="customMotionCode">T·ª± t·∫°o hi·ªáu ·ª©ng (JS):</label>
                <textarea id="customMotionCode" rows="3" class="w-full text-sm rounded p-2 text-black"
                  placeholder="V√≠ d·ª•: obj.rotation.y += Math.sin(time * 0.001) * 0.01;"></textarea>
              </div>
            </div>

            <!-- üß± T·∫°o kh·ªëi v·ªõi th√¥ng s·ªë -->
            <div class="p-4 bg-black/30 rounded-xl space-y-3 custom-scroll overflow-auto max-h-40 w-full">
              <h2 class="text-lg font-bold">üß± T√πy Bi·∫øn Kh·ªëi 3D</h2>

              <div class="space-y-2">
                <div>
                  <label class="block text-sm">Lo·∫°i Kh·ªëi:</label>
                  <select id="shapeType" class="w-full px-2 py-1 text-black rounded">
                    <option value="box">Box</option>
                    <option value="sphere">Sphere</option>
                    <option value="cylinder">Cylinder</option>
                  </select>
                </div>

                <div>
                  <label class="block text-sm">K√≠ch th∆∞·ªõc / B√°n k√≠nh:</label>
                  <input id="shapeSize" type="number" value="1" min="0.1" step="0.1"
                    class="w-full px-2 py-1 text-black rounded" />
                </div>

                <div>
                  <label class="block text-sm">Chi·ªÅu Cao:</label>
                  <input id="shapeHeight" type="number" value="1" min="0.1" step="0.1"
                    class="w-full px-2 py-1 text-black rounded" />
                </div>

                <div>
                  <label class="block text-sm">M√†u s·∫Øc:</label>
                  <input id="shapeColor" type="color" value="#44ccff" class="w-full px-2 py-1 rounded" />
                </div>

                <button onclick="createShape()"
                  class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded shadow w-full">
                  ‚ûï T·∫°o Kh·ªëi
                </button>
              </div>
            </div>


            <!-- üì¶ Danh s√°ch m·∫´u -->
            <div class="space-y-2">
              <h2 class="text-lg font-semibold mb-2">üì¶ Kh·ªëi M·∫´u C√≥ S·∫µn</h2>
              <div id="buttonContainer"
                class="custom-scroll overflow-auto max-h-60 grid grid-cols-2 sm:grid-cols-4 gap-2 text-sm">
                <!-- N√∫t s·∫Ω ƒë∆∞·ª£c th√™m ƒë·ªông -->
              </div>
            </div>

            <script>
              const objectButtons = [
                { label: '‚ö™ Kh·ªëi C·∫ßu', ref: 'sphere' },
                { label: '‚ù§Ô∏è Tr√°i Tim', ref: 'heart' },
                { label: 'üåÄ H√¨nh Xuy·∫øn', ref: 'torus' },
                { label: 'üîÉ Xo·∫Øn ·ªêc', ref: 'spiral' },
                { label: 'üåä S√≥ng Sin', ref: 'wave' },
                { label: 'üî∫ Y√™n Ng·ª±a', ref: 'saddle' },
                { label: 'üßä Elipsoid', ref: 'ellipsoid' },
                { label: 'üìà Parabol 3D', ref: 'paraboloid' },
                { label: 'üåÄ Sin-Cos Wave', ref: 'sincosWave' },
                { label: '‚ôæÔ∏è Mobius', ref: 'mobius' },
                { label: 'üîª Cone', ref: 'cone' },
                { label: 'üåÄ Cycloid', ref: 'cycloid' }
              ];


              const buttonContainer = document.getElementById('buttonContainer');

              objectButtons.forEach(({ label, ref }) => {
                const btn = document.createElement('button');
                btn.textContent = label;
                btn.className = 'border px-3 py-1 rounded';
                btn.onclick = () => toggle(window[ref]); // Truy c·∫≠p ƒë·ªëi t∆∞·ª£ng to√†n c·ª•c
                buttonContainer.appendChild(btn);
              });
            </script>
            </div>
          </div>

          <!-- Tab: G√≥c Nh√¨n -->
          <div id="tab-view" class="tab-content hidden">
            <span>Ch·ªçn g√≥c nh√¨n:</span>
            <select id="viewSelector" onchange="setViewDirection()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full mt-1">
              <option value="default">3D T·ª± Do</option>
              <option value="xy">XY (Tr√™n)</option>
              <option value="yz">YZ (Tr√°i)</option>
              <option value="xz">XZ (Tr∆∞·ªõc)</option>
            </select>
          </div>

          <!-- Tab: √Ånh s√°ng -->
          <div id="tab-light" class="tab-content hidden space-y-3">
            <span>Ch·∫ø ƒë·ªô √°nh s√°ng:</span>
            <select id="lightMode" onchange="updateLightMode()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full">
              <option value="soft">M·ªÅm</option>
              <option value="strong">M·∫°nh</option>
              <option value="wireframe">Ch·ªâ khung</option>
            </select>

            <!-- Material Picker -->
            <span>Lo·∫°i v·∫≠t li·ªáu:</span>
            <select id="materialType" onchange="updateLightMode()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full">
              <option value="standard">Standard</option>
              <option value="phong">Phong</option>
              <option value="lambert">Lambert</option>
              <option value="toon">Toon</option>
              <option value="texture">Texture</option>
            </select>

            <!-- Texture Picker (ch·ªâ hi·ªán n·∫øu ch·ªçn texture) -->
            <span id="textureLabel" class="hidden">Ch·ªçn ·∫£nh n·ªÅn:</span>
            <input type="file" id="textureImage" accept="image/*" class="hidden w-full text-white"
              onchange="updateLightMode()" />
          </div>


          <!-- Tab: Vector -->
          <div id="tab-vector" class="tab-content hidden space-y-3">
            <span>Vector:</span>
            <div id="vector-inputs" class="grid grid-cols-3 gap-3 text-sm font-medium mt-2"></div>
            <script>
              const vectorInputs = [
                { label: "X1", id: "x1" },
                { label: "Y1", id: "y1" },
                { label: "Z1", id: "z1" },
                { label: "X2", id: "x2" },
                { label: "Y2", id: "y2" },
                { label: "Z2", id: "z2" },
              ];

              const container = document.getElementById("vector-inputs");

              vectorInputs.forEach(({ label, id }) => {
                const wrapper = document.createElement("label");
                wrapper.className = "flex items-center space-x-1";

                const span = document.createElement("span");
                span.textContent = label + ":";

                const input = document.createElement("input");
                input.type = "number";
                input.id = id;
                input.step = "0.1";
                input.className = "w-20 p-1 border rounded text-black";

                wrapper.appendChild(span);
                wrapper.appendChild(input);
                container.appendChild(wrapper);
              });
            </script>
            <button onclick="drawVectorFromInput()" class="border px-3 py-1 rounded">V·∫Ω vector</button>
          </div>

          <!-- Tab: Tr·ª•c -->
          <div id="tab-axis" class="tab-content hidden space-y-3">

          </div>

          <div id="tab-history" class="tab-content hidden">
            <span>üßæ L·ªãch S·ª≠:</span>
            <ul id="historyList" class="space-y-1 text-sm list-disc list-inside"></ul>
          </div>
          <!-- Tab: Xu·∫•t ·∫£nh -->
          <div id="tab-export" class="tab-content hidden">
            <button onclick="saveImage()"
              class="w-full bg-red-600 hover:bg-red-700 transition px-4 py-2 rounded-xl font-semibold mt-2">
              üì∏ Xu·∫•t ·∫¢nh
            </button>
          </div>
          <!-- Tab: T√≠ch Ph√¢n -->
          <div id="tab-integral" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">

              <!-- T√≠nh T√≠ch Ph√¢n 1 Bi·∫øn -->
              <div class="space-y-4">
                <h2 class="text-lg font-semibold">üìà T√≠nh T√≠ch Ph√¢n 1 Bi·∫øn (‚à´ f(x) dx)</h2>
                <div class="flex items-center gap-2">

                  <label for="integralFormula1D" class="w-16">H√†m s·ªë:</label>
                  <input id="integralFormula1D" type="text" placeholder="f(x) = x^2"
                    class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="grid grid-cols-3 gap-4">
                  <div class="flex items-center gap-2">
                    <label for="a1D" class="flex flex-col">Ti·ªám c·∫≠n d∆∞·ªõi:</label>
                    <input id="a1D" type="text" placeholder="Nh·∫≠p a (v√≠ d·ª•: 0, pi, sqrt(2))"
                      class="w-24 text-black px-2 py-1 rounded-lg" />
                  </div>
                  <div class="flex items-center gap-2">
                    <label for="b1D" class="flex flex-col">Ti·ªám c·∫≠n tr√™n:</label>
                    <input id="b1D" type="text" placeholder="Nh·∫≠p b (v√≠ d·ª•: 2*pi, e)"
                      class="w-24 text-black px-2 py-1 rounded-lg" />
                  </div>
                  <div class="flex items-center gap-2">
                    <label for="integralSteps" class="flex flex-col">S·ªë ƒëo·∫°n chia (n):</label>
                    <input id="integralSteps" type="number" min="10" value="200"
                      class="w-24 text-black px-2 py-1 rounded-lg" />
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-4">
                  <div class="flex items-center gap-2">
                    <label for="integralMethod" class="w-32">Ph∆∞∆°ng ph√°p t√≠nh:</label>
                    <select id="integralMethod" class="text-black px-2 py-1 rounded">
                      <option value="midpoint">Midpoint</option>
                      <option value="trapezoidal">Trapezoidal</option>
                      <option value="simpson">Simpson</option>
                    </select>
                  </div>
                </div>

                <div class="flex justify-between items-center mt-2">
                  <div id="resultIntegral1D" class="text-green-400 font-bold"></div>
                  <button onclick="computeIntegral1D()"
                    class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">
                    üìä T√≠nh v√† V·∫Ω
                  </button>
                </div>

                <div class="space-y-2">
                  <canvas id="integralGraph1D" width="600" height="250"
                    class="bg-white rounded shadow-md w-full"></canvas>
                  <label class="inline-flex items-center space-x-2">
                    <input type="checkbox" id="showIntegralSteps" class="text-black">
                    <span>Hi·ªán chi ti·∫øt t·ª´ng b∆∞·ªõc</span>
                  </label>
                  <div id="integralStepsTable"
                    class="overflow-auto max-h-64 bg-black/20 p-2 rounded hidden text-xs text-white font-mono"></div>
                </div>
              </div>

              <hr class="my-4 border-t border-dashed border-gray-300" />

              <!-- T√≠nh T√≠ch Ph√¢n 2 Bi·∫øn -->
              <div class="space-y-4">
                <h2 class="text-lg font-semibold">üìä T√≠nh T√≠ch Ph√¢n 2 Bi·∫øn (‚à¨ f(x,y) dxdy)</h2>
                <div class="flex items-center gap-2">

                  <label for="integralFormula1D" class="w-16">H√†m s·ªë:</label>
                  <input id="integralFormula2D" type="text" placeholder="f(x,y) = x*y"
                    class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div id="rangeInputs" class="grid grid-cols-3 gap-2 text-sm text-white font-medium"></div>
                <script>
                  const fields = [
                    { id: 'a2D', label: 'x min', value: '0' },
                    { id: 'b2D', label: 'x max', value: '0' },
                    { id: 'stepsX', label: 'S·ªë b∆∞·ªõc X', value: '0' },
                    { id: 'c2D', label: 'y min', value: '0' },
                    { id: 'd2D', label: 'y max', value: '0' },
                    { id: 'stepsY', label: 'S·ªë b∆∞·ªõc Y', value: '0' },
                  ];

                  const rangeInputsContainer = document.getElementById('rangeInputs');
                  fields.forEach(({ label, id, value }) => {
                    const div = document.createElement('label');
                    div.className = 'flex flex-col';
                    div.innerHTML = `${label} <input id="${id}" type="number" placeholder="${label}" value="${value}" class="w-48 text-black px-2 py-1 rounded-lg">`;
                    rangeInputsContainer.appendChild(div);
                  });
                </script>
                <div class="flex justify-between items-center mt-2">
                  <div id="resultIntegral2D" class="text-yellow-300 font-bold"></div>
                  <button onclick="computeIntegral2D()"
                    class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">
                    üßÆ T√≠nh
                  </button>
                </div>
                <div class="flex items-center gap-2">
                  <label for="colormapSelect" class="w-32">Ch·ªçn Colormap:</label>
                  <select id="colormapSelect" class="text-black px-2 py-1 rounded">
                    <option value="viridis">Viridis</option>
                    <option value="plasma">Plasma</option>
                    <option value="turbo">Turbo</option>
                    <option value="gray">Gray</option>
                  </select>
                </div>

                <canvas id="integralHeatmap2D" width="600" height="250"
                  class="mt-4 border border-gray-300 rounded bg-white shadow-md w-full"></canvas>
              </div>

            </div>
          </div>
          <!-- Tab: ƒê·ªì th·ªã 2D -->
          <div id="tab-graph2D" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">
              <h2 class="text-lg font-semibold">üìà H√†m S·ªë 2D: y = f(x)</h2>
              <div class="flex items-center gap-2">
                <label for="inputFormula2D" class="w-16">H√†m s·ªë:</label>
                <input id="inputFormula2D" type="text" placeholder="y = x^3 - 3x - 1"
                  class="w-full text-black px-2 py-1 rounded" />
              </div>
              <div class="flex justify-between items-center mt-2">
                <button onclick="plot2D()" class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">
                  üìà V·∫Ω ƒê·ªì Th·ªã 2D
                </button>
              </div>
              <canvas id="graph2D" class="mt-4 border border-gray-300 rounded bg-white shadow-md w-full" width="600"
                height="250"></canvas>
              <script>
                let chart2D;

                function plot2D() {
                  const input = document.getElementById("inputFormula2D").value.trim();
                  if (!/^y\s*=/.test(input)) {
                    alert("Vui l√≤ng nh·∫≠p c√¥ng th·ª©c d∆∞·ªõi d·∫°ng: y = f(x)");
                    return;
                  }


                  const exprStr = input
                    .replace(/^y\s*=\s*/, "")   // b·ªè ph·∫ßn y =
                    .replace(/‚àí/g, "-")         // thay d·∫•u tr·ª´ Unicode
                    .replace(/√ó/g, "*")         // thay d·∫•u nh√¢n Unicode n·∫øu c√≥
                    .replace(/√∑/g, "/");        // thay d·∫•u chia Unicode n·∫øu c√≥

                  let expr;
                  try {
                    expr = math.compile(exprStr);
                  } catch (e) {
                    alert("C√¥ng th·ª©c sai: " + e.message);
                    return;
                  }

                  const xValues = [];
                  const yValues = [];
                  for (let x = -10; x <= 10; x += 0.1) {
                    try {
                      const y = expr.evaluate({ x });
                      if (typeof y === "number" && isFinite(y)) {
                        xValues.push(x);
                        yValues.push(y);
                      } else {
                        xValues.push(x);
                        yValues.push(null);
                      }
                    } catch {
                      xValues.push(x);
                      yValues.push(null);
                    }
                  }

                  if (chart2D) chart2D.destroy();

                  const ctx = document.getElementById("graph2D").getContext("2d");
                  chart2D = new Chart(ctx, {
                    type: "line",
                    data: {
                      labels: xValues,
                      datasets: [{
                        label: input,
                        data: yValues,
                        borderColor: "rgb(75, 192, 192)",
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                      }],
                    },
                    options: {
                      responsive: true,
                      scales: {
                        x: { type: "linear", title: { display: true, text: "x" } },
                        y: { title: { display: true, text: "y" } },
                      },
                    },
                  });
                }
              </script>
            </div>
          </div>
          <!-- Tab: ƒê∆∞·ªùng th·∫≥ng -->
          <div id="tab-geometryPanel" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">
              <h2 class="text-lg font-semibold">üß± M·∫∑t Ph·∫≥ng (ax + by + cz + d = 0)</h2>
              <div class="flex justify-between items-center mt-2">
                <button onclick="addPlaneInput()"
                  class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">‚ûï Th√™m m·∫∑t
                  ph·∫≥ng</button>
                <button onclick="drawAllPlanes()"
                  class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">üìê V·∫Ω t·∫•t
                  c·∫£</button>
              </div>
              <div class="space-y-2">
                <span>üßÆ Danh s√°ch ph∆∞∆°ng tr√¨nh m·∫∑t ph·∫≥ng</span>
                <div id="planeList" class="space-y-2"></div>
              </div>
              <h2 class="text-lg font-semibold">üìå Giao tuy·∫øn gi·ªØa hai m·∫∑t ph·∫≥ng</h2>
              <div class="flex justify-between items-center mt-2">
                <div class="w-48 grid grid-cols-2 gap-2 text-sm">
                  <select id="plane1Select" class="text-black p-2 rounded"></select>
                  <select id="plane2Select" class="text-black p-2 rounded"></select>
                </div>
                <button onclick="drawIntersection()"
                  class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">üìè V·∫Ω
                  giao
                  tuy·∫øn</button>
              </div>
              <!-- ƒê∆∞·ªùng th·∫≥ng -->
              <div class="space-y-2">

                <h2 class="text-lg font-semibold">üìè ƒê∆∞·ªùng th·∫≥ng (tham s·ªë)</h2>
                <div class="flex items-center gap-2">
                  <label for="x0" class="w-16">H√†m s·ªë:</label>
                  <input id="x0" type="text" placeholder="x = x0 + at" class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="y0" class="w-16">H√†m s·ªë:</label>
                  <input id="y0" type="text" placeholder="y = y0 + bt" class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="z0" class="w-16">H√†m s·ªë:</label>
                  <input id="z0" type="text" placeholder="z = z0 + ct" class="w-full text-black px-2 py-1 rounded" />
                </div>
                <button onclick="drawLine3D()" class="bg-green-600 hover:bg-green-700 w-full py-2 rounded">üìà V·∫Ω ƒë∆∞·ªùng
                  th·∫≥ng</button>
              </div>


              <span>üéØ Ki·ªÉm tra quan h·ªá gi·ªØa 2 vector</span>
              <div class="grid grid-cols-2 gap-2">
                <input id="v1" class="text-black px-2 py-1 rounded" placeholder="VD: [1,2,3]">
                <input id="v2" class="text-black px-2 py-1 rounded" placeholder="VD: [-1,4,2]">
              </div>
              <button onclick="checkVectors()" class="w-full py-1 rounded bg-indigo-600 hover:bg-indigo-700 mt-2">üîç
                Ki·ªÉm
                Tra</button>
              <div id="checkResult" class="text-sm text-white mt-2"></div>
              <script>
                function checkVectors() {
                  const v1 = JSON.parse(document.getElementById('v1').value);
                  const v2 = JSON.parse(document.getElementById('v2').value);
                  const vec1 = new THREE.Vector3(...v1);
                  const vec2 = new THREE.Vector3(...v2);

                  const dot = vec1.dot(vec2);
                  const cross = new THREE.Vector3().crossVectors(vec1, vec2);
                  let result = "";

                  if (dot === 0) result += "‚úÖ Hai vector vu√¥ng g√≥c<br/>";
                  if (cross.length() === 0) result += "‚úÖ Hai vector song song<br/>";
                  if (!result) result = "‚ùå Kh√¥ng vu√¥ng g√≥c, kh√¥ng song song";

                  document.getElementById('checkResult').innerHTML = result;
                }

              </script>
            </div>
          </div>
          <!-- Tab: ƒê·∫°o h√†m -->
          <div id="tab-derivative" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">
              <h2 class="text-lg font-semibold">üßÆ C√¥ng Th·ª©c z = f(x, y)</h2>
              <div class="flex items-center gap-2">
                <label for="inputFormula" class="w-16">H√†m s·ªë:</label>
                <input id="inputFormula" type="text" placeholder="z = sin(x) + cos(y)"
                  class="w-60 text-black p-2 rounded" />
                <div class="flex justify-between items-center">
                  <select id="mode" class="text-black p-2 rounded-lg">
                    <option value="surface">B·ªÅ M·∫∑t M·ªãn</option>
                    <option value="line">D·∫°ng Line</option>
                  </select>
                </div>
              </div>
              <div id="axis-inputs" class="grid grid-cols-2 gap-2 text-sm text-white font-medium"></div>

              <script>
                const axisParams = [
                  { label: 'X min', id: 'xMin', value: -50 },
                  { label: 'X max', id: 'xMax', value: 50 },
                  { label: 'Y min', id: 'yMin', value: -50 },
                  { label: 'Y max', id: 'yMax', value: 50 }
                ];

                const axisInputsContainer = document.getElementById('axis-inputs');

                axisParams.forEach(param => {
                  const label = document.createElement('label');
                  label.className = 'flex flex-col';

                  label.innerHTML = `
                  ${param.label}
                  <input id="${param.id}" type="number" value="${param.value}" class="text-black px-2 py-1 rounded-lg">
                `;

                  axisInputsContainer.appendChild(label);
                });
              </script>
              <div class="flex items-center gap-2">
                <label for="resolution" class="w-40">üéöÔ∏è ƒê·ªô ph√¢n gi·∫£i:</label>
                <input id="resolution" type="range" min="5" max="50" value="25" class="w-full">
              </div>
              <button onclick="plotSurface()" class="border p-2 rounded bg-green-600 hover:bg-green-700 text-white">üìâ
                V·∫Ω ƒê·ªì Th·ªã
              </button>
              <button onclick="computeDerivatives()"
                class="bg-blue-600 hover:bg-blue-700 transition p-2 rounded-xl font-semibold">T√≠nh ƒê·∫°o
                H√†m</button>

              <div class="space-y-2">
                <span>üßÆ ƒê·∫°o h√†m & Vi ph√¢n</span>

                <div id="derivativeResult"
                  class="text-sm text-white bg-white/10 p-2 rounded-lg whitespace-pre-line mt-2">
                </div>

                <button onclick="plotDerivative('dx')" class="border px-3 py-1 rounded">‚àÇz/‚àÇx</button>
                <button onclick="plotDerivative('dy')" class="border px-3 py-1 rounded">‚àÇz/‚àÇy</button>
                <button onclick="plotDerivative('dx2')" class="border px-3 py-1 rounded">‚àÇ¬≤z/‚àÇx¬≤</button>
                <button onclick="plotDerivative('dy2')" class="border px-3 py-1 rounded">‚àÇ¬≤z/‚àÇy¬≤</button>
                <button onclick="plotDerivative('dxdy')" class="border px-3 py-1 rounded">‚àÇ¬≤z/‚àÇx‚àÇy</button>
                <script>
                  let derivatives = {}; // l∆∞u l·∫°i c√°c c√¥ng th·ª©c ƒë·∫°o h√†m
                  function plotDerivative(key) {
                    const formula = derivatives[key];
                    if (!formula) {
                      alert("‚ùó Vui l√≤ng nh·∫•n 'T√≠nh ƒê·∫°o H√†m' tr∆∞·ªõc khi v·∫Ω ƒë·ªì th·ªã.");
                      return;
                    }

                    const formulaInput = document.getElementById("inputFormula");
                    formulaInput.value = "z = " + formula;
                    plotSurface(); // v·∫Ω l·∫°i ƒë·ªì th·ªã d·ª±a tr√™n input
                  }
                  function computeDerivatives() {
                    const input = document.getElementById("inputFormula").value;
                    const expr = input.replace(/^z\s*=\s*/, "");

                    try {
                      const dz_dx = math.derivative(expr, 'x').toString();
                      const dz_dy = math.derivative(expr, 'y').toString();
                      const d2z_dx2 = math.derivative(dz_dx, 'x').toString();
                      const d2z_dy2 = math.derivative(dz_dy, 'y').toString();
                      const d2z_dxdy = math.derivative(dz_dx, 'y').toString();

                      // T√≠nh vi ph√¢n ƒë·∫ßy ƒë·ªß
                      const differential = `dz = (${dz_dx}) dx + (${dz_dy}) dy`;

                      // L∆∞u c√¥ng th·ª©c ƒë·ªÉ v·∫Ω ƒë·ªì th·ªã
                      derivatives = {
                        dx: dz_dx,
                        dy: dz_dy,
                        dx2: d2z_dx2,
                        dy2: d2z_dy2,
                        dxdy: d2z_dxdy
                      };

                      const result = `
                  ‚àÇz/‚àÇx = ${dz_dx}
                  ‚àÇz/‚àÇy = ${dz_dy}
                  ‚àÇ¬≤z/‚àÇx¬≤ = ${d2z_dx2}
                  ‚àÇ¬≤z/‚àÇy¬≤ = ${d2z_dy2}
                  ‚àÇ¬≤z/‚àÇx‚àÇy = ${d2z_dxdy}
                  
                  ${differential}
                        `.trim();

                      document.getElementById("derivativeResult").innerText = result;

                    } catch (err) {
                      document.getElementById("derivativeResult").innerText = "‚ùå L·ªói c√¥ng th·ª©c ho·∫∑c kh√¥ng th·ªÉ t√≠nh ƒë·∫°o h√†m.";
                    }
                  }
                </script>
              </div>
            </div>
          </div>
          <!-- Tab: ƒê·ªì th·ªã c·ª±c -->
          <div id="tab-polarGraph" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">

              <h2 class="text-lg font-semibold">üìà C√¥ng Th·ª©c r = f(Œ∏)</h2>

              <div class="space-y-2">
                <!-- Dropdown ch·ªçn c√¥ng th·ª©c m·∫´u -->
                <div class="flex items-center gap-2">
                  <label for="formulaSelect" class="w-20">M·∫´u:</label>
                  <select id="formulaSelect" class="flex-1 px-2 py-1 rounded text-black">
                    <option value="">-- Ch·ªçn c√¥ng th·ª©c m·∫´u --</option>

                    <!-- C∆° b·∫£n -->
                    <option value="theta">r = Œ∏</option>
                    <option value="3 * theta">r = 3Œ∏</option>
                    <option value="sqrt(theta)">r = ‚àöŒ∏</option>
                    <option value="theta * sin(theta)">r = Œ∏ * sin(Œ∏)</option>

                    <!-- H√†m l∆∞·ª£ng gi√°c ph·ªï bi·∫øn -->
                    <option value="10 * sin(3 * theta)">r = 10 * sin(3Œ∏)</option>
                    <option value="5 + 2 * cos(4 * theta)">r = 5 + 2 * cos(4Œ∏)</option>
                    <option value="2 * sin(2 * theta)">r = 2 * sin(2Œ∏)</option>
                    <option value="4 * cos(3 * theta)">r = 4 * cos(3Œ∏)</option>
                    <option value="6 * sin(theta) * cos(theta)">r = 6 * sin(Œ∏) * cos(Œ∏)</option>
                    <option value="abs(4 * sin(2 * theta))">r = |4 * sin(2Œ∏)|</option>
                    <option value="sqrt(abs(cos(2 * theta)))">r = ‚àö|cos(2Œ∏)|</option>
                    <option value="8 * sin(theta) - 2">r = 8 * sin(Œ∏) - 2</option>

                    <!-- C√°c h√†m ƒë·∫∑c bi·ªát v√† h√¨nh ƒë·∫πp -->
                    <option value="exp(cos(theta)) - 2 * cos(4 * theta) + pow(sin(theta / 12), 5)">
                      r = e<sup>cosŒ∏</sup> - 2cos(4Œ∏) + sin‚Åµ(Œ∏/12)
                    </option>
                    <option value="1 / (1 - 0.8 * cos(theta))">r = 1 / (1 - 0.8 * cos(Œ∏))</option>
                    <option value="1 / (1 + 0.8 * sin(theta))">r = 1 / (1 + 0.8 * sin(Œ∏))</option>

                    <!-- H√¨nh hoa / rosette -->
                    <option value="5 * sin(5 * theta)">r = 5 * sin(5Œ∏) üå∏</option>
                    <option value="7 * cos(7 * theta)">r = 7 * cos(7Œ∏) üåº</option>
                    <option value="10 * sin(theta) + 5 * sin(3 * theta)">r = 10sin(Œ∏) + 5sin(3Œ∏)</option>

                    <!-- H√¨nh tr√°i tim (cardioid) -->
                    <option value="1 - sin(theta)">r = 1 - sin(Œ∏) ‚ù§Ô∏è</option>
                    <option value="1 + cos(theta)">r = 1 + cos(Œ∏) üíô</option>

                    <!-- H√¨nh l·∫° -->
                    <option value="theta * cos(theta)">r = Œ∏ * cos(Œ∏)</option>
                    <option value="theta * sin(5 * theta)">r = Œ∏ * sin(5Œ∏)</option>
                    <option value="abs(sin(2 * theta)) + abs(cos(3 * theta))">r = |sin(2Œ∏)| + |cos(3Œ∏)|</option>
                  </select>
                </div>



                <!-- Nh·∫≠p c√¥ng th·ª©c -->
                <div class="flex items-center gap-2">
                  <label for="polarFormula" class="w-20">H√†m s·ªë:</label>
                  <input id="polarFormula" type="text" placeholder="r = 10 * sin(3 * theta)"
                    class="flex-1 text-black px-2 py-1 rounded" />
                </div>

                <!-- Tu·ª≥ ch·ªçn v√† n√∫t v·∫Ω -->
                <div class="flex justify-between items-center mt-2">
                  <label class="flex items-center gap-2 text-white font-mono">
                    <input id="moveCameraPolar" type="checkbox" class="form-checkbox text-blue-500" checked />
                    T·ª± ƒë·ªông di chuy·ªÉn cam khi v·∫Ω c·ª±c
                  </label>
                  <button onclick="plotPolar()"
                    class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">
                    üìâ V·∫Ω ƒê·ªì Th·ªã C·ª±c
                  </button>
                </div>
              </div>


              <div class="space-y-2">
                <!-- Dropdown ch·ªçn c√¥ng th·ª©c 3D m·∫´u -->
                <div class="flex items-center gap-2">
                  <label for="customFormulaSelect" class="w-20">M·∫´u:</label>
                  <select id="customFormulaSelect" class="flex-1 px-2 py-1 rounded text-black">
                    <option value="">-- Ch·ªçn c√¥ng th·ª©c m·∫´u --</option>

                    <!-- C∆° b·∫£n -->
                    <option value="x = cos(t); y = sin(t); z = t">Helix: x = cos(t), y = sin(t), z = t</option>
                    <option value="x = t; y = t * t; z = t * t * t">Parabol 3D: x = t, y = t¬≤, z = t¬≥</option>
                    <option value="x = t; y = sin(t); z = cos(t)">Sine + Cosine Wave</option>
                    <option value="x = t; y = sin(2*t); z = cos(3*t)">S√≥ng ƒëa t·∫ßn</option>

                    <!-- H√¨nh h·ªçc xo·∫Øn -->
                    <option value="x = 10 * sin(t); y = 10 * cos(t); z = 0.5 * t">Spiral Xo·∫Øn</option>
                    <option value="x = sin(t); y = cos(t); z = sin(2 * t)">Double Sine</option>
                    <option value="x = sin(t); y = t; z = cos(t)">Sin-Z Path</option>

                    <!-- Lissajous & Lemniscate -->
                    <option value="x = sin(2 * t); y = cos(3 * t); z = sin(t)">Lissajous 3D</option>
                    <option value="x = cos(t); y = sin(t); z = cos(2*t)">Lemniscate-like</option>

                    <!-- K√©p v√† t·ªï h·ª£p -->
                    <option value="x = 5 * sin(t); y = 5 * cos(t); z = 5 * sin(2 * t)">K√©p sin</option>
                    <option value="x = sin(3*t); y = cos(5*t); z = sin(t)">T·ªï h·ª£p h√†i</option>
                    <option value="x = t * cos(t); y = t * sin(t); z = t">Archimedean Spiral</option>

                    <!-- H√¨nh kh·ªëi ·∫£o -->
                    <option value="x = sin(t) * cos(t); y = cos(t); z = sin(t)">H√¨nh tr·ª©ng 3D</option>
                    <option value="x = abs(sin(t)); y = abs(cos(t)); z = t">H√¨nh n√≥n r·ªùi r·∫°c</option>
                    <option value="x = sin(t) + cos(2*t); y = cos(t) - sin(2*t); z = sin(t)">H√¨nh u·ªën l∆∞·ª£n</option>

                    <!-- ƒê·∫∑c bi·ªát -->
                    <option value="x = sin(t) * sqrt(abs(t)); y = cos(t) * sqrt(abs(t)); z = t">B√≥ hoa xo·∫Øn</option>
                    <option value="x = log(t); y = sin(t); z = cos(t)">Logarithmic path</option>
                    <option value="x = 1 / (1 + 0.3 * cos(t)); y = t; z = sin(t)">C√°nh cung ngh·ªãch ƒë·∫£o</option>
                  </select>
                </div>

                <h2 class="text-lg font-semibold">üßÆ C√¥ng Th·ª©c T√πy Ch·ªânh (x, y, z)</h2>
                <div class="flex items-center gap-2">
                  <label for="customX" class="w-16">H√†m s·ªë:</label>
                  <input id="customX" type="text" placeholder="x = ..." class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="customY" class="w-16">H√†m s·ªë:</label>
                  <input id="customY" type="text" placeholder="y = ..." class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="customZ" class="w-16">H√†m s·ªë:</label>
                  <input id="customZ" type="text" placeholder="z = ..." class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div id="paramControls" class="grid grid-cols-3 gap-2 text-sm text-white font-medium">

                  <script>
                    const paramData = [
                      { label: 't min', id: 'tMin', value: 0 },
                      { label: 't max', id: 'tMax', value: 6.28 },
                      { label: 'res', id: 'tRes', value: 200 }
                    ];

                    const paramDatacontainer = document.getElementById('paramControls');
                    paramData.forEach(({ label, id, value }) => {
                      const wrapper = document.createElement('label');
                      wrapper.className = 'flex flex-col';
                      wrapper.innerHTML = `${label} <input id="${id}" type="number" value="${value}" class="w-32 text-black px-2 py-1 rounded-lg">`;
                      paramDatacontainer.appendChild(wrapper);
                    });

                  </script>
                </div>

                <div class="flex justify-between items-center mt-2">
                  <div class="flex items-center space-x-2 mt-2 text-white font-mono">
                    <input id="moveCameraCustom" type="checkbox" class="form-checkbox text-blue-500" checked>
                    <label for="moveCameraCustom">T·ª± ƒë·ªông di chuy·ªÉn cam khi v·∫Ω</label>
                  </div>
                  <button onclick="plotCustom3D()"
                    class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">üìâ
                    V·∫Ω H√¨nh T√πy Ch·ªânh
                  </button>
                  <label class="flex items-center gap-2 mt-2">
                    <input id="customCurveMotion" type="checkbox" class="form-checkbox" checked>
                    √Åp d·ª•ng hi·ªáu ·ª©ng cho h√†m t√πy ch·ªânh
                  </label>

                </div>

              </div>
            </div>
          </div>
        </div>

        <!-- N√∫t tab d·ªçc b√™n ph·∫£i -->
        <div id="tabContainer"
          class="custom-scroll overflow-auto max-h-80 flex flex-col border-l border-white/20 p-2 space-y-2 text-xl font-semibold min-w-[7rem]">
          <script>
            const tabs = [
            { id: 'tab-display', label: 'üéõÔ∏è Hi·ªÉn Th·ªã' },
              { id: 'tab-sample', label: 'M·∫´u H√¨nh' },
              { id: 'tab-derivative', label: 'ƒê·∫°o h√†m' },
              { id: 'tab-view', label: 'üß≠ G√≥c Nh√¨n' },
              { id: 'tab-light', label: 'üí° √Ånh S√°ng' },
              { id: 'tab-history', label: 'üßæ L·ªãch s·ª≠' },
              { id: 'tab-graph2D', label: 'ƒê·ªì th·ªã 2D' },
              { id: 'tab-polarGraph', label: 'ƒê·ªì th·ªã c·ª±c' },
              { id: 'tab-integral', label: '‚à´ T√≠ch Ph√¢n' },
              { id: 'tab-geometryPanel', label: 'ƒê∆∞·ªùng th·∫≥ng' },
              { id: 'tab-vector', label: 'Vector' },
              { id: 'tab-export', label: 'üì∏ Xu·∫•t' },
            ];

            const tabContainer = document.getElementById('tabContainer');
            tabContainer.innerHTML = tabs.map((tab, index) => `
              <button class="tab-btn ${index === 0 ? 'active-tab' : ''}"
                      onclick="switchTab(event, '${tab.id}')">${tab.label}</button>
            `).join('');

            function switchTab(evt, tabId) {
              document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
              document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active-tab'));
              document.getElementById(tabId).classList.remove('hidden');
              evt.currentTarget.classList.add('active-tab');
            }
          </script>
        </div>


      </div>
    </div>

  </div>

  <!-- N√∫t 3 g·∫°ch ƒë·ªÉ b·∫≠t menu -->
  <button onclick="toggleMenu()" class="fixed top-4 right-4 z-40 p-2 bg-black/80 text-white rounded-md shadow-md">
    <!-- Bi·ªÉu t∆∞·ª£ng 3 g·∫°ch -->
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"
      stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
    </svg>
  </button>

  <!-- Floating Menu -->
  <div id="floatingMenu"
    class="hidden fixed top-4 right-20 translate-x-1/2 z-30 bg-black/80 text-white rounded-xl px-4 py-3 space-y-2 shadow-xl border border-white/10">
    <script>
      function toggleMenu() {
        const menu = document.getElementById('floatingMenu');
        menu.classList.toggle('hidden');
      }
      function toggleDiv(id) {
        const el = document.getElementById(id);
        if (el) {
          el.classList.toggle('hidden');
        }
      }
      const panels = [
        { id: 'formulaPanel', label: 'üìê C√¥ng Th·ª©c' },
        { id: 'formulaPanel2D', label: 'üìê C√¥ng Th·ª©c 2D' },
        { id: 'geometryPanel', label: 'üìê Ph∆∞∆°ng Tr√¨nh H√¨nh H·ªçc' },
        { id: 'customFormula', label: 'C√¥ng th·ª©c t√πy ch·ªânh' }

      ];

      document.addEventListener('DOMContentLoaded', () => {
        const floatingMenu = document.getElementById('floatingMenu');
        if (!floatingMenu) return;

        panels.forEach(panel => {
          const wrapper = document.createElement('div');
          wrapper.className = 'flex items-center space-x-2';

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `toggle${panel.id.charAt(0).toUpperCase() + panel.id.slice(1)}`;
          checkbox.onchange = () => toggleDiv(panel.id);

          const label = document.createElement('label');
          label.htmlFor = checkbox.id;
          label.textContent = panel.label;

          wrapper.appendChild(checkbox);
          wrapper.appendChild(label);
          floatingMenu.appendChild(wrapper);
        });
      });
    </script>
  </div>



  <script>
    const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(60, 60, 60);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Label renderer
const labelRenderer = new THREE.CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.top = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
document.body.appendChild(labelRenderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;


let gridHelper = new THREE.GridHelper(100, 20);
scene.add(gridHelper);

// Light
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const light = new THREE.PointLight(0xffffff, 1);
light.position.set(50, 50, 100);
scene.add(light);

// H√†m t·∫°o tr·ª•c
let axisGroup = new THREE.Group(); // Nh√≥m ch·ª©a c√°c tr·ª•c
scene.add(axisGroup);

function createFullAxis(axis = 'x', length = 50, color = 0xffffff) {
  const dirMap = {
    x: new THREE.Vector3(1, 0, 0),
    y: new THREE.Vector3(0, 1, 0),
    z: new THREE.Vector3(0, 0, 1)
  };

  const dir = dirMap[axis];
  if (!dir) return;

  // ƒê∆∞·ªùng tr·ª•c t·ª´ -length ƒë·∫øn +length
  const points = [
    dir.clone().multiplyScalar(-length),
    dir.clone().multiplyScalar(length)
  ];
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color });
  const line = new THREE.Line(geometry, material);
  axisGroup.add(line); // ‚úÖ Th√™m v√†o group

  // M≈©i t√™n d∆∞∆°ng
  const arrowPos1 = dir.clone().multiplyScalar(length);
  const arrow1 = new THREE.ArrowHelper(dir.clone().normalize(), arrowPos1, 3, color, 1, 0.5);
  axisGroup.add(arrow1); // ‚úÖ

  // M≈©i t√™n √¢m
  const dirNeg = dir.clone().negate();
  const arrowPos2 = dirNeg.clone().multiplyScalar(length);
  const arrow2 = new THREE.ArrowHelper(dirNeg.normalize(), arrowPos2, 3, color, 1, 0.5);
  axisGroup.add(arrow2); // ‚úÖ
}



// G·ªçi c√°c tr·ª•c nh∆∞ tr∆∞·ªõc
createFullAxis('x', 50, 0xff0000);
createFullAxis('y', 50, 0x00ff00);
createFullAxis('z', 50, 0x00ffff);



// Labels
function createLabel(text, pos, color) {
  const div = document.createElement('div');
  div.textContent = text;
  div.style.color = color;
  div.style.fontWeight = 'bold';
  const label = new THREE.CSS2DObject(div);
  label.position.copy(pos);
  axisGroup.add(label); // üü¢ add v√†o group lu√¥n
  return label; // ‚úÖ tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng label

}
const oLabel = createLabel('.', new THREE.Vector3(0, 0, 0), 'white');
const xLabel = createLabel('X', new THREE.Vector3(55, 0, 0), 'red');
const yLabel = createLabel('Y', new THREE.Vector3(0, 55, 0), 'lime');
const zLabel = createLabel('Z', new THREE.Vector3(0, 0, 55), 'cyan');

let axisTicksGroup = new THREE.Group(); // Nh√≥m ƒë·ªÉ d·ªÖ ·∫©n/hi·ªán t·∫•t c·∫£ tick


// D√πng nh√≥m ƒë·ªÉ ch·ª©a t·∫•t c·∫£ ticks
function addAxisTicks(axis = 'x', step = 5, min = -50, max = 50, color = 'white') {
  const dirVectors = {
    x: {
      from: (i) => [new THREE.Vector3(i, -0.5, 0), new THREE.Vector3(i, 0.5, 0)],
      pos: (i) => new THREE.Vector3(i, 0, 0)
    },
    y: {
      from: (i) => [new THREE.Vector3(-0.5, i, 0), new THREE.Vector3(0.5, i, 0)],
      pos: (i) => new THREE.Vector3(0, i, 0)
    },
    z: {
      from: (i) => [new THREE.Vector3(0, -0.5, i), new THREE.Vector3(0, 0.5, i)],
      pos: (i) => new THREE.Vector3(0, 0, i)
    }
  };

  const data = dirVectors[axis];
  if (!data) return;

  const material = new THREE.LineBasicMaterial({ color });

  for (let i = min; i <= max; i += step) {
    if (i === 0) continue;

    const points = data.from(i);
    const tick = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(points),
      material
    );
    axisTicksGroup.add(tick);

    const label = createLabel(`${i}`, data.pos(i), color);
    axisTicksGroup.add(label);
  }
}
function updateAxisAll() {
  const checkboxes = document.querySelectorAll('.axis-checkbox');
  const selectedAxes = Array.from(checkboxes)
    .filter(cb => cb.checked)
    .map(cb => cb.value);

  const length = parseFloat(document.getElementById('axisLengthInput').value);
  const colorHex = document.getElementById('axisColorInput').value;
  const showLabels = document.getElementById('showAxisLabels').checked;
  const showTicks = document.getElementById('showAxisTicks').checked;

  const step = parseFloat(document.getElementById('stepInput').value);
  const min = parseFloat(document.getElementById('minInput').value);
  const max = parseFloat(document.getElementById('maxInput').value);

  // L·∫•y nh√£n ng∆∞·ªùi d√πng nh·∫≠p (n·∫øu r·ªóng th√¨ d√πng m·∫∑c ƒë·ªãnh)
  const labelMap = {
    x: document.getElementById('labelXInput')?.value.trim() || 'X',
    y: document.getElementById('labelYInput')?.value.trim() || 'Y',
    z: document.getElementById('labelZInput')?.value.trim() || 'Z'
  };

  // X√≥a c√°c tr·ª•c v√† ticks c≈©
  axisGroup.clear();
  axisTicksGroup.clear();

  selectedAxes.forEach(axis => {
    // T·∫°o tr·ª•c
    createFullAxis(axis, length, new THREE.Color(colorHex));

    // T·∫°o nh√£n n·∫øu c√≥
    if (showLabels) {
      const labelPos = {
        x: new THREE.Vector3(length + 5, 0, 0),
        y: new THREE.Vector3(0, length + 5, 0),
        z: new THREE.Vector3(0, 0, length + 5)
      };

      const labelColor = {
        x: 'red',
        y: 'lime',
        z: 'cyan'
      };

      createLabel(labelMap[axis], labelPos[axis], labelColor[axis]);
    }

    // T·∫°o ticks n·∫øu c√≥
    if (showTicks) {
      addAxisTicks(axis, step, min, max, colorHex);
    }
  });

  // Nh√£n g·ªëc (0,0,0)
  if (showLabels) {
    createLabel('.', new THREE.Vector3(0, 0, 0), 'white');
  }
}




// Th√™m ticks 1 l·∫ßn
addAxisTicks('x', 5, -50, 50, 'white');
addAxisTicks('y', 5, -50, 50, 'white');
addAxisTicks('z', 5, -50, 50, 'white');
scene.add(axisTicksGroup);

function createFormulaLabel(text, position = new THREE.Vector3(0, 0, 0)) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 512;
  canvas.height = 128;

  ctx.fillStyle = 'white';
  ctx.font = 'bold 32px monospace';
  ctx.fillText(text, 20, 80);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);

  sprite.scale.set(10, 2.5, 1); // t√πy ch·ªânh k√≠ch th∆∞·ªõc
  sprite.position.copy(position.clone().add(new THREE.Vector3(0, 5, 0))); // ƒë·∫∑t ph√≠a tr√™n ƒë·ªì th·ªã

  return sprite;
}


// ‚úÖ H√†m n·ªôi suy tuy·∫øn t√≠nh
const lerp = (a, b, t) => a + (b - a) * t;

// ‚úÖ T·∫°o ƒëi·ªÉm t·ª´ h√†m 1 bi·∫øn
function createParametricPoints(fn, [t0, t1], steps) {
  return Array.from({ length: steps + 1 }, (_, i) => fn(lerp(t0, t1, i / steps)));
}

// ‚úÖ T·∫°o ƒëo·∫°n n·ªëi t·ª´ h√†m 2 bi·∫øn (u, v)
function createParametricSegments(fn, [u0, u1], [v0, v1], segments) {
  const points = [];

  for (let i = 1; i < segments; i++) {
    const u = lerp(u0, u1, i / segments);
    for (let j = 0; j < segments; j++) {
      const v1a = lerp(v0, v1, j / segments);
      const v1b = lerp(v0, v1, (j + 1) / segments);
      points.push(fn(u, v1a), fn(u, v1b)); // vƒ© tuy·∫øn
    }
  }

  for (let j = 0; j < segments; j++) {
    const v = lerp(v0, v1, j / segments);
    for (let i = 0; i < segments; i++) {
      const u1a = lerp(u0, u1, i / segments);
      const u1b = lerp(u0, u1, (i + 1) / segments);
      points.push(fn(u1a, v), fn(u1b, v)); // kinh tuy·∫øn
    }
  }

  return points;
}
// geometryFunctions.js

// üéØ M·∫∑t c·∫ßu 3D
function sphere3D(theta, phi, r = 5) {
  return new THREE.Vector3(
    r * Math.sin(theta) * Math.cos(phi),
    r * Math.sin(theta) * Math.sin(phi),
    r * Math.cos(theta)
  );
}

// ‚ù§Ô∏è Tr√°i tim 3D
function heart3D(t, s = 2.5) {
  return new THREE.Vector3(
    s * 16 * Math.pow(Math.sin(t), 3),
    s * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)),
    s * 4 * Math.sin(2 * t)
  );
}
// üî∑ H√¨nh xuy·∫øn (Torus)
function torus3D(u, v, R = 4, r = 1.5) {
  return new THREE.Vector3(
    (R + r * Math.cos(v)) * Math.cos(u),
    (R + r * Math.cos(v)) * Math.sin(u),
    r * Math.sin(v)
  );
}

// üî∑ S√≥ng Sin 3D
function wave3D(x, z, A = 1, f = 1) {
  return new THREE.Vector3(
    x,
    A * Math.sin(f * (x ** 2 + z ** 2)),
    z
  );
}

// üî∑ H√¨nh xo·∫Øn ·ªëc
function spiral3D(t, a = 0.1, b = 0.2) {
  return new THREE.Vector3(
    a * t * Math.cos(t),
    a * t * Math.sin(t),
    b * t
  );
}

// üî∑ M·∫∑t y√™n ng·ª±a (Hyperbolic Paraboloid)
function saddle3D(x, z) {
  return new THREE.Vector3(
    x,
    x * x - z * z,
    z
  );
}

// üî∑ Elipsoid
function ellipsoid3D(theta, phi, rx = 4, ry = 2, rz = 1.5) {
  return new THREE.Vector3(
    rx * Math.sin(theta) * Math.cos(phi),
    ry * Math.sin(theta) * Math.sin(phi),
    rz * Math.cos(theta)
  );
}
// üî∂ M·∫∑t Parabol 3D
function paraboloid3D(x, z, a = 0.5) {
  return new THREE.Vector3(
    x,
    a * (x * x + z * z),
    z
  );
}
// üî∂ M·∫∑t s√≥ng Sin-Cos 3D
function sincosWave3D(x, z, a = 1) {
  return new THREE.Vector3(
    x,
    a * Math.sin(x) * Math.cos(z),
    z
  );
}
// üî∂ Mobius Strip (D·∫£i Mobius)
function mobius3D(u, v, R = 2) {
  const halfV = v / 2;
  return new THREE.Vector3(
    Math.cos(u) * (R + halfV * Math.cos(u / 2)),
    Math.sin(u) * (R + halfV * Math.cos(u / 2)),
    halfV * Math.sin(u / 2)
  );
}
// üî∂ H√¨nh Ch√≥p Xoay (Cone)
function cone3D(theta, h, r = 1) {
  return new THREE.Vector3(
    r * (1 - h) * Math.cos(theta),
    h,
    r * (1 - h) * Math.sin(theta)
  );
}
// üî∂ Cycloid 3D
function cycloid3D(t, r = 1) {
  return new THREE.Vector3(
    r * (t - Math.sin(t)),
    0,
    r * (1 - Math.cos(t))
  );
}

// üéØ T·∫°o c√°c ƒë·ªëi t∆∞·ª£ng h√¨nh h·ªçc
const heart = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(createParametricPoints(heart3D, [0, Math.PI * 2], 500)),
  new THREE.LineBasicMaterial({ color: 0xff66cc })
);

const sphere = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(sphere3D, [0, Math.PI], [0, Math.PI * 2], 30)),
  new THREE.LineBasicMaterial({ color: 0x66ccff })
);

const torus = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(torus3D, [0, Math.PI * 2], [0, Math.PI * 2], 50)),
  new THREE.LineBasicMaterial({ color: 0xffcc00 })
);

const spiral = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(createParametricPoints(spiral3D, [0, 10 * Math.PI], 1000)),
  new THREE.LineBasicMaterial({ color: 0x00ff99 })
);

const wave = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(wave3D, [-5, 5], [-5, 5], 50)),
  new THREE.LineBasicMaterial({ color: 0x3366ff })
);

const saddle = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(saddle3D, [-3, 3], [-3, 3], 50)),
  new THREE.LineBasicMaterial({ color: 0xff6666 })
);

const ellipsoid = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(ellipsoid3D, [0, Math.PI], [0, Math.PI * 2], 30)),
  new THREE.LineBasicMaterial({ color: 0x00ccff })
);
// üî∂ M·∫∑t Parabol 3D
const paraboloid = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(paraboloid3D, [-3, 3], [-3, 3], 50)),
  new THREE.LineBasicMaterial({ color: 0xcc00cc })
);

// üî∂ S√≥ng Sin-Cos 3D
const sincosWave = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(sincosWave3D, [-5, 5], [-5, 5], 50)),
  new THREE.LineBasicMaterial({ color: 0x00cccc })
);

// üî∂ D·∫£i Mobius
const mobius = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(mobius3D, [0, Math.PI * 2], [-1, 1], 100)),
  new THREE.LineBasicMaterial({ color: 0xff9966 })
);

// üî∂ H√¨nh Ch√≥p Xoay (Cone)
const cone = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(cone3D, [0, Math.PI * 2], [0, 1], 50)),
  new THREE.LineBasicMaterial({ color: 0x9999ff })
);

// üî∂ Cycloid 3D
const cycloid = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(createParametricPoints(cycloid3D, [0, 4 * Math.PI], 300)),
  new THREE.LineBasicMaterial({ color: 0xffcc99 })
);

// ‚úÖ Danh s√°ch ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ x·ª≠ l√Ω chung
const allObjects = [heart, sphere, torus, spiral, wave, saddle, ellipsoid, paraboloid, sincosWave, mobius, cone, cycloid];

// ‚úÖ ·∫®n t·∫•t c·∫£ khi t·∫£i trang v√† th√™m v√†o scene
allObjects.forEach(obj => {
  obj.visible = false;
  scene.add(obj);
});

// Toggle visibility
function toggle(...objects) {
  objects.forEach(obj => {
    if (obj) obj.visible = !obj.visible;
  });
}

// V·∫Ω ƒë·ªì th·ªã m·∫∑t
let surfaceMesh;
let currentLabel;
let formulaLabel; // th√™m d√≤ng n√†y


function plotSurface() {
  let formulaRaw = document.getElementById("inputFormula").value
    .toLowerCase()
    .replace(/‚àí/g, '-')    // d·∫•u tr·ª´ unicode
    .replace(/√ó/g, '*')    // d·∫•u nh√¢n unicode
    .replace(/√∑/g, '/')    // d·∫•u chia unicode
    .replace(/\s+/g, '');  // xo√° kho·∫£ng tr·∫Øng
  const mode = document.getElementById("mode").value;
  const resolution = parseInt(document.getElementById("resolution").value);
  const lightMode = document.getElementById("lightMode").value;

  const xMin = parseFloat(document.getElementById("xMin").value);
  const xMax = parseFloat(document.getElementById("xMax").value);
  const yMin = parseFloat(document.getElementById("yMin").value);
  const yMax = parseFloat(document.getElementById("yMax").value);

  let depVar = null;
  const vars = ['x', 'y', 'z'];
  let indepVars = [];

  for (let v of vars) {
    if (formulaRaw.startsWith(v + '=')) {
      depVar = v;
      indepVars = vars.filter(w => w !== v);
      break;
    }
  }

  if (!depVar) {
    alert('‚ùó Vui l√≤ng nh·∫≠p c√¥ng th·ª©c d∆∞·ªõi d·∫°ng: z = f(x, y)');
    return;
  }

  const exprBody = formulaRaw.split('=')[1];
  let expr;
  try {
    expr = math.compile(exprBody);
  } catch (e) {
    alert('L·ªói c√¥ng th·ª©c: ' + e.message);
    return;
  }

  if (surfaceMesh) scene.remove(surfaceMesh);

  const geometry = new THREE.BufferGeometry();
  const stepX = (xMax - xMin) / resolution;
  const stepY = (yMax - yMin) / resolution;
  const countX = resolution + 1;
  const countY = resolution + 1;
  const points = [];

  for (let i = 0; i <= resolution; i++) {
    const u = xMin + i * stepX;
    for (let j = 0; j <= resolution; j++) {
      const v = yMin + j * stepY;
      let x = 0, y = 0, z = 0;
      const varsObj = {};
      varsObj[indepVars[0]] = u;
      varsObj[indepVars[1]] = v;
      try {
        const result = expr.evaluate(varsObj);
        if (depVar === 'x') {
          x = result; y = u; z = v;
        } else if (depVar === 'y') {
          x = u; y = result; z = v;
        } else {
          x = u; y = v; z = result;
        }
      } catch (e) {
        x = y = z = NaN;
      }
      points.push(x, y, z);
    }
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
  // === T√çNH TO√ÅN UV MAPPING (√°p d·ª•ng √°nh x·∫° ph·∫≥ng t·ª´ x,y) ===
  const uv = [];
  for (let i = 0; i <= resolution; i++) {
    const u = xMin + i * stepX;
    for (let j = 0; j <= resolution; j++) {
      const v = yMin + j * stepY;

      // ƒê∆∞a x v√† y v·ªÅ kho·∫£ng [0,1]
      const uCoord = (u - xMin) / (xMax - xMin);
      const vCoord = (v - yMin) / (yMax - yMin); // Kh√¥ng ƒë·∫£o tr·ª•c Y

      uv.push(uCoord, vCoord);
    }
  }
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));

  if (mode === 'surface') {
    const indices = [];
    for (let i = 0; i < countX - 1; i++) {
      for (let j = 0; j < countY - 1; j++) {
        const a = i * countY + j;
        const b = a + 1;
        const c = a + countY;
        const d = c + 1;
        indices.push(a, b, d, a, d, c);
      }
    }
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    let material;
    if (lightMode === 'wireframe') {
      material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
    } else {
      const texLoader = new THREE.TextureLoader();
      const texture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
      material = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        map: texture,
        metalness: 0.5,
        roughness: lightMode === 'soft' ? 0.9 : 0.3,
        flatShading: lightMode === 'strong',
        side: THREE.DoubleSide,
      });
    }
    surfaceMesh = new THREE.Mesh(geometry, material);
  } else {
    const group = new THREE.Group();
    for (let i = 0; i < countX; i++) {
      const linePoints = [];
      for (let j = 0; j < countY; j++) {
        const idx = i * countY + j;
        linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
      group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffff00 })));
    }
    for (let j = 0; j < countY; j++) {
      const linePoints = [];
      for (let i = 0; i < countX; i++) {
        const idx = i * countY + j;
        linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
      group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffaa00 })));
    }
    surfaceMesh = group;
  }
  scene.add(surfaceMesh);
  if (formulaLabel) scene.remove(formulaLabel); // Xo√° label c≈© n·∫øu c√≥
  formulaLabel = createFormulaLabel(formulaRaw, new THREE.Vector3(0, 0, 0));
  scene.add(formulaLabel);

  addToHistory(`B·ªÅ m·∫∑t: ${formulaRaw}`, surfaceMesh);
}

function plotPrimitive() {
  const choice = document.getElementById("primitiveShape").value;
  let mesh;
  const material = new THREE.MeshStandardMaterial({ color: 0x33ffff });

  switch (choice) {
    case 'cube':
      mesh = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), material);
      break;
    case 'sphere':
      mesh = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), material);
      break;
    case 'cylinder':
      mesh = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 15, 32), material);
      break;
    case 'cone':
      mesh = new THREE.Mesh(new THREE.ConeGeometry(5, 15, 32), material);
      break;
    case 'circle':
      mesh = new THREE.Mesh(new THREE.CircleGeometry(8, 32), material);
      break;
    case 'ellipse':
      const ellipse = new THREE.Shape();
      ellipse.absellipse(0, 0, 8, 4, 0, Math.PI * 2, false, 0);
      const ellipseGeom = new THREE.ShapeGeometry(ellipse);
      mesh = new THREE.Mesh(ellipseGeom, material);
      break;
    case 'triangle':
      const triShape = new THREE.Shape();
      triShape.moveTo(0, 10);
      triShape.lineTo(-8.66, -5);
      triShape.lineTo(8.66, -5);
      triShape.lineTo(0, 10);
      const triGeom = new THREE.ShapeGeometry(triShape);
      mesh = new THREE.Mesh(triGeom, material);
      break;
    case 'pentagon':
      mesh = polygonMesh(5, 6, material);
      break;
    case 'hexagon':
      mesh = polygonMesh(6, 6, material);
      break;
    case 'pyramid':
      const geom = new THREE.ConeGeometry(7, 10, 4);
      mesh = new THREE.Mesh(geom, material);
      break;
    case 'plane':
      mesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), material);
      break;
    default:
      alert("H√£y ch·ªçn kh·ªëi h√¨nh.");
      return;
  }

  mesh.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, Math.random() * 20 - 10);
  scene.add(mesh);

}

let customCurve; // l∆∞u ƒë∆∞·ªùng c≈© ƒë·ªÉ x√≥a tr∆∞·ªõc khi v·∫Ω m·ªõi

function plotCustom3D() {
  const tMin = parseFloat(document.getElementById("tMin").value);
  const tMax = parseFloat(document.getElementById("tMax").value);
  const res = parseInt(document.getElementById("tRes").value);

  const rawX = document.getElementById("customX").value.trim().toLowerCase();
  const rawY = document.getElementById("customY").value.trim().toLowerCase();
  const rawZ = document.getElementById("customZ").value.trim().toLowerCase();

  if (!rawX.startsWith("x = ") || !rawY.startsWith("y = ") || !rawZ.startsWith("z = ")) {
    alert("Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng: x = ..., y = ..., z = ...");
    return;
  }

  const xExpr = rawX.split("=")[1];
  const yExpr = rawY.split("=")[1];
  const zExpr = rawZ.split("=")[1];

  let fx, fy, fz;
  try {
    fx = math.compile(xExpr);
    fy = math.compile(yExpr);
    fz = math.compile(zExpr);
  } catch (e) {
    alert("L·ªói trong c√¥ng th·ª©c: " + e.message);
    return;
  }

  // Xo√° ƒë∆∞·ªùng cong c≈© n·∫øu c√≥
  if (customCurve) scene.remove(customCurve);

  const points = [];
  for (let i = 0; i <= res; i++) {
    const t = tMin + ((tMax - tMin) * i / res);

    const context = {
      t: t,
      theta: t,
      u: t,
      v: t
    };

    try {
      const x = fx.evaluate(context);
      const y = fy.evaluate(context);
      const z = fz.evaluate(context);

      if (isFinite(x) && isFinite(y) && isFinite(z)) {
        points.push(new THREE.Vector3(x, y, z));
      }
    } catch (e) {
      console.warn("L·ªói khi ƒë√°nh gi√° t·∫°i t =", t, ":", e.message);
    }
  }

  if (points.length < 2) {
    alert("Kh√¥ng ƒë·ªß ƒëi·ªÉm h·ª£p l·ªá ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng.");
    return;
  }
  if (customCurve) {
    scene.remove(customCurve);
    const index = allObjects.indexOf(customCurve);
    if (index !== -1) allObjects.splice(index, 1);
    originalPositions.delete(customCurve);
  }
  
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0xff44aa });
  customCurve = new THREE.Line(geometry, material);
  scene.add(customCurve);
  if (document.getElementById("customCurveMotion").checked) {
    allObjects.push(customCurve);
    originalPositions.set(customCurve, customCurve.position.clone());
  }
  

  addToHistory(`T√πy ch·ªânh 3D`, customCurve);
  const moveCam = document.getElementById("moveCameraCustom").checked;
  if (moveCam) {
    moveCameraTo(points);
  }
}
document.getElementById("customFormulaSelect").addEventListener("change", function () {
  const selected = this.value;
  if (!selected) return;

  // Xo√° ƒë∆∞·ªùng c≈© n·∫øu c√≥
  if (typeof customCurve !== "undefined" && customCurve) {
    scene.remove(customCurve);
  }

  const [xLine, yLine, zLine] = selected.split(";").map(s => s.trim());

  document.getElementById("customX").value = xLine || "";
  document.getElementById("customY").value = yLine || "";
  document.getElementById("customZ").value = zLine || "";

  // G·ªçi h√†m v·∫Ω lu√¥n
  plotCustom3D();
});
function moveCameraTo(points) {
  const center = new THREE.Vector3();
  points.forEach(p => center.add(p));
  center.divideScalar(points.length);

  camera.position.set(center.x + 10, center.y + 10, center.z + 10);
  camera.lookAt(center);
}

// H√†m h·ªó tr·ª£ t·∫°o ƒëa gi√°c 2D ƒë·ªÅu (pentagon, hexagon,...)
function polygonMesh(sides, radius, material) {
  const shape = new THREE.Shape();
  for (let i = 0; i <= sides; i++) {
    const angle = (i / sides) * Math.PI * 2;
    const x = radius * Math.cos(angle);
    const y = radius * Math.sin(angle);
    if (i === 0) shape.moveTo(x, y);
    else shape.lineTo(x, y);
  }
  const geometry = new THREE.ShapeGeometry(shape);
  return new THREE.Mesh(geometry, material);
}


// V·∫Ω ƒë·ªì th·ªã c·ª±c
let lastPolarGraph = null; // Bi·∫øn l∆∞u ƒë·ªì th·ªã c·ª±c g·∫ßn nh·∫•t

function plotPolar() {
  // X√≥a ƒë·ªì th·ªã c·ª±c c≈© n·∫øu c√≥
  if (lastPolarGraph) {
    scene.remove(lastPolarGraph);
    lastPolarGraph.geometry.dispose();
    lastPolarGraph.material.dispose();
    lastPolarGraph = null;
  }

  const formula = document.getElementById("polarFormula").value;
  const expr = math.compile(formula);
  const points = [];

  for (let i = 0; i <= 1000; i++) {
    const theta = (i / 1000) * Math.PI * 2;
    let r = 0;
    try { r = expr.evaluate({ theta }); } catch (e) { }
    const x = r * Math.cos(theta);
    const y = r * Math.sin(theta);
    points.push(new THREE.Vector3(x, 0, y));
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const polarCurve = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff9933 }));

  scene.add(polarCurve);
  lastPolarGraph = polarCurve; // C·∫≠p nh·∫≠t ƒë·ªì th·ªã c·ª±c m·ªõi nh·∫•t

  addToHistory(`ƒê·ªì th·ªã c·ª±c: ${formula}`, polarCurve);

  // Di chuy·ªÉn camera n·∫øu c·∫ßn
  const moveCam = document.getElementById("moveCameraPolar").checked;
  if (moveCam) {
    moveCameraTo(points);
  }
}

document.getElementById("formulaSelect").addEventListener("change", function () {
  const selected = this.value;
  if (selected) {
    document.getElementById("polarFormula").value = selected;
  }
  plotPolar();
});

let planeEquations = [];

function drawAllPlanes() {
  planeEquations = []; // reset danh s√°ch
  const planes = document.querySelectorAll('#planeList > div');
  const select1 = document.getElementById('plane1Select');
  const select2 = document.getElementById('plane2Select');
  select1.innerHTML = "";
  select2.innerHTML = "";

  planes.forEach((div, index) => {
    const inputs = div.querySelectorAll('input');
    const a = parseFloat(inputs[0].value);
    const b = parseFloat(inputs[1].value);
    const c = parseFloat(inputs[2].value);
    const d = parseFloat(inputs[3].value);
    planeEquations.push({ a, b, c, d });

    // render m·∫∑t ph·∫≥ng
    drawPlaneFromParams(a, b, c, d);

    // update dropdown
    const option = `<option value="${index}">M·∫∑t ${index + 1}</option>`;
    select1.innerHTML += option;
    select2.innerHTML += option;
  });
}
function intersectPlanes(p1, p2) {
  const n1 = new THREE.Vector3(p1.a, p1.b, p1.c);
  const n2 = new THREE.Vector3(p2.a, p2.b, p2.c);
  const dir = new THREE.Vector3().crossVectors(n1, n2);

  if (dir.length() < 1e-6) {
    alert("‚ö†Ô∏è Hai m·∫∑t ph·∫≥ng song song ho·∫∑c tr√πng nhau (kh√¥ng c√≥ giao tuy·∫øn)");
    return;
  }

  const A = new THREE.Matrix3();
  A.set(
    p1.a, p1.b, p1.c,
    p2.a, p2.b, p2.c,
    dir.x, dir.y, dir.z
  );

  const D = new THREE.Vector3(-p1.d, -p2.d, 0);
  const Ainv = A.clone().invert();

  if (!Ainv) {
    alert("‚ö†Ô∏è Kh√¥ng t√¨m ƒë∆∞·ª£c ƒëi·ªÉm giao");
    return;
  }

  const point = D.applyMatrix3(Ainv);

  const points = [];
  for (let t = -50; t <= 50; t += 1) {
    const pt = point.clone().add(dir.clone().normalize().multiplyScalar(t));
    points.push(pt);
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
  const line = new THREE.Line(geometry, material);
  scene.add(line);
}
function drawIntersection() {
  const i1 = parseInt(document.getElementById('plane1Select').value);
  const i2 = parseInt(document.getElementById('plane2Select').value);

  if (isNaN(i1) || isNaN(i2) || i1 === i2) {
    alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn hai m·∫∑t ph·∫≥ng kh√°c nhau");
    return;
  }

  const p1 = planeEquations[i1];
  const p2 = planeEquations[i2];

  intersectPlanes(p1, p2);
}

function drawLine3D() {
  const xExpr = document.getElementById('x0').value;
  const yExpr = document.getElementById('y0').value;
  const zExpr = document.getElementById('z0').value;

  const tMin = -10, tMax = 10, steps = 100;
  const points = [];

  for (let i = 0; i <= steps; i++) {
    const t = tMin + (tMax - tMin) * i / steps;
    const x = math.evaluate(xExpr, { t });
    const y = math.evaluate(yExpr, { t });
    const z = math.evaluate(zExpr, { t });
    points.push(new THREE.Vector3(x, y, z));
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  const line = new THREE.Line(geometry, material);

  scene.add(line);
}
function addPlaneInput() {
  const planeList = document.getElementById('planeList');
  const div = document.createElement('div');
  div.className = "flex space-x-1";
  div.innerHTML = `
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="a">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="b">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="c">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="d">
      <button onclick="this.parentElement.remove()" class="text-red-400">‚úñÔ∏è</button>
    `;
  planeList.appendChild(div);
}


function drawPlaneFromParams(a, b, c, d) {
  const geometry = new THREE.PlaneGeometry(100, 100);
  const normal = new THREE.Vector3(a, b, c).normalize();
  const center = normal.clone().multiplyScalar(-d / normal.lengthSq());

  const material = new THREE.MeshStandardMaterial({
    color: Math.random() * 0xffffff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.4
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(center);
  mesh.lookAt(center.clone().add(normal));
  scene.add(mesh);
}


const historyList = document.getElementById('historyList');

function addToHistory(label, object3D) {
  const li = document.createElement('li');
  li.classList.add('flex', 'justify-between', 'items-center');

  const span = document.createElement('span');
  span.textContent = label;
  span.classList.add('cursor-pointer', 'hover:text-yellow-300', 'truncate');

  let visible = true;
  span.addEventListener('click', () => {
    visible = !visible;
    object3D.visible = visible;
    span.style.textDecoration = visible ? 'none' : 'line-through';
  });

  const deleteBtn = document.createElement('button');
  deleteBtn.textContent = 'üóë';
  deleteBtn.classList.add('ml-2', 'hover:text-red-500');
  deleteBtn.addEventListener('click', () => {
    scene.remove(object3D);      // Xo√° kh·ªèi scene
    li.remove();                // Xo√° kh·ªèi giao di·ªán l·ªãch s·ª≠
  });

  li.appendChild(span);
  li.appendChild(deleteBtn);
  historyList.appendChild(li);
}

function updateLightMode() {
  const mode = document.getElementById("lightMode").value;
  const materialType = document.getElementById("materialType").value;
  const textureInput = document.getElementById("textureImage");
  const textureLabel = document.getElementById("textureLabel");

  if (!surfaceMesh) return;

  let newMaterial;

  // ·∫®n/hi·ªán ph·∫ßn ch·ªçn ·∫£nh
  if (materialType === 'texture') {
    textureInput.classList.remove("hidden");
    textureLabel.classList.remove("hidden");
  } else {
    textureInput.classList.add("hidden");
    textureLabel.classList.add("hidden");
  }

  const texLoader = new THREE.TextureLoader();

  switch (materialType) {
    case 'phong':
      newMaterial = new THREE.MeshPhongMaterial({
        color: 0xffaa00,
        shininess: 100,
        side: THREE.DoubleSide
      });
      break;
    case 'lambert':
      newMaterial = new THREE.MeshLambertMaterial({
        color: 0x99ccff,
        side: THREE.DoubleSide
      });
      break;
    case 'toon':
      newMaterial = new THREE.MeshToonMaterial({
        color: 0xff99cc,
        gradientMap: null,
        side: THREE.DoubleSide
      });
      break;
    case 'texture':
      if (textureInput.files && textureInput.files[0]) {
        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;

            const texturedMat = new THREE.MeshStandardMaterial({
              map: texture,
              metalness: 0.2,
              roughness: mode === 'soft' ? 0.9 : 0.3,
              flatShading: mode === 'strong',
              side: THREE.DoubleSide
            });

            applyMaterial(texturedMat); // √Åp d·ª•ng texture l√™n surfaceMesh
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(textureInput.files[0]);
        return; // ‚ö†Ô∏è QUAN TR·ªåNG! Tr√°nh ch·∫°y ti·∫øp c√°c l·ªánh sau
      } else {
        alert("Vui l√≤ng ch·ªçn ·∫£nh.");
        return;
      }

      break;
    case 'standard':
    default:
      const baseTexture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
      newMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        map: baseTexture,
        metalness: 0.5,
        roughness: mode === 'soft' ? 0.9 : 0.3,
        flatShading: mode === 'strong',
        side: THREE.DoubleSide
      });
  }

  // Wireframe override
  if (mode === 'wireframe') {
    newMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      wireframe: true
    });
  }

  applyMaterial(newMaterial);
}

function applyMaterial(material) {
  if (surfaceMesh instanceof THREE.Mesh) {
    surfaceMesh.material.dispose();
    surfaceMesh.material = material;
  }
}
// T√≠nh t√≠ch ph√¢n 1D v√† v·∫Ω
function computeIntegral1D() {
  const formula = document.getElementById("integralFormula1D").value.replace(/^f\(x\)\s*=\s*/, '');
  const a = math.evaluate(document.getElementById("a1D").value); // H·ªó tr·ª£ œÄ, e, sqrt()
  const b = math.evaluate(document.getElementById("b1D").value);
  const steps = parseInt(document.getElementById("integralSteps").value);
  const method = document.getElementById("integralMethod").value;

  const showSteps = document.getElementById("showIntegralSteps").checked;
  const expr = math.compile(formula);

  let area = 0;
  const dx = (b - a) / steps;
  const xVals = [], yVals = [], barData = [];
  let stepsHTML = `<table class="w-full table-auto border-collapse"><thead><tr class="border-b"><th>x</th><th>f(x)</th><th>f(x)¬∑dx</th></tr></thead><tbody>`;

  if (method === "midpoint") {
    for (let i = 0; i < steps; i++) {
      const x = a + (i + 0.5) * dx;
      const y = expr.evaluate({ x });
      const slice = y * dx;
      area += slice;
      xVals.push(x);
      yVals.push(y);
      barData.push({ x: x, y: y });
      if (showSteps) {
        stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>${slice.toFixed(6)}</td></tr>`;
      }
    }
  } else if (method === "trapezoidal") {
    for (let i = 0; i <= steps; i++) {
      const x = a + i * dx;
      const y = expr.evaluate({ x });
      xVals.push(x);
      yVals.push(y);
      barData.push({ x, y });
      if (i === 0 || i === steps) area += y / 2;
      else area += y;
      if (showSteps) {
        stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>-</td></tr>`;
      }
    }
    area *= dx;
  } else if (method === "simpson" && steps % 2 === 0) {
    for (let i = 0; i <= steps; i++) {
      const x = a + i * dx;
      const y = expr.evaluate({ x });
      xVals.push(x);
      yVals.push(y);
      barData.push({ x, y });
      if (i === 0 || i === steps) area += y;
      else if (i % 2 === 0) area += 2 * y;
      else area += 4 * y;
      if (showSteps) {
        stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>-</td></tr>`;
      }
    }
    area *= dx / 3;
  } else {
    alert("Simpson's Rule requires even number of intervals.");
    return;
  }

  stepsHTML += `</tbody></table>`;
  document.getElementById("resultIntegral1D").innerText =
    `‚à´ f(x) dx t·ª´ ${a} ƒë·∫øn ${b} ‚âà ${area.toFixed(6)} (ph∆∞∆°ng ph√°p: ${method})`;

  const detailDiv = document.getElementById("integralStepsTable");
  if (showSteps) {
    detailDiv.innerHTML = stepsHTML;
    detailDiv.classList.remove("hidden");
  } else {
    detailDiv.innerHTML = "";
    detailDiv.classList.add("hidden");
  }

  // V·∫º BI·ªÇU ƒê·ªí
  const ctx = document.getElementById("integralGraph1D").getContext("2d");

  if (window.chartIntegral1D) {
    window.chartIntegral1D.destroy(); // Tr√°nh l·ªói canvas d√πng l·∫°i
  }

  window.chartIntegral1D = new Chart(ctx, {
    type: "bar", // Bi·ªÉu ƒë·ªì thanh + ƒë∆∞·ªùng
    data: {
      datasets: [
        {
          type: "line",
          label: "f(x)",
          data: xVals.map((x, i) => ({ x: x, y: yVals[i] })),
          borderColor: "blue",
          backgroundColor: "rgba(59,130,246,0.2)",
          tension: 0.3,
          fill: true,
          parsing: false
        },
        {
          type: "bar",
          label: "Di·ªán t√≠ch l√°t",
          data: barData,
          backgroundColor: "rgba(34,197,94,0.6)",
          borderWidth: 0,
          parsing: false,
          barThickness: Math.max(1, 300 / steps)
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          type: "linear",
          title: { display: true, text: "x" }
        },
        y: {
          title: { display: true, text: "f(x)" }
        }
      },
      plugins: {
        legend: { position: "top" },
      }
    }
  });
}


const showSteps = document.getElementById("showIntegralSteps").checked;
const detailDiv = document.getElementById("integralStepsTable");
if (showSteps) {
  detailDiv.innerHTML = stepsHTML;
  detailDiv.classList.remove("hidden");
} else {
  detailDiv.innerHTML = "";
  detailDiv.classList.add("hidden");
}

// T√≠nh t√≠ch ph√¢n 2D ƒë∆°n gi·∫£n b·∫±ng ph∆∞∆°ng ph√°p h√¨nh ch·ªØ nh·∫≠t
function computeIntegral2D() {
  const formula = document.getElementById("integralFormula2D").value.replace(/^f\(x,y\)\s*=\s*/, '');
  const xMin = parseFloat(document.getElementById("a2D").value);
  const xMax = parseFloat(document.getElementById("b2D").value);
  const yMin = parseFloat(document.getElementById("c2D").value);
  const yMax = parseFloat(document.getElementById("d2D").value);
  const selectedMap = document.getElementById("colormapSelect").value;

  const expr = math.compile(formula);

  const stepsX = parseInt(document.getElementById("stepsX").value);
  const stepsY = parseInt(document.getElementById("stepsY").value);

  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  let sum = 0;
  for (let i = 0; i <= stepsX; i++) {
    const x = xMin + i * dx;
    for (let j = 0; j <= stepsY; j++) {
      const y = yMin + j * dy;
      const val = expr.evaluate({ x, y });
      if (isFinite(val)) sum += val * dx * dy;
    }
  }

  document.getElementById("resultIntegral2D").innerText =
    `‚à¨ f(x,y) dxdy t·ª´ (${xMin},${yMin}) ƒë·∫øn (${xMax},${yMax}) = ${sum.toFixed(6)}`;
  visualizeIntegral2D();
  draw2DHeatmap(formula, xMin, xMax, yMin, yMax, stepsX, stepsY, selectedMap);

}

function draw2DHeatmap(formula, xMin, xMax, yMin, yMax, stepsX, stepsY, colormapName = "viridis") {
  const ctx = document.getElementById("integralHeatmap2D")?.getContext("2d");
  if (!ctx) return;

  const expr = math.compile(formula);
  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  const data = [];
  let zMin = Infinity, zMax = -Infinity;

  for (let i = 0; i < stepsX; i++) {
    const x = xMin + i * dx + dx / 2;
    for (let j = 0; j < stepsY; j++) {
      const y = yMin + j * dy + dy / 2;
      try {
        const z = expr.evaluate({ x, y });
        if (!isFinite(z)) continue;
        data.push({ x, y, v: z });
        zMin = Math.min(zMin, z);
        zMax = Math.max(zMax, z);
      } catch (e) {
        console.warn(`L·ªói t·∫°i (${x},${y}):`, e.message);
      }
    }
  }

  if (window.heatmap2DChart) window.heatmap2DChart.destroy();

  window.heatmap2DChart = new Chart(ctx, {
    type: 'matrix',
    data: {
      datasets: [{
        label: 'f(x,y)',
        data: data,
        backgroundColor(ctx) {
          const point = ctx.dataset?.data?.[ctx.dataIndex];
          if (!point || typeof point.v !== "number") return "rgba(0,0,0,0)";
          const normalized = (point.v - zMin) / (zMax - zMin || 1);
          return getColorFromMap(normalized, colormapName);
        },

        width(ctx) {
          const area = ctx.chart.chartArea;
          if (!area) return 10;
          return area.width / stepsX;
        },
        height(ctx) {
          const area = ctx.chart.chartArea;
          if (!area) return 10;
          return area.height / stepsY;
        }
      }]
    },
    options: {
      maintainAspectRatio: true,
      responsive: true,
      plugins: {
        tooltip: {
          callbacks: {
            title: () => '',
            label: ctx => {
              const d = ctx.raw;
              return `x: ${d.x.toFixed(2)}, y: ${d.y.toFixed(2)}, z: ${d.v.toFixed(2)}`;
            }
          }
        },
        legend: { display: false }
      },
      scales: {
        x: {
          type: 'linear',
          min: xMin,
          max: xMax,
          title: { display: true, text: 'x' }
        },
        y: {
          type: 'linear',
          min: yMin,
          max: yMax,
          title: { display: true, text: 'y' }
        }
      }
    }
  });
}
document.getElementById("colormapSelect").addEventListener("change", () => {
  computeIntegral2D(); // g·ªçi l·∫°i to√†n b·ªô h√†m ƒë·ªÉ c·∫≠p nh·∫≠t colormap
});


function getColorFromMap(t, mapName = "viridis") {
  t = Math.min(1, Math.max(0, t)); // ƒë·∫£m b·∫£o t ‚àà [0,1]

  // C√°c colormap ph·ªï bi·∫øn
  switch (mapName) {
    case 'plasma':
      return plasmaColorMap(t);
    case 'turbo':
      return turboColorMap(t);
    case 'gray':
      const g = Math.floor(255 * t);
      return `rgba(${g},${g},${g},1)`;
    case 'viridis':
    default:
      return viridisColorMap(t);
  }
}

// Colormap viridis (gi·∫£m nh·∫π ƒë·ªÉ ph√π h·ª£p)
function viridisColorMap(t) {
  const r = Math.floor(255 * Math.max(0, Math.min(1, 0.267 + 1.5 * t)));
  const g = Math.floor(255 * Math.max(0, Math.min(1, 0.004 + 2.0 * t)));
  const b = Math.floor(255 * Math.max(0, Math.min(1, 0.329 + 1.2 * t)));
  return `rgba(${r},${g},${b},1)`;
}

function plasmaColorMap(t) {
  const r = Math.floor(255 * Math.min(1, Math.max(0, 1.5 * t)));
  const g = Math.floor(255 * Math.abs(Math.sin(t * Math.PI)));
  const b = Math.floor(255 * (1 - t));
  return `rgba(${r},${g},${b},1)`;
}

function turboColorMap(t) {
  // https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html
  const r = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.75)))));
  const g = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.5)))));
  const b = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.25)))));
  return `rgba(${r},${g},${b},1)`;
}


function visualizeIntegral2D() {
  const formula = document.getElementById("integralFormula2D").value.replace(/^f\(x,y\)\s*=\s*/, '');
  const xMin = parseFloat(document.getElementById("a2D").value);
  const xMax = parseFloat(document.getElementById("b2D").value);
  const yMin = parseFloat(document.getElementById("c2D").value);
  const yMax = parseFloat(document.getElementById("d2D").value);

  const stepsX = parseInt(document.getElementById("stepsX").value);
  const stepsY = parseInt(document.getElementById("stepsY").value);

  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  const expr = math.compile(formula);
  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const colors = [];
  const color = new THREE.Color();

  for (let i = 0; i < stepsX; i++) {
    for (let j = 0; j < stepsY; j++) {
      const x1 = xMin + i * dx;
      const y1 = yMin + j * dy;
      const x2 = xMin + (i + 1) * dx;
      const y2 = yMin + (j + 1) * dy;

      const z11 = expr.evaluate({ x: x1, y: y1 });
      const z12 = expr.evaluate({ x: x1, y: y2 });
      const z21 = expr.evaluate({ x: x2, y: y1 });
      const z22 = expr.evaluate({ x: x2, y: y2 });

      // 2 m·∫∑t tam gi√°c t·∫°o h√¨nh ch·ªØ nh·∫≠t
      vertices.push(x1, y1, 0, x1, y1, -z11, x2, y1, -z21);
      vertices.push(x1, y1, 0, x2, y1, -z21, x2, y1, 0);

      vertices.push(x1, y2, 0, x1, y2, -z12, x2, y2, -z22);
      vertices.push(x1, y2, 0, x2, y2, -z22, x2, y2, 0);

      const avgZ1 = (z11 + z21) / 2;
      const avgZ2 = (z12 + z22) / 2;
      for (let k = 0; k < 6; k++) {
        color.setHSL(0.6 - 0.6 * (avgZ1 / 10), 1.0, 0.5);
        colors.push(color.r, color.g, color.b);
      }
      for (let k = 0; k < 6; k++) {
        color.setHSL(0.6 - 0.6 * (avgZ2 / 10), 1.0, 0.5);
        colors.push(color.r, color.g, color.b);
      }
    }
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.6
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.name = "integralSurface";

  // X√≥a mesh c≈© n·∫øu c√≥
  const old = scene.getObjectByName("integralSurface");
  if (old) scene.remove(old);

  scene.add(mesh);


  // üîç Camera di chuy·ªÉn l·∫°i g·∫ßn m√¥ h√¨nh sau khi v·∫Ω
  if (camera && controls) {
    const centerX = (xMin + xMax) / 2;
    const centerY = (yMin + yMax) / 2;
    const centerZ = 3; // cao h∆°n m·ªôt ch√∫t ƒë·ªÉ th·∫•y r√µ b·ªÅ m·∫∑t

    controls.target.set(centerX, centerY, 0);
    camera.position.set(centerX, centerY + (xMax - xMin) * 1.5, centerZ + 5);
    controls.update();
  }
}


// Xu·∫•t ·∫£nh
function saveImage() {
  renderer.render(scene, camera);
  const link = document.createElement('a');
  link.download = 'screenshot.png';
  link.href = renderer.domElement.toDataURL('image/png');
  link.click();
}

// // Auto rotate toggle
// let autoRotate = true;
// document.addEventListener('keydown', e => {
//     if (e.key && e.key.toLowerCase() === 'r') {
//         autoRotate = !autoRotate;
//         console.log('Toggled autoRotate:', autoRotate);
//     }
// });
// ‚úÖ ƒê·∫∑t bi·∫øn n√†y ·ªü ƒë·∫ßu file ho·∫∑c tr∆∞·ªõc khi d√πng ƒë·∫øn
// let autoRotate = true;

// // ‚úÖ Hi·ªÉn th·ªã tr·∫°ng th√°i ban ƒë·∫ßu (n·∫øu c√≥)
// const statusEl = document.getElementById('autoRotateStatus');
// function updateAutoRotateStatus() {
//     if (statusEl) {
//         statusEl.textContent = `Auto-Rotate: ${autoRotate ? 'On' : 'Off'}`;
//     }
// }

// // ‚úÖ B·∫Øt ph√≠m R ƒë·ªÉ b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô xoay t·ª± ƒë·ªông
// document.addEventListener('keydown', e => {
//     if (e.key && e.key.toLowerCase() === 'r') {
//         autoRotate = !autoRotate;
//         updateAutoRotateStatus();
//     }
// });
let autoRotate = true;

const toggleButton = document.getElementById('autoRotateToggle');

function updateAutoRotateUI() {
  toggleButton.textContent = autoRotate ? 'On' : 'Off';
  toggleButton.classList.toggle('bg-green-600', autoRotate);
  toggleButton.classList.toggle('bg-red-600', !autoRotate);
}

toggleButton.addEventListener('click', () => {
  autoRotate = !autoRotate;
  updateAutoRotateUI();
});

let formulaVisible = true;
const formulaToggle = document.getElementById('formulaToggle');

function updateFormulaToggleUI() {
  formulaToggle.textContent = formulaVisible ? 'On' : 'Off';
  formulaToggle.classList.toggle('bg-green-600', formulaVisible);
  formulaToggle.classList.toggle('bg-red-600', !formulaVisible);

  if (formulaLabel) {
    formulaLabel.visible = formulaVisible;
  }
}

formulaToggle.addEventListener('click', () => {
  formulaVisible = !formulaVisible;
  updateFormulaToggleUI();
});


let motionEffect = ""; // m·∫∑c ƒë·ªãnh kh√¥ng c√≥ hi·ªáu ·ª©ng
document.getElementById("motionEffect").addEventListener("change", e => {
  motionEffect = e.target.value;
});
let customMotionCode = "";
let customMotionFunc = null;
let lastCompiledCode = "";

document.getElementById("customMotionCode").addEventListener("input", (e) => {
  customMotionCode = e.target.value;
});

// Gi·ªØ v·ªã tr√≠ g·ªëc ban ƒë·∫ßu cho c√°c hi·ªáu ·ª©ng nh∆∞ bounce
const originalPositions = new Map();
allObjects.forEach(obj => {
  originalPositions.set(obj, obj.position.clone());
});

function animate(time) {
  requestAnimationFrame(animate);

  // √Åp d·ª•ng hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông n·∫øu c√≥
  allObjects.forEach(obj => {
    if (!obj.visible) return;

    switch (motionEffect) {
      case "rotateY":
        obj.rotation.y += 0.01;
        break;
      case "rotateX":
        obj.rotation.x += 0.01;
        break;
      case "bounce":
        const orig = originalPositions.get(obj);
        obj.position.y = orig.y + Math.sin(time * 0.005) * 0.5;
        break;
      case "wave":
        obj.rotation.z = Math.sin(time * 0.003) * 0.3;
        obj.position.y = Math.sin(time * 0.002) * 0.4;
        break;
      case "spin":
        obj.rotation.x += 0.01;
        obj.rotation.y += 0.01;
        break;
      case "shake":
        const origShake = originalPositions.get(obj);
        obj.position.x = origShake.x + Math.sin(time * 0.02) * 0.3;
        break;
      case "circle":
        const origCircle = originalPositions.get(obj);
        obj.position.x = origCircle.x + Math.cos(time * 0.002) * 1;
        obj.position.z = origCircle.z + Math.sin(time * 0.002) * 1;
        break;
      case "waveZ":
        obj.rotation.x = Math.sin(time * 0.002) * 0.3;
        obj.position.z = Math.sin(time * 0.003) * 0.4;
        break;
        case "blink":
          if (obj.material) {
            obj.material.transparent = true; // ƒê·∫£m b·∫£o b·∫≠t ch·∫ø ƒë·ªô trong su·ªët
            obj.material.opacity = 0.5 + 0.5 * Math.sin(performance.now() * 0.005);
          }
          break;
          case "float":
            obj.position.y = Math.sin(time * 0.002) * 0.5;
            break;
          case "rotate":
            obj.rotation.y += 0.01;
            break;
          case "pulse":
            const s = 1 + 0.3 * Math.sin(time * 0.004);
            obj.scale.set(s, s, s);
            break;
          case "orbit":
            obj.position.x = Math.sin(time * 0.001) * 5;
            obj.position.z = Math.cos(time * 0.001) * 5;
            obj.lookAt(0, 0, 0);
            break;
          case "flashColor":
            const c = 0.5 + Math.sin(time * 0.01) * 0.5;
            obj.material.color.setRGB(c, 0.2, 1 - c);
            break;
    }

        // ‚ú® Ch·∫°y hi·ªáu ·ª©ng ng∆∞·ªùi d√πng vi·∫øt
        if (customMotionCode.trim()) {
          try {
            // C·ªë t·∫°o tr∆∞·ªõc function 1 l·∫ßn duy nh·∫•t (n·∫øu kh√°c v·ªõi l·∫ßn tr∆∞·ªõc)
            if (customMotionCode !== lastCompiledCode) {
              customMotionFunc = new Function("obj", "time", customMotionCode);
              lastCompiledCode = customMotionCode;
            }
            if (typeof customMotionFunc === "function") {
              customMotionFunc(obj, time);
            }
          } catch (err) {
            console.warn("L·ªói trong custom motion code:", err.message);
            customMotionFunc = null;
          }
        }
        
  });
  if (autoRotate) scene.rotation.y += 0.001;

  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate();
function createShape() {
  const type = document.getElementById('shapeType').value;
  const size = parseFloat(document.getElementById('shapeSize').value);
  const height = parseFloat(document.getElementById('shapeHeight').value);
  const color = document.getElementById('shapeColor').value;

  let geometry;

  switch (type) {
    case 'box':
      geometry = new THREE.BoxGeometry(size, height, size);
      break;
    case 'sphere':
      geometry = new THREE.SphereGeometry(size, 32, 32);
      break;
    case 'cylinder':
      geometry = new THREE.CylinderGeometry(size, size, height, 32);
      break;
  }

  const material = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);

  // ƒê·∫∑t v·ªã tr√≠ ng·∫´u nhi√™n ƒë·ªÉ d·ªÖ nh√¨n
  mesh.position.set(
    (Math.random() - 0.5) * 5,
    (Math.random() - 0.5) * 5,
    (Math.random() - 0.5) * 5
  );

  scene.add(mesh);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
});
let previousCameraPos = new THREE.Vector3(); // L∆∞u camera c≈©
let previousTarget = new THREE.Vector3();    // L∆∞u target c≈© n·∫øu d√πng controls.target

function setViewDirection() {
  const view = document.getElementById("viewSelector").value;

  // L∆∞u camera tr∆∞·ªõc ƒë√≥ n·∫øu ch∆∞a l∆∞u
  if (!previousCameraPos) previousCameraPos = new THREE.Vector3();
  if (!previousTarget) previousTarget = new THREE.Vector3();
  previousCameraPos.copy(camera.position);
  previousTarget.copy(controls.target);

  scene.rotation.set(0, 0, 0);

  switch (view) {
    case 'xy': // Nh√¨n t·ª´ tr√™n xu·ªëng
      camera.position.set(0, 100, 0);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;

      if (zAxis) zAxis.visible = false;
      if (zLabel) zLabel.visible = false;
      break;

    case 'yz': // Nh√¨n t·ª´ tr·ª•c X (tr√°i -> ph·∫£i)
      camera.position.set(100, 0, 0);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;

      if (xAxis) xAxis.visible = false;
      if (xLabel) xLabel.visible = false;
      break;

    case 'xz': // Nh√¨n t·ª´ tr∆∞·ªõc (tr·ª•c Y l√™n)
      camera.position.set(0, 0, 100);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;

      if (yAxis) yAxis.visible = false;
      if (yLabel) yLabel.visible = false;
      break;

    default: // Tr·ªü v·ªÅ 3D
      camera.position.copy(previousCameraPos);
      controls.target.copy(previousTarget);
      controls.enableRotate = true;
      autoRotate = true;

      // Hi·ªán l·∫°i c√°c tr·ª•c
      if (xAxis) xAxis.visible = true;
      if (yAxis) yAxis.visible = true;
      if (zAxis) zAxis.visible = true;
      if (xLabel) xLabel.visible = true;
      if (yLabel) yLabel.visible = true;
      if (zLabel) zLabel.visible = true;
      break;
  }

  controls.update();
  camera.lookAt(controls.target);
}

let points3D = []; // Danh s√°ch c√°c ƒëi·ªÉm ƒë√£ th√™m

function addPoint(pos) {
  // T·∫°o ƒëi·ªÉm
  const point = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 16, 16),
    new THREE.MeshStandardMaterial({ color: 0xff3333 }).clone()
  );
  point.position.copy(pos);
  scene.add(point);

  // T·∫°o nh√£n
  const label = createLabel(`(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, pos.clone().add(new THREE.Vector3(1, 1, 0)), '#fff');

  // L∆∞u l·∫°i ƒë·ªÉ qu·∫£n l√Ω
  points3D.push({ point, label, pos: pos.clone() });

  // N·∫øu c√≥ ƒëi·ªÉm tr∆∞·ªõc ƒë√≥ th√¨ v·∫Ω vector (m≈©i t√™n)
  if (points3D.length >= 2) {
    const from = points3D[points3D.length - 2].pos;
    const to = pos;
    const dir = new THREE.Vector3().subVectors(to, from);
    const arrow = new THREE.ArrowHelper(dir.clone().normalize(), from.clone(), dir.length(), 0xffff00);
    scene.add(arrow);

    // L∆∞u v√†o l·ªãch s·ª≠ (t√πy ch·ªçn)
    addToHistory(`Vector t·ª´ (${from.x.toFixed(1)}, ${from.y.toFixed(1)}, ${from.z.toFixed(1)}) ƒë·∫øn (${to.x.toFixed(1)}, ${to.y.toFixed(1)}, ${to.z.toFixed(1)})`, arrow);
  }

  addToHistory(`ƒêi·ªÉm (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, point);
}

function drawVectorFromInput() {
  const x1 = parseFloat(document.getElementById("x1").value);
  const y1 = parseFloat(document.getElementById("y1").value);
  const z1 = parseFloat(document.getElementById("z1").value);

  const x2 = parseFloat(document.getElementById("x2").value);
  const y2 = parseFloat(document.getElementById("y2").value);
  const z2 = parseFloat(document.getElementById("z2").value);

  if (
    isNaN(x1) || isNaN(y1) || isNaN(z1) ||
    isNaN(x2) || isNaN(y2) || isNaN(z2)
  ) {
    alert("Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß v√† h·ª£p l·ªá c√°c t·ªça ƒë·ªô.");
    return;
  }

  const from = new THREE.Vector3(x1, y1, z1);
  const to = new THREE.Vector3(x2, y2, z2);
  const dir = new THREE.Vector3().subVectors(to, from);
  const length = dir.length();
  const arrow = new THREE.ArrowHelper(dir.clone().normalize(), from, length, 0x00ff00);
  scene.add(arrow);

  // Th√™m ƒëi·ªÉm v√† nh√£n n·∫øu mu·ªën l∆∞u
  addPoint(from);
  addPoint(to);

  addToHistory(`Vector t·ª´ (${x1}, ${y1}, ${z1}) ƒë·∫øn (${x2}, ${y2}, ${z2})`, arrow);
}

//////////////
// C√°c h√†m ƒë∆∞·ª£c d√πng trong HTML c·∫ßn g√°n v√†o window
window.drawVectorFromInput = drawVectorFromInput;
// window.toggleMiniForm = toggleMiniForm;
// window.switchTab = switchTab;
// window.toggleMenu = toggleMenu;
// window.toggleDiv = toggleDiv;
window.plotPrimitive = plotPrimitive;
window.plotSurface = plotSurface;
window.plot2D = plot2D;
window.plotPolar = plotPolar;
window.drawLine3D = drawLine3D;
window.addPlaneInput = addPlaneInput;
window.drawAllPlanes = drawAllPlanes;
window.plotCustom3D = plotCustom3D;
window.drawIntersection = drawIntersection;
window.saveImage = saveImage;
window.updateLightMode = updateLightMode;
window.toggle = toggle;
window.gridHelper = gridHelper;
// window.axisGroup = axisGroup;
window.axisTicksGroup = axisTicksGroup;
window.sphere = sphere; // n·∫øu b·∫°n ƒë·∫∑t `sphereLine` ƒë·∫°i di·ªán cho m·∫∑t c·∫ßu 3D
window.heart = heart;
window.torus = torus;
window.spiral = spiral;
window.wave = wave;
window.saddle = saddle;
window.ellipsoid = ellipsoid;
window.paraboloid = paraboloid;
window.sincosWave = sincosWave;
window.mobius = mobius;
window.cone = cone;
window.cycloid = cycloid;
window.line = heart;  // n·∫øu `line` d√πng cho ƒë∆∞·ªùng cong t√πy ch·ªânh
window.setViewDirection = setViewDirection;
// G√°n v√†o window ƒë·ªÉ c√≥ th·ªÉ d√πng trong HTML
// window.xAxis = xAxis;
// window.yAxis = yAxis;
// window.zAxis = zAxis;
window.updateAxisAll = updateAxisAll;
window.oLabel = oLabel;
window.xLabel = xLabel;
window.yLabel = yLabel;
window.zLabel = zLabel;
window.computeIntegral2D = computeIntegral2D;
window.computeIntegral1D = computeIntegral1D;
window.createShape = createShape;
  </script>

</body>

</html>