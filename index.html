<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Math 3D Plotter</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.1.0/dist/chartjs-chart-matrix.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111827;
    }

    canvas {
      display: block;
    }

    select option {
      color: #d1d5db;
      /* Tailwind's text-gray-300 */
      background-color: #1f2937;
      /* Tailwind's bg-gray-800 */
    }

    .tab-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      text-align: left;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .tab-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .active-tab {
      background-color: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.2);
    }

    /* Ẩn nền thanh cuộn cho Chrome, Edge, Safari */
    .custom-scroll::-webkit-scrollbar {
      width: 8px;
    }

    .custom-scroll::-webkit-scrollbar-track {
      background: transparent;
      /* nền trong suốt */
    }

    .custom-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.3);
      /* thanh kéo mờ nhẹ */
      border-radius: 4px;
    }

    /* Cho Firefox */
    .custom-scroll {
      scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
      scrollbar-width: thin;
    }
  </style>
</head>

<body>

  <!-- Nút mở mini form -->
  <div class="fixed bottom-4 right-4 z-20 text-right">
    <button onclick="toggleMiniForm()"
      class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-full shadow-lg">
      ⚙️ Công Cụ
    </button>

    <!-- Mini form với tabs -->
    <div id="miniForm"
      class="hidden mt-3 p-4 bg-black/80 backdrop-blur-md rounded-2xl shadow-2xl w-[28rem] max-h-[70vh] overflow-y-auto text-white border border-white/10">
      <script>
        function toggleMiniForm() {
          const form = document.getElementById('miniForm');
          form.classList.toggle('hidden');
        }
      </script>
      <!-- Flex chứa nội dung và nút tab dọc -->
      <div class="flex space-x-4 text-left">

        <!-- Nội dung tab bên trái -->
        <div class="flex-1">
          <!-- Tab: Hiển thị -->
          <div id="tab-display" class="tab-content space-y-3 custom-scroll overflow-auto max-h-80">
            <div class="space-y-6 text-sm font-medium text-white m-4">

              <div class="flex flex-wrap gap-2 text-sm">
                <!-- Nút toggle auto rotate -->
                <div id="toggleContainer" class="flex flex-wrap gap-4 text-white font-mono text-sm mt-2"></div>

                <script>
                  const toggles = [
                    { id: "autoRotateToggle", label: "Auto-Rotate" },
                    { id: "formulaToggle", label: "Hiển thị Công Thức" },
                  ];

                  const toggleContainer = document.getElementById('toggleContainer');

                  toggles.forEach(({ id, label }) => {
                    const group = document.createElement('div');
                    group.className = 'flex items-center space-x-2';

                    const span = document.createElement('span');
                    span.textContent = label;

                    const button = document.createElement('button');
                    button.id = id;
                    button.className = 'px-3 py-1 rounded bg-green-600 hover:bg-green-700 text-white shadow';
                    button.textContent = 'On';

                    group.appendChild(span);
                    group.appendChild(button);
                    toggleContainer.appendChild(group);
                  });
                </script>

              </div>
              <hr class="w-px h-auto border-l border-l border-gray-300 mx-2" />
              <button onclick="toggle(gridHelper)" class="border px-3 py-1 rounded">Lưới</button>
              <hr class="my-2 border-t border-dashed border-gray-300" />
              <!-- Panel điều khiển trục + ticks -->
              <div class="space-y-4 custom-scroll overflow-auto max-h-60 text-sm font-medium text-white m-2">

                <!-- Chọn trục và nhãn -->
                <div class="space-y-2">
                  <h2 class="text-lg font-bold">Cấu hình trục</h2>

                  <div id="axisControls" class="space-y-3"></div>
                  <script>
                    const axisLabels = [
                      { axis: 'x', label: 'Trục X', placeholder: 'Nhãn X (mặc định: X)' },
                      { axis: 'y', label: 'Trục Y', placeholder: 'Nhãn Y (mặc định: Y)' },
                      { axis: 'z', label: 'Trục Z', placeholder: 'Nhãn Z (mặc định: Z)' }
                    ];

                    const axisContainer = document.getElementById('axisControls');

                    axisLabels.forEach(({ axis, label, placeholder }) => {
                      const wrapper = document.createElement('div');
                      wrapper.className = 'flex items-center gap-2';

                      wrapper.innerHTML = `
                        <input type="checkbox" class="axis-checkbox" value="${axis}" checked />
                        <label class="w-16">${label}</label>
                        <input id="label${axis.toUpperCase()}Input" type="text" placeholder="${placeholder}"
                          class="flex-1 px-2 py-1 text-black rounded" />
                      `;

                      axisContainer.appendChild(wrapper);
                    });

                  </script>
                </div>

                <!-- Cấu hình ticks -->
                <div>
                  <h2 class="text-lg font-bold mb-2">Cấu hình ticks</h2>

                  <div id="ticksInputs" class="grid grid-cols-4 gap-2 text-sm text-white font-medium"></div>
                  <script>
                    const ticks = [
                      { id: 'axisLengthInput', label: 'Độ dài trục:', value: '50' },
                      { id: 'stepInput', label: 'Bước:', value: '5' },
                      { id: 'minInput', label: 'Min', value: '-50' },
                      { id: 'maxInput', label: 'Max', value: '50' }
                    ];

                    const ticksContainer = document.getElementById('ticksInputs');
                    ticks.forEach(({ label, id, value }) => {
                      const div = document.createElement('label');
                      div.className = 'flex flex-col';
                      div.innerHTML = `${label} <input id="${id}" type="number" placeholder="${label}" value="${value}" class="w-32 text-black px-2 py-1 rounded-lg">`;
                      ticksContainer.appendChild(div);
                    });
                  </script>
                </div>

                <!-- Tùy chọn hiển thị -->
                <div class="space-y-2">
                  <h2 class="text-lg font-bold">Tùy chọn hiển thị</h2>
                  <div class="grid grid-cols-4 gap-4">

                    <label class="flex items-center gap-2">
                      <input id="showAxisLabels" type="checkbox" class="form-checkbox" checked />
                      Hiển thị nhãn trục
                    </label>
                    <label class="flex items-center gap-2">
                      <input id="showAxisTicks" type="checkbox" class="form-checkbox" checked />
                      Hiển thị ticks
                    </label>
                    <!-- Màu trục -->

                    <label class="flex items-center gap-2">Màu trục:
                      <input id="axisColorInput" type="color" value="#ffffff" class="w-24 rounded" /></label>
                    <!-- Nút cập nhật -->
                    <button onclick="updateAxisAll()"
                      class="bg-blue-600 hover:bg-blue-700 transition p-2 rounded-xl font-semibold">
                      Cập Nhật Trục & Ticks
                    </button>
                  </div>
                </div>
              </div>

              <hr class="my-4 border-t border-dashed border-gray-300" />

              <div class="text-sm text-gray-600">
                <!-- Nội dung khác -->
                <p>Thông tin bổ sung, ghi chú hoặc hướng dẫn ở đây.</p>
              </div>
            </div>
          </div>

          <div id="tab-sample" class="tab-content hidden">
            <select id="primitiveShape" class="border bg-transparent text-white rounded px-3 py-1 text-sm">
              <option value="none">Chọn khối 2D/3D</option>
              <option value="cube">Hình Lập Phương</option>
              <option value="sphere">Hình Cầu</option>
              <option value="cylinder">Hình Trụ</option>
              <option value="cone">Hình Nón</option>
              <option value="circle">Hình Tròn 2D</option>
              <option value="ellipse">Ellipse</option>
              <option value="triangle">Tam Giác 2D</option>
              <option value="pentagon">Ngũ Giác 2D</option>
              <option value="hexagon">Lục Giác 2D</option>
              <option value="pyramid">Hình Chóp</option>
              <option value="plane">Mặt Phẳng</option>
            </select>
            <button onclick="plotPrimitive()" class="border px-3 py-1 rounded">➕ Thêm</button>
            <hr class="my-2 border-t border-dashed border-gray-300" />

            <!-- HTML -->
            <div id="buttonContainer" class="custom-scroll overflow-auto max-h-60 grid grid-cols-2 sm:grid-cols-2 gap-2 text-sm">
            </div>

            <script>
              const objectButtons = [
                { label: '⚪ Khối Cầu', ref: 'sphere' },
                { label: '❤️ Trái Tim', ref: 'heart' },
                { label: '🌀 Hình Xuyến', ref: 'torus' },
                { label: '🔃 Xoắn Ốc', ref: 'spiral' },
                { label: '🌊 Sóng Sin', ref: 'wave' },
                { label: '🔺 Yên Ngựa', ref: 'saddle' },
                { label: '🧊 Elipsoid', ref: 'ellipsoid' },
                { label: '📈 Parabol 3D', ref: 'paraboloid' },
                { label: '🌀 Sin-Cos Wave', ref: 'sincosWave' },
                { label: '♾️ Mobius', ref: 'mobius' },
                { label: '🔻 Cone', ref: 'cone' },
                { label: '🌀 Cycloid', ref: 'cycloid' }
              ];


              const buttonContainer = document.getElementById('buttonContainer');

              objectButtons.forEach(({ label, ref }) => {
                const btn = document.createElement('button');
                btn.textContent = label;
                btn.className = 'border px-3 py-1 rounded';
                btn.onclick = () => toggle(window[ref]); // Truy cập đối tượng toàn cục
                buttonContainer.appendChild(btn);
              });
            </script>
          </div>

          <!-- Tab: Góc Nhìn -->
          <div id="tab-view" class="tab-content hidden">
            <span>Chọn góc nhìn:</span>
            <select id="viewSelector" onchange="setViewDirection()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full mt-1">
              <option value="default">3D Tự Do</option>
              <option value="xy">XY (Trên)</option>
              <option value="yz">YZ (Trái)</option>
              <option value="xz">XZ (Trước)</option>
            </select>
          </div>

          <!-- Tab: Ánh sáng -->
          <div id="tab-light" class="tab-content hidden space-y-3">
            <span>Chế độ ánh sáng:</span>
            <select id="lightMode" onchange="updateLightMode()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full">
              <option value="soft">Mềm</option>
              <option value="strong">Mạnh</option>
              <option value="wireframe">Chỉ khung</option>
            </select>

            <!-- Material Picker -->
            <span>Loại vật liệu:</span>
            <select id="materialType" onchange="updateLightMode()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full">
              <option value="standard">Standard</option>
              <option value="phong">Phong</option>
              <option value="lambert">Lambert</option>
              <option value="toon">Toon</option>
              <option value="texture">Texture</option>
            </select>

            <!-- Texture Picker (chỉ hiện nếu chọn texture) -->
            <span id="textureLabel" class="hidden">Chọn ảnh nền:</span>
            <input type="file" id="textureImage" accept="image/*" class="hidden w-full text-white"
              onchange="updateLightMode()" />
          </div>


          <!-- Tab: Vector -->
          <div id="tab-vector" class="tab-content hidden space-y-3">
            <span>Vector:</span>
            <div id="vector-inputs" class="grid grid-cols-3 gap-3 text-sm font-medium mt-2"></div>
            <script>
              const vectorInputs = [
                { label: "X1", id: "x1" },
                { label: "Y1", id: "y1" },
                { label: "Z1", id: "z1" },
                { label: "X2", id: "x2" },
                { label: "Y2", id: "y2" },
                { label: "Z2", id: "z2" },
              ];

              const container = document.getElementById("vector-inputs");

              vectorInputs.forEach(({ label, id }) => {
                const wrapper = document.createElement("label");
                wrapper.className = "flex items-center space-x-1";

                const span = document.createElement("span");
                span.textContent = label + ":";

                const input = document.createElement("input");
                input.type = "number";
                input.id = id;
                input.step = "0.1";
                input.className = "w-20 p-1 border rounded text-black";

                wrapper.appendChild(span);
                wrapper.appendChild(input);
                container.appendChild(wrapper);
              });
            </script>
            <button onclick="drawVectorFromInput()" class="border px-3 py-1 rounded">Vẽ vector</button>
          </div>

          <!-- Tab: Trục -->
          <div id="tab-axis" class="tab-content hidden space-y-3">
            <span>🎚️ Độ phân giải:</span>
            <input id="resolution" type="range" min="5" max="50" value="25" class="w-full">

            <div id="axis-inputs" class="grid grid-cols-2 gap-3 text-sm font-medium mt-2"></div>

            <script>
              const axisParams = [
                { label: 'X min', id: 'xMin', value: -50 },
                { label: 'X max', id: 'xMax', value: 50 },
                { label: 'Y min', id: 'yMin', value: -50 },
                { label: 'Y max', id: 'yMax', value: 50 }
              ];

              const axisInputsContainer = document.getElementById('axis-inputs');

              axisParams.forEach(param => {
                const label = document.createElement('label');
                label.className = 'flex flex-col';

                label.innerHTML = `
                  ${param.label}
                  <input id="${param.id}" type="number" value="${param.value}" class="text-black px-2 py-1 rounded-lg">
                `;

                axisInputsContainer.appendChild(label);
              });
            </script>
          </div>

          <div id="tab-history" class="tab-content hidden">
            <span>🧾 Lịch Sử:</span>
            <ul id="historyList" class="space-y-1 text-sm list-disc list-inside"></ul>
          </div>
          <!-- Tab: Xuất ảnh -->
          <div id="tab-export" class="tab-content hidden">
            <button onclick="saveImage()"
              class="w-full bg-red-600 hover:bg-red-700 transition px-4 py-2 rounded-xl font-semibold mt-2">
              📸 Xuất Ảnh
            </button>
          </div>
          <!-- Tab: Tích Phân -->
          <div id="tab-integral" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">

              <!-- Tính Tích Phân 1 Biến -->
              <div class="space-y-4">
                <h2 class="text-lg font-semibold">📈 Tính Tích Phân 1 Biến (∫ f(x) dx)</h2>
                <div class="flex items-center gap-2">

                  <label for="integralFormula1D" class="w-16">Hàm số:</label>
                  <input id="integralFormula1D" type="text" placeholder="f(x) = x^2"
                    class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="grid grid-cols-3 gap-4">
                  <div class="flex items-center gap-2">
                    <label for="a1D" class="flex flex-col">Tiệm cận dưới:</label>
                    <input id="a1D" type="text" placeholder="Nhập a (ví dụ: 0, pi, sqrt(2))"
                      class="w-24 text-black px-2 py-1 rounded-lg" />
                  </div>
                  <div class="flex items-center gap-2">
                    <label for="b1D" class="flex flex-col">Tiệm cận trên:</label>
                    <input id="b1D" type="text" placeholder="Nhập b (ví dụ: 2*pi, e)"
                      class="w-24 text-black px-2 py-1 rounded-lg" />
                  </div>
                  <div class="flex items-center gap-2">
                    <label for="integralSteps" class="flex flex-col">Số đoạn chia (n):</label>
                    <input id="integralSteps" type="number" min="10" value="200"
                      class="w-24 text-black px-2 py-1 rounded-lg" />
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-4">
                  <div class="flex items-center gap-2">
                    <label for="integralMethod" class="w-32">Phương pháp tính:</label>
                    <select id="integralMethod" class="text-black px-2 py-1 rounded">
                      <option value="midpoint">Midpoint</option>
                      <option value="trapezoidal">Trapezoidal</option>
                      <option value="simpson">Simpson</option>
                    </select>
                  </div>
                </div>

                <div class="flex justify-between items-center mt-2">
                  <div id="resultIntegral1D" class="text-green-400 font-bold"></div>
                  <button onclick="computeIntegral1D()"
                    class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">
                    📊 Tính và Vẽ
                  </button>
                </div>

                <div class="space-y-2">
                  <canvas id="integralGraph1D" width="600" height="250"
                    class="bg-white rounded shadow-md w-full"></canvas>
                  <label class="inline-flex items-center space-x-2">
                    <input type="checkbox" id="showIntegralSteps" class="text-black">
                    <span>Hiện chi tiết từng bước</span>
                  </label>
                  <div id="integralStepsTable"
                    class="overflow-auto max-h-64 bg-black/20 p-2 rounded hidden text-xs text-white font-mono"></div>
                </div>
              </div>

              <hr class="my-4 border-t border-dashed border-gray-300" />

              <!-- Tính Tích Phân 2 Biến -->
              <div class="space-y-4">
                <h2 class="text-lg font-semibold">📊 Tính Tích Phân 2 Biến (∬ f(x,y) dxdy)</h2>
                <div class="flex items-center gap-2">

                  <label for="integralFormula1D" class="w-16">Hàm số:</label>
                  <input id="integralFormula2D" type="text" placeholder="f(x,y) = x*y"
                    class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div id="rangeInputs" class="grid grid-cols-3 gap-2 text-sm text-white font-medium"></div>
                <script>
                  const fields = [
                    { id: 'a2D', label: 'x min', value: '0' },
                    { id: 'b2D', label: 'x max', value: '0' },
                    { id: 'stepsX', label: 'Số bước X', value: '0' },
                    { id: 'c2D', label: 'y min', value: '0' },
                    { id: 'd2D', label: 'y max', value: '0' },
                    { id: 'stepsY', label: 'Số bước Y', value: '0' },
                  ];

                  const rangeInputsContainer = document.getElementById('rangeInputs');
                  fields.forEach(({ label, id, value }) => {
                    const div = document.createElement('label');
                    div.className = 'flex flex-col';
                    div.innerHTML = `${label} <input id="${id}" type="number" placeholder="${label}" value="${value}" class="w-48 text-black px-2 py-1 rounded-lg">`;
                    rangeInputsContainer.appendChild(div);
                  });
                </script>
                <div class="flex justify-between items-center mt-2">
                  <div id="resultIntegral2D" class="text-yellow-300 font-bold"></div>
                  <button onclick="computeIntegral2D()"
                    class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">
                    🧮 Tính
                  </button>
                </div>
                <div class="flex items-center gap-2">
                  <label for="colormapSelect" class="w-32">Chọn Colormap:</label>
                  <select id="colormapSelect" class="text-black px-2 py-1 rounded">
                    <option value="viridis">Viridis</option>
                    <option value="plasma">Plasma</option>
                    <option value="turbo">Turbo</option>
                    <option value="gray">Gray</option>
                  </select>
                </div>

                <canvas id="integralHeatmap2D" width="600" height="250"
                  class="mt-4 border border-gray-300 rounded bg-white shadow-md w-full"></canvas>
              </div>

            </div>
          </div>
          <!-- Tab: Đồ thị 2D -->
          <div id="tab-graph2D" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">
              <h2 class="text-lg font-semibold">📈 Hàm Số 2D: y = f(x)</h2>
              <div class="flex items-center gap-2">
                <label for="inputFormula2D" class="w-16">Hàm số:</label>
                <input id="inputFormula2D" type="text" placeholder="y = x^3 - 3x - 1"
                  class="w-full text-black px-2 py-1 rounded" />
              </div>
              <div class="flex justify-between items-center mt-2">
                <button onclick="plot2D()" class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">
                  📈 Vẽ Đồ Thị 2D
                </button>
              </div>
              <canvas id="graph2D" class="mt-4 border border-gray-300 rounded bg-white shadow-md w-full" width="600"
                height="250"></canvas>
              <script>
                let chart2D;

                function plot2D() {
                  const input = document.getElementById("inputFormula2D").value.trim();
                  if (!/^y\s*=/.test(input)) {
                    alert("Vui lòng nhập công thức dưới dạng: y = f(x)");
                    return;
                  }


                  const exprStr = input
                    .replace(/^y\s*=\s*/, "")   // bỏ phần y =
                    .replace(/−/g, "-")         // thay dấu trừ Unicode
                    .replace(/×/g, "*")         // thay dấu nhân Unicode nếu có
                    .replace(/÷/g, "/");        // thay dấu chia Unicode nếu có

                  let expr;
                  try {
                    expr = math.compile(exprStr);
                  } catch (e) {
                    alert("Công thức sai: " + e.message);
                    return;
                  }

                  const xValues = [];
                  const yValues = [];
                  for (let x = -10; x <= 10; x += 0.1) {
                    try {
                      const y = expr.evaluate({ x });
                      if (typeof y === "number" && isFinite(y)) {
                        xValues.push(x);
                        yValues.push(y);
                      } else {
                        xValues.push(x);
                        yValues.push(null);
                      }
                    } catch {
                      xValues.push(x);
                      yValues.push(null);
                    }
                  }

                  if (chart2D) chart2D.destroy();

                  const ctx = document.getElementById("graph2D").getContext("2d");
                  chart2D = new Chart(ctx, {
                    type: "line",
                    data: {
                      labels: xValues,
                      datasets: [{
                        label: input,
                        data: yValues,
                        borderColor: "rgb(75, 192, 192)",
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                      }],
                    },
                    options: {
                      responsive: true,
                      scales: {
                        x: { type: "linear", title: { display: true, text: "x" } },
                        y: { title: { display: true, text: "y" } },
                      },
                    },
                  });
                }
              </script>
            </div>
          </div>
          <!-- Tab: Đường thẳng -->
          <div id="tab-geometryPanel" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">
              <h2 class="text-lg font-semibold">🧱 Mặt Phẳng (ax + by + cz + d = 0)</h2>
              <div class="flex justify-between items-center mt-2">
                <button onclick="addPlaneInput()"
                  class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">➕ Thêm mặt
                  phẳng</button>
                <button onclick="drawAllPlanes()"
                  class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">📐 Vẽ tất
                  cả</button>
              </div>
              <div class="space-y-2">
                <span>🧮 Danh sách phương trình mặt phẳng</span>
                <div id="planeList" class="space-y-2"></div>
              </div>
              <h2 class="text-lg font-semibold">📌 Giao tuyến giữa hai mặt phẳng</h2>
              <div class="flex justify-between items-center mt-2">
                <div class="w-48 grid grid-cols-2 gap-2 text-sm">
                  <select id="plane1Select" class="text-black p-2 rounded"></select>
                  <select id="plane2Select" class="text-black p-2 rounded"></select>
                </div>
                <button onclick="drawIntersection()"
                  class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">📏 Vẽ
                  giao
                  tuyến</button>
              </div>
              <!-- Đường thẳng -->
              <div class="space-y-2">

                <h2 class="text-lg font-semibold">📏 Đường thẳng (tham số)</h2>
                <div class="flex items-center gap-2">
                  <label for="x0" class="w-16">Hàm số:</label>
                  <input id="x0" type="text" placeholder="x = x0 + at" class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="y0" class="w-16">Hàm số:</label>
                  <input id="y0" type="text" placeholder="y = y0 + bt" class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="z0" class="w-16">Hàm số:</label>
                  <input id="z0" type="text" placeholder="z = z0 + ct" class="w-full text-black px-2 py-1 rounded" />
                </div>
                <button onclick="drawLine3D()" class="bg-green-600 hover:bg-green-700 w-full py-2 rounded">📈 Vẽ đường
                  thẳng</button>
              </div>


              <span>🎯 Kiểm tra quan hệ giữa 2 vector</span>
              <div class="grid grid-cols-2 gap-2">
                <input id="v1" class="text-black px-2 py-1 rounded" placeholder="VD: [1,2,3]">
                <input id="v2" class="text-black px-2 py-1 rounded" placeholder="VD: [-1,4,2]">
              </div>
              <button onclick="checkVectors()" class="w-full py-1 rounded bg-indigo-600 hover:bg-indigo-700 mt-2">🔍
                Kiểm
                Tra</button>
              <div id="checkResult" class="text-sm text-white mt-2"></div>
              <script>
                function checkVectors() {
                  const v1 = JSON.parse(document.getElementById('v1').value);
                  const v2 = JSON.parse(document.getElementById('v2').value);
                  const vec1 = new THREE.Vector3(...v1);
                  const vec2 = new THREE.Vector3(...v2);

                  const dot = vec1.dot(vec2);
                  const cross = new THREE.Vector3().crossVectors(vec1, vec2);
                  let result = "";

                  if (dot === 0) result += "✅ Hai vector vuông góc<br/>";
                  if (cross.length() === 0) result += "✅ Hai vector song song<br/>";
                  if (!result) result = "❌ Không vuông góc, không song song";

                  document.getElementById('checkResult').innerHTML = result;
                }

              </script>
            </div>
          </div>
          <!-- Tab: Đạo hàm -->
          <div id="tab-derivative" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">
              <h2 class="text-lg font-semibold">🧮 Công Thức z = f(x, y)</h2>
              <div class="flex items-center gap-2">
                <label for="inputFormula" class="w-16">Hàm số:</label>
                <input id="inputFormula" type="text" placeholder="z = sin(x) + cos(y)"
                  class="w-full text-black px-2 py-1 rounded" />
              </div>
              <div class="flex justify-between items-center mt-2">
                <select id="mode" class="text-black p-2 rounded-lg">
                  <option value="surface">Bề Mặt Mịn</option>
                  <option value="line">Dạng Line</option>
                </select>
                <button onclick="plotSurface()" class="border p-2 rounded bg-green-600 hover:bg-green-700 text-white">📉
                  Vẽ Đồ Thị
                </button>
                <button onclick="computeDerivatives()"
                  class="bg-blue-600 hover:bg-blue-700 transition p-2 rounded-xl font-semibold">Tính Đạo
                  Hàm</button>
              </div>

              <div class="space-y-2">
                <span>🧮 Đạo hàm & Vi phân</span>

                <div id="derivativeResult"
                  class="text-sm text-white bg-white/10 p-2 rounded-lg whitespace-pre-line mt-2">
                </div>

                <button onclick="plotDerivative('dx')" class="border px-3 py-1 rounded">∂z/∂x</button>
                <button onclick="plotDerivative('dy')" class="border px-3 py-1 rounded">∂z/∂y</button>
                <button onclick="plotDerivative('dx2')" class="border px-3 py-1 rounded">∂²z/∂x²</button>
                <button onclick="plotDerivative('dy2')" class="border px-3 py-1 rounded">∂²z/∂y²</button>
                <button onclick="plotDerivative('dxdy')" class="border px-3 py-1 rounded">∂²z/∂x∂y</button>
                <script>
                  let derivatives = {}; // lưu lại các công thức đạo hàm
                  function plotDerivative(key) {
                    const formula = derivatives[key];
                    if (!formula) {
                      alert("❗ Vui lòng nhấn 'Tính Đạo Hàm' trước khi vẽ đồ thị.");
                      return;
                    }

                    const formulaInput = document.getElementById("inputFormula");
                    formulaInput.value = "z = " + formula;
                    plotSurface(); // vẽ lại đồ thị dựa trên input
                  }
                  function computeDerivatives() {
                    const input = document.getElementById("inputFormula").value;
                    const expr = input.replace(/^z\s*=\s*/, "");

                    try {
                      const dz_dx = math.derivative(expr, 'x').toString();
                      const dz_dy = math.derivative(expr, 'y').toString();
                      const d2z_dx2 = math.derivative(dz_dx, 'x').toString();
                      const d2z_dy2 = math.derivative(dz_dy, 'y').toString();
                      const d2z_dxdy = math.derivative(dz_dx, 'y').toString();

                      // Tính vi phân đầy đủ
                      const differential = `dz = (${dz_dx}) dx + (${dz_dy}) dy`;

                      // Lưu công thức để vẽ đồ thị
                      derivatives = {
                        dx: dz_dx,
                        dy: dz_dy,
                        dx2: d2z_dx2,
                        dy2: d2z_dy2,
                        dxdy: d2z_dxdy
                      };

                      const result = `
                  ∂z/∂x = ${dz_dx}
                  ∂z/∂y = ${dz_dy}
                  ∂²z/∂x² = ${d2z_dx2}
                  ∂²z/∂y² = ${d2z_dy2}
                  ∂²z/∂x∂y = ${d2z_dxdy}
                  
                  ${differential}
                        `.trim();

                      document.getElementById("derivativeResult").innerText = result;

                    } catch (err) {
                      document.getElementById("derivativeResult").innerText = "❌ Lỗi công thức hoặc không thể tính đạo hàm.";
                    }
                  }
                </script>
              </div>
            </div>
          </div>
          <!-- Tab: Đồ thị cực -->
          <div id="tab-polarGraph" class="tab-content hidden custom-scroll overflow-auto max-h-80 space-y-4 text-sm">
            <div class="space-y-6 text-sm font-medium text-white m-4">

              <h2 class="text-lg font-semibold">📈 Công Thức r = f(θ)</h2>
              <div class="flex items-center gap-2">

                <label for="polarFormula" class="w-16">Hàm số:</label>
                <input id="polarFormula" type="text" placeholder="r = 10 * sin(3 * theta)"
                  class="w-full text-black px-2 py-1 rounded" />
              </div>
              <div class="flex justify-between items-center mt-2">
                <div class="flex items-center space-x-2 mt-2 text-white font-mono">
                  <input id="moveCameraPolar" type="checkbox" class="form-checkbox text-blue-500" checked>
                  <label for="moveCameraPolar">Tự động di chuyển cam khi vẽ cực</label>
                </div>
                <button onclick="plotPolar()"
                  class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">📉
                  Vẽ Đồ Thị Cực
                </button>
              </div>

              <div class="space-y-2">
                <h2 class="text-lg font-semibold">🧮 Công Thức Tùy Chỉnh (x, y, z)</h2>
                <div class="flex items-center gap-2">
                  <label for="customX" class="w-16">Hàm số:</label>
                  <input id="customX" type="text" placeholder="x = ..." class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="customY" class="w-16">Hàm số:</label>
                  <input id="customY" type="text" placeholder="y = ..." class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div class="flex items-center gap-2">
                  <label for="customZ" class="w-16">Hàm số:</label>
                  <input id="customZ" type="text" placeholder="z = ..." class="w-full text-black px-2 py-1 rounded" />
                </div>
                <div id="paramControls" class="grid grid-cols-3 gap-2 text-sm text-white font-medium">

                  <script>
                    const paramData = [
                      { label: 't min', id: 'tMin', value: 0 },
                      { label: 't max', id: 'tMax', value: 6.28 },
                      { label: 'res', id: 'tRes', value: 200 }
                    ];

                    const paramDatacontainer = document.getElementById('paramControls');
                    paramData.forEach(({ label, id, value }) => {
                      const wrapper = document.createElement('label');
                      wrapper.className = 'flex flex-col';
                      wrapper.innerHTML = `${label} <input id="${id}" type="number" value="${value}" class="w-32 text-black px-2 py-1 rounded-lg">`;
                      paramDatacontainer.appendChild(wrapper);
                    });

                  </script>
                </div>

                <div class="flex justify-between items-center mt-2">
                  <div class="flex items-center space-x-2 mt-2 text-white font-mono">
                    <input id="moveCameraCustom" type="checkbox" class="form-checkbox text-blue-500" checked>
                    <label for="moveCameraCustom">Tự động di chuyển cam khi vẽ</label>
                  </div>
                  <button onclick="plotCustom3D()"
                    class="border px-4 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white">📉
                    Vẽ Hình Tùy Chỉnh
                  </button>
                </div>

              </div>
            </div>
          </div>
        </div>

        <!-- Nút tab dọc bên phải -->
        <div id="tabContainer"
          class="custom-scroll overflow-auto max-h-80 flex flex-col border-l border-white/20 p-2 space-y-2 text-sm font-semibold min-w-[7rem]">
          <script>
            const tabs = [
              { id: 'tab-display', label: '🎛️ Hiển Thị' },
              { id: 'tab-view', label: '🧭 Góc Nhìn' },
              { id: 'tab-sample', label: 'Mẫu Hình' },
              { id: 'tab-light', label: '💡 Ánh Sáng' },
              { id: 'tab-axis', label: '📐 Trục' },
              { id: 'tab-history', label: '🧾 Lịch sử' },
              { id: 'tab-graph2D', label: 'Đồ thị 2D' },
              { id: 'tab-derivative', label: 'Đạo hàm' },
              { id: 'tab-polarGraph', label: 'Đồ thị cực' },
              { id: 'tab-integral', label: '∫ Tích Phân' },
              { id: 'tab-geometryPanel', label: 'Đường thẳng' },
              { id: 'tab-vector', label: 'Vector' },
              { id: 'tab-export', label: '📸 Xuất' },
            ];

            const tabContainer = document.getElementById('tabContainer');
            tabContainer.innerHTML = tabs.map((tab, index) => `
              <button class="tab-btn ${index === 0 ? 'active-tab' : ''}"
                      onclick="switchTab(event, '${tab.id}')">${tab.label}</button>
            `).join('');

            function switchTab(evt, tabId) {
              document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
              document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active-tab'));
              document.getElementById(tabId).classList.remove('hidden');
              evt.currentTarget.classList.add('active-tab');
            }
          </script>
        </div>


      </div>
    </div>

  </div>

  <!-- Nút 3 gạch để bật menu -->
  <button onclick="toggleMenu()" class="fixed top-4 right-4 z-40 p-2 bg-black/80 text-white rounded-md shadow-md">
    <!-- Biểu tượng 3 gạch -->
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"
      stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
    </svg>
  </button>

  <!-- Floating Menu -->
  <div id="floatingMenu"
    class="hidden fixed top-4 right-20 translate-x-1/2 z-30 bg-black/80 text-white rounded-xl px-4 py-3 space-y-2 shadow-xl border border-white/10">
    <script>
      function toggleMenu() {
        const menu = document.getElementById('floatingMenu');
        menu.classList.toggle('hidden');
      }
      function toggleDiv(id) {
        const el = document.getElementById(id);
        if (el) {
          el.classList.toggle('hidden');
        }
      }
      const panels = [
        { id: 'formulaPanel', label: '📐 Công Thức' },
        { id: 'formulaPanel2D', label: '📐 Công Thức 2D' },
        { id: 'geometryPanel', label: '📐 Phương Trình Hình Học' },
        { id: 'customFormula', label: 'Công thức tùy chỉnh' }

      ];

      document.addEventListener('DOMContentLoaded', () => {
        const floatingMenu = document.getElementById('floatingMenu');
        if (!floatingMenu) return;

        panels.forEach(panel => {
          const wrapper = document.createElement('div');
          wrapper.className = 'flex items-center space-x-2';

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `toggle${panel.id.charAt(0).toUpperCase() + panel.id.slice(1)}`;
          checkbox.onchange = () => toggleDiv(panel.id);

          const label = document.createElement('label');
          label.htmlFor = checkbox.id;
          label.textContent = panel.label;

          wrapper.appendChild(checkbox);
          wrapper.appendChild(label);
          floatingMenu.appendChild(wrapper);
        });
      });
    </script>
  </div>



  <script>
    

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(60, 60, 60);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Label renderer
const labelRenderer = new THREE.CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.top = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
document.body.appendChild(labelRenderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;


let gridHelper = new THREE.GridHelper(100, 20);
scene.add(gridHelper);

// Light
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const light = new THREE.PointLight(0xffffff, 1);
light.position.set(50, 50, 100);
scene.add(light);

// Hàm tạo trục
let axisGroup = new THREE.Group(); // Nhóm chứa các trục
scene.add(axisGroup);

function createFullAxis(axis = 'x', length = 50, color = 0xffffff) {
  const dirMap = {
    x: new THREE.Vector3(1, 0, 0),
    y: new THREE.Vector3(0, 1, 0),
    z: new THREE.Vector3(0, 0, 1)
  };

  const dir = dirMap[axis];
  if (!dir) return;

  // Đường trục từ -length đến +length
  const points = [
    dir.clone().multiplyScalar(-length),
    dir.clone().multiplyScalar(length)
  ];
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color });
  const line = new THREE.Line(geometry, material);
  axisGroup.add(line); // ✅ Thêm vào group

  // Mũi tên dương
  const arrowPos1 = dir.clone().multiplyScalar(length);
  const arrow1 = new THREE.ArrowHelper(dir.clone().normalize(), arrowPos1, 3, color, 1, 0.5);
  axisGroup.add(arrow1); // ✅

  // Mũi tên âm
  const dirNeg = dir.clone().negate();
  const arrowPos2 = dirNeg.clone().multiplyScalar(length);
  const arrow2 = new THREE.ArrowHelper(dirNeg.normalize(), arrowPos2, 3, color, 1, 0.5);
  axisGroup.add(arrow2); // ✅
}



// Gọi các trục như trước
createFullAxis('x', 50, 0xff0000);
createFullAxis('y', 50, 0x00ff00);
createFullAxis('z', 50, 0x00ffff);



// Labels
function createLabel(text, pos, color) {
  const div = document.createElement('div');
  div.textContent = text;
  div.style.color = color;
  div.style.fontWeight = 'bold';
  const label = new THREE.CSS2DObject(div);
  label.position.copy(pos);
  axisGroup.add(label); // 🟢 add vào group luôn
  return label; // ✅ trả về đối tượng label

}
const oLabel = createLabel('.', new THREE.Vector3(0, 0, 0), 'white');
const xLabel = createLabel('X', new THREE.Vector3(55, 0, 0), 'red');
const yLabel = createLabel('Y', new THREE.Vector3(0, 55, 0), 'lime');
const zLabel = createLabel('Z', new THREE.Vector3(0, 0, 55), 'cyan');

let axisTicksGroup = new THREE.Group(); // Nhóm để dễ ẩn/hiện tất cả tick


// Dùng nhóm để chứa tất cả ticks
function addAxisTicks(axis = 'x', step = 5, min = -50, max = 50, color = 'white') {
  const dirVectors = {
    x: {
      from: (i) => [new THREE.Vector3(i, -0.5, 0), new THREE.Vector3(i, 0.5, 0)],
      pos: (i) => new THREE.Vector3(i, 0, 0)
    },
    y: {
      from: (i) => [new THREE.Vector3(-0.5, i, 0), new THREE.Vector3(0.5, i, 0)],
      pos: (i) => new THREE.Vector3(0, i, 0)
    },
    z: {
      from: (i) => [new THREE.Vector3(0, -0.5, i), new THREE.Vector3(0, 0.5, i)],
      pos: (i) => new THREE.Vector3(0, 0, i)
    }
  };

  const data = dirVectors[axis];
  if (!data) return;

  const material = new THREE.LineBasicMaterial({ color });

  for (let i = min; i <= max; i += step) {
    if (i === 0) continue;

    const points = data.from(i);
    const tick = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(points),
      material
    );
    axisTicksGroup.add(tick);

    const label = createLabel(`${i}`, data.pos(i), color);
    axisTicksGroup.add(label);
  }
}
function updateAxisAll() {
  const checkboxes = document.querySelectorAll('.axis-checkbox');
  const selectedAxes = Array.from(checkboxes)
    .filter(cb => cb.checked)
    .map(cb => cb.value);

  const length = parseFloat(document.getElementById('axisLengthInput').value);
  const colorHex = document.getElementById('axisColorInput').value;
  const showLabels = document.getElementById('showAxisLabels').checked;
  const showTicks = document.getElementById('showAxisTicks').checked;

  const step = parseFloat(document.getElementById('stepInput').value);
  const min = parseFloat(document.getElementById('minInput').value);
  const max = parseFloat(document.getElementById('maxInput').value);

  // Lấy nhãn người dùng nhập (nếu rỗng thì dùng mặc định)
  const labelMap = {
    x: document.getElementById('labelXInput')?.value.trim() || 'X',
    y: document.getElementById('labelYInput')?.value.trim() || 'Y',
    z: document.getElementById('labelZInput')?.value.trim() || 'Z'
  };

  // Xóa các trục và ticks cũ
  axisGroup.clear();
  axisTicksGroup.clear();

  selectedAxes.forEach(axis => {
    // Tạo trục
    createFullAxis(axis, length, new THREE.Color(colorHex));

    // Tạo nhãn nếu có
    if (showLabels) {
      const labelPos = {
        x: new THREE.Vector3(length + 5, 0, 0),
        y: new THREE.Vector3(0, length + 5, 0),
        z: new THREE.Vector3(0, 0, length + 5)
      };

      const labelColor = {
        x: 'red',
        y: 'lime',
        z: 'cyan'
      };

      createLabel(labelMap[axis], labelPos[axis], labelColor[axis]);
    }

    // Tạo ticks nếu có
    if (showTicks) {
      addAxisTicks(axis, step, min, max, colorHex);
    }
  });

  // Nhãn gốc (0,0,0)
  if (showLabels) {
    createLabel('.', new THREE.Vector3(0, 0, 0), 'white');
  }
}




// Thêm ticks 1 lần
addAxisTicks('x', 5, -50, 50, 'white');
addAxisTicks('y', 5, -50, 50, 'white');
addAxisTicks('z', 5, -50, 50, 'white');
scene.add(axisTicksGroup);

function createFormulaLabel(text, position = new THREE.Vector3(0, 0, 0)) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 512;
  canvas.height = 128;

  ctx.fillStyle = 'white';
  ctx.font = 'bold 32px monospace';
  ctx.fillText(text, 20, 80);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);

  sprite.scale.set(10, 2.5, 1); // tùy chỉnh kích thước
  sprite.position.copy(position.clone().add(new THREE.Vector3(0, 5, 0))); // đặt phía trên đồ thị

  return sprite;
}


// ✅ Hàm nội suy tuyến tính
const lerp = (a, b, t) => a + (b - a) * t;

// ✅ Tạo điểm từ hàm 1 biến
function createParametricPoints(fn, [t0, t1], steps) {
  return Array.from({ length: steps + 1 }, (_, i) => fn(lerp(t0, t1, i / steps)));
}

// ✅ Tạo đoạn nối từ hàm 2 biến (u, v)
function createParametricSegments(fn, [u0, u1], [v0, v1], segments) {
  const points = [];

  for (let i = 1; i < segments; i++) {
    const u = lerp(u0, u1, i / segments);
    for (let j = 0; j < segments; j++) {
      const v1a = lerp(v0, v1, j / segments);
      const v1b = lerp(v0, v1, (j + 1) / segments);
      points.push(fn(u, v1a), fn(u, v1b)); // vĩ tuyến
    }
  }

  for (let j = 0; j < segments; j++) {
    const v = lerp(v0, v1, j / segments);
    for (let i = 0; i < segments; i++) {
      const u1a = lerp(u0, u1, i / segments);
      const u1b = lerp(u0, u1, (i + 1) / segments);
      points.push(fn(u1a, v), fn(u1b, v)); // kinh tuyến
    }
  }

  return points;
}
// geometryFunctions.js

// 🎯 Mặt cầu 3D
function sphere3D(theta, phi, r = 5) {
  return new THREE.Vector3(
    r * Math.sin(theta) * Math.cos(phi),
    r * Math.sin(theta) * Math.sin(phi),
    r * Math.cos(theta)
  );
}

// ❤️ Trái tim 3D
function heart3D(t, s = 2.5) {
  return new THREE.Vector3(
    s * 16 * Math.pow(Math.sin(t), 3),
    s * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)),
    s * 4 * Math.sin(2 * t)
  );
}
// 🔷 Hình xuyến (Torus)
function torus3D(u, v, R = 4, r = 1.5) {
  return new THREE.Vector3(
    (R + r * Math.cos(v)) * Math.cos(u),
    (R + r * Math.cos(v)) * Math.sin(u),
    r * Math.sin(v)
  );
}

// 🔷 Sóng Sin 3D
function wave3D(x, z, A = 1, f = 1) {
  return new THREE.Vector3(
    x,
    A * Math.sin(f * (x ** 2 + z ** 2)),
    z
  );
}

// 🔷 Hình xoắn ốc
function spiral3D(t, a = 0.1, b = 0.2) {
  return new THREE.Vector3(
    a * t * Math.cos(t),
    a * t * Math.sin(t),
    b * t
  );
}

// 🔷 Mặt yên ngựa (Hyperbolic Paraboloid)
function saddle3D(x, z) {
  return new THREE.Vector3(
    x,
    x * x - z * z,
    z
  );
}

// 🔷 Elipsoid
function ellipsoid3D(theta, phi, rx = 4, ry = 2, rz = 1.5) {
  return new THREE.Vector3(
    rx * Math.sin(theta) * Math.cos(phi),
    ry * Math.sin(theta) * Math.sin(phi),
    rz * Math.cos(theta)
  );
}
// 🔶 Mặt Parabol 3D
function paraboloid3D(x, z, a = 0.5) {
  return new THREE.Vector3(
    x,
    a * (x * x + z * z),
    z
  );
}
// 🔶 Mặt sóng Sin-Cos 3D
function sincosWave3D(x, z, a = 1) {
  return new THREE.Vector3(
    x,
    a * Math.sin(x) * Math.cos(z),
    z
  );
}
// 🔶 Mobius Strip (Dải Mobius)
function mobius3D(u, v, R = 2) {
  const halfV = v / 2;
  return new THREE.Vector3(
    Math.cos(u) * (R + halfV * Math.cos(u / 2)),
    Math.sin(u) * (R + halfV * Math.cos(u / 2)),
    halfV * Math.sin(u / 2)
  );
}
// 🔶 Hình Chóp Xoay (Cone)
function cone3D(theta, h, r = 1) {
  return new THREE.Vector3(
    r * (1 - h) * Math.cos(theta),
    h,
    r * (1 - h) * Math.sin(theta)
  );
}
// 🔶 Cycloid 3D
function cycloid3D(t, r = 1) {
  return new THREE.Vector3(
    r * (t - Math.sin(t)),
    0,
    r * (1 - Math.cos(t))
  );
}

// 🎯 Tạo các đối tượng hình học
const heart = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(createParametricPoints(heart3D, [0, Math.PI * 2], 500)),
  new THREE.LineBasicMaterial({ color: 0xff66cc })
);

const sphere = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(sphere3D, [0, Math.PI], [0, Math.PI * 2], 30)),
  new THREE.LineBasicMaterial({ color: 0x66ccff })
);

const torus = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(torus3D, [0, Math.PI * 2], [0, Math.PI * 2], 50)),
  new THREE.LineBasicMaterial({ color: 0xffcc00 })
);

const spiral = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(createParametricPoints(spiral3D, [0, 10 * Math.PI], 1000)),
  new THREE.LineBasicMaterial({ color: 0x00ff99 })
);

const wave = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(wave3D, [-5, 5], [-5, 5], 50)),
  new THREE.LineBasicMaterial({ color: 0x3366ff })
);

const saddle = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(saddle3D, [-3, 3], [-3, 3], 50)),
  new THREE.LineBasicMaterial({ color: 0xff6666 })
);

const ellipsoid = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(ellipsoid3D, [0, Math.PI], [0, Math.PI * 2], 30)),
  new THREE.LineBasicMaterial({ color: 0x00ccff })
);
// 🔶 Mặt Parabol 3D
const paraboloid = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(paraboloid3D, [-3, 3], [-3, 3], 50)),
  new THREE.LineBasicMaterial({ color: 0xcc00cc })
);

// 🔶 Sóng Sin-Cos 3D
const sincosWave = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(sincosWave3D, [-5, 5], [-5, 5], 50)),
  new THREE.LineBasicMaterial({ color: 0x00cccc })
);

// 🔶 Dải Mobius
const mobius = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(mobius3D, [0, Math.PI * 2], [-1, 1], 100)),
  new THREE.LineBasicMaterial({ color: 0xff9966 })
);

// 🔶 Hình Chóp Xoay (Cone)
const cone = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(createParametricSegments(cone3D, [0, Math.PI * 2], [0, 1], 50)),
  new THREE.LineBasicMaterial({ color: 0x9999ff })
);

// 🔶 Cycloid 3D
const cycloid = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(createParametricPoints(cycloid3D, [0, 4 * Math.PI], 300)),
  new THREE.LineBasicMaterial({ color: 0xffcc99 })
);

// ✅ Danh sách đối tượng để xử lý chung
const allObjects = [heart, sphere, torus, spiral, wave, saddle, ellipsoid, paraboloid, sincosWave, mobius, cone, cycloid];

// ✅ Ẩn tất cả khi tải trang và thêm vào scene
allObjects.forEach(obj => {
  obj.visible = false;
  scene.add(obj);
});

// Toggle visibility
function toggle(...objects) {
  objects.forEach(obj => {
    if (obj) obj.visible = !obj.visible;
  });
}

// Vẽ đồ thị mặt
let surfaceMesh;
let currentLabel;
let formulaLabel; // thêm dòng này


function plotSurface() {
  let formulaRaw = document.getElementById("inputFormula").value
    .toLowerCase()
    .replace(/−/g, '-')    // dấu trừ unicode
    .replace(/×/g, '*')    // dấu nhân unicode
    .replace(/÷/g, '/')    // dấu chia unicode
    .replace(/\s+/g, '');  // xoá khoảng trắng
  const mode = document.getElementById("mode").value;
  const resolution = parseInt(document.getElementById("resolution").value);
  const lightMode = document.getElementById("lightMode").value;

  const xMin = parseFloat(document.getElementById("xMin").value);
  const xMax = parseFloat(document.getElementById("xMax").value);
  const yMin = parseFloat(document.getElementById("yMin").value);
  const yMax = parseFloat(document.getElementById("yMax").value);

  let depVar = null;
  const vars = ['x', 'y', 'z'];
  let indepVars = [];

  for (let v of vars) {
    if (formulaRaw.startsWith(v + '=')) {
      depVar = v;
      indepVars = vars.filter(w => w !== v);
      break;
    }
  }

  if (!depVar) {
    alert('❗ Vui lòng nhập công thức dưới dạng: z = f(x, y)');
    return;
  }

  const exprBody = formulaRaw.split('=')[1];
  let expr;
  try {
    expr = math.compile(exprBody);
  } catch (e) {
    alert('Lỗi công thức: ' + e.message);
    return;
  }

  if (surfaceMesh) scene.remove(surfaceMesh);

  const geometry = new THREE.BufferGeometry();
  const stepX = (xMax - xMin) / resolution;
  const stepY = (yMax - yMin) / resolution;
  const countX = resolution + 1;
  const countY = resolution + 1;
  const points = [];

  for (let i = 0; i <= resolution; i++) {
    const u = xMin + i * stepX;
    for (let j = 0; j <= resolution; j++) {
      const v = yMin + j * stepY;
      let x = 0, y = 0, z = 0;
      const varsObj = {};
      varsObj[indepVars[0]] = u;
      varsObj[indepVars[1]] = v;
      try {
        const result = expr.evaluate(varsObj);
        if (depVar === 'x') {
          x = result; y = u; z = v;
        } else if (depVar === 'y') {
          x = u; y = result; z = v;
        } else {
          x = u; y = v; z = result;
        }
      } catch (e) {
        x = y = z = NaN;
      }
      points.push(x, y, z);
    }
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
  // === TÍNH TOÁN UV MAPPING (áp dụng ánh xạ phẳng từ x,y) ===
  const uv = [];
  for (let i = 0; i <= resolution; i++) {
    const u = xMin + i * stepX;
    for (let j = 0; j <= resolution; j++) {
      const v = yMin + j * stepY;

      // Đưa x và y về khoảng [0,1]
      const uCoord = (u - xMin) / (xMax - xMin);
      const vCoord = (v - yMin) / (yMax - yMin); // Không đảo trục Y

      uv.push(uCoord, vCoord);
    }
  }
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));

  if (mode === 'surface') {
    const indices = [];
    for (let i = 0; i < countX - 1; i++) {
      for (let j = 0; j < countY - 1; j++) {
        const a = i * countY + j;
        const b = a + 1;
        const c = a + countY;
        const d = c + 1;
        indices.push(a, b, d, a, d, c);
      }
    }
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    let material;
    if (lightMode === 'wireframe') {
      material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
    } else {
      const texLoader = new THREE.TextureLoader();
      const texture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
      material = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        map: texture,
        metalness: 0.5,
        roughness: lightMode === 'soft' ? 0.9 : 0.3,
        flatShading: lightMode === 'strong',
        side: THREE.DoubleSide,
      });
    }
    surfaceMesh = new THREE.Mesh(geometry, material);
  } else {
    const group = new THREE.Group();
    for (let i = 0; i < countX; i++) {
      const linePoints = [];
      for (let j = 0; j < countY; j++) {
        const idx = i * countY + j;
        linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
      group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffff00 })));
    }
    for (let j = 0; j < countY; j++) {
      const linePoints = [];
      for (let i = 0; i < countX; i++) {
        const idx = i * countY + j;
        linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
      group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffaa00 })));
    }
    surfaceMesh = group;
  }
  scene.add(surfaceMesh);
  if (formulaLabel) scene.remove(formulaLabel); // Xoá label cũ nếu có
  formulaLabel = createFormulaLabel(formulaRaw, new THREE.Vector3(0, 0, 0));
  scene.add(formulaLabel);

  addToHistory(`Bề mặt: ${formulaRaw}`, surfaceMesh);
}

function plotPrimitive() {
  const choice = document.getElementById("primitiveShape").value;
  let mesh;
  const material = new THREE.MeshStandardMaterial({ color: 0x33ffff });

  switch (choice) {
    case 'cube':
      mesh = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), material);
      break;
    case 'sphere':
      mesh = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), material);
      break;
    case 'cylinder':
      mesh = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 15, 32), material);
      break;
    case 'cone':
      mesh = new THREE.Mesh(new THREE.ConeGeometry(5, 15, 32), material);
      break;
    case 'circle':
      mesh = new THREE.Mesh(new THREE.CircleGeometry(8, 32), material);
      break;
    case 'ellipse':
      const ellipse = new THREE.Shape();
      ellipse.absellipse(0, 0, 8, 4, 0, Math.PI * 2, false, 0);
      const ellipseGeom = new THREE.ShapeGeometry(ellipse);
      mesh = new THREE.Mesh(ellipseGeom, material);
      break;
    case 'triangle':
      const triShape = new THREE.Shape();
      triShape.moveTo(0, 10);
      triShape.lineTo(-8.66, -5);
      triShape.lineTo(8.66, -5);
      triShape.lineTo(0, 10);
      const triGeom = new THREE.ShapeGeometry(triShape);
      mesh = new THREE.Mesh(triGeom, material);
      break;
    case 'pentagon':
      mesh = polygonMesh(5, 6, material);
      break;
    case 'hexagon':
      mesh = polygonMesh(6, 6, material);
      break;
    case 'pyramid':
      const geom = new THREE.ConeGeometry(7, 10, 4);
      mesh = new THREE.Mesh(geom, material);
      break;
    case 'plane':
      mesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), material);
      break;
    default:
      alert("Hãy chọn khối hình.");
      return;
  }

  mesh.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, Math.random() * 20 - 10);
  scene.add(mesh);

}

let customCurve; // lưu đường cũ để xóa trước khi vẽ mới

function plotCustom3D() {
  const tMin = parseFloat(document.getElementById("tMin").value);
  const tMax = parseFloat(document.getElementById("tMax").value);
  const res = parseInt(document.getElementById("tRes").value);

  const rawX = document.getElementById("customX").value.trim().toLowerCase();
  const rawY = document.getElementById("customY").value.trim().toLowerCase();
  const rawZ = document.getElementById("customZ").value.trim().toLowerCase();

  if (!rawX.startsWith("x = ") || !rawY.startsWith("y = ") || !rawZ.startsWith("z = ")) {
    alert("Vui lòng nhập đúng định dạng: x = ..., y = ..., z = ...");
    return;
  }

  const xExpr = rawX.split("=")[1];
  const yExpr = rawY.split("=")[1];
  const zExpr = rawZ.split("=")[1];

  let fx, fy, fz;
  try {
    fx = math.compile(xExpr);
    fy = math.compile(yExpr);
    fz = math.compile(zExpr);
  } catch (e) {
    alert("Lỗi trong công thức: " + e.message);
    return;
  }

  // Xoá đường cong cũ nếu có
  if (customCurve) scene.remove(customCurve);

  const points = [];
  for (let i = 0; i <= res; i++) {
    const t = tMin + ((tMax - tMin) * i / res);

    const context = {
      t: t,
      theta: t,
      u: t,
      v: t
    };

    try {
      const x = fx.evaluate(context);
      const y = fy.evaluate(context);
      const z = fz.evaluate(context);

      if (isFinite(x) && isFinite(y) && isFinite(z)) {
        points.push(new THREE.Vector3(x, y, z));
      }
    } catch (e) {
      console.warn("Lỗi khi đánh giá tại t =", t, ":", e.message);
    }
  }

  if (points.length < 2) {
    alert("Không đủ điểm hợp lệ để vẽ đường.");
    return;
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0xff44aa });
  customCurve = new THREE.Line(geometry, material);
  scene.add(customCurve);
  addToHistory(`Tùy chỉnh 3D`, customCurve);
  const moveCam = document.getElementById("moveCameraCustom").checked;
  if (moveCam) {
    moveCameraTo(points);
  }
}
function moveCameraTo(points) {
  const center = new THREE.Vector3();
  points.forEach(p => center.add(p));
  center.divideScalar(points.length);

  camera.position.set(center.x + 10, center.y + 10, center.z + 10);
  camera.lookAt(center);
}

// Hàm hỗ trợ tạo đa giác 2D đều (pentagon, hexagon,...)
function polygonMesh(sides, radius, material) {
  const shape = new THREE.Shape();
  for (let i = 0; i <= sides; i++) {
    const angle = (i / sides) * Math.PI * 2;
    const x = radius * Math.cos(angle);
    const y = radius * Math.sin(angle);
    if (i === 0) shape.moveTo(x, y);
    else shape.lineTo(x, y);
  }
  const geometry = new THREE.ShapeGeometry(shape);
  return new THREE.Mesh(geometry, material);
}


// Vẽ đồ thị cực
function plotPolar() {
  const formula = document.getElementById("polarFormula").value;
  const expr = math.compile(formula);
  const points = [];

  for (let i = 0; i <= 1000; i++) {
    const theta = (i / 1000) * Math.PI * 2;
    let r = 0;
    try { r = expr.evaluate({ theta }); } catch (e) { }
    const x = r * Math.cos(theta);
    const y = r * Math.sin(theta);
    points.push(new THREE.Vector3(x, 0, y));
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const polarCurve = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff9933 }));
  scene.add(polarCurve);
  addToHistory(`Đồ thị cực: ${formula}`, polarCurve);
  // 👇 Di chuyển camera đến vùng đồ thị cực
  // Nếu checkbox được bật, di chuyển camera lại gần đồ thị
  const moveCam = document.getElementById("moveCameraPolar").checked;
  if (moveCam) {
    moveCameraTo(points);
  }
}

let planeEquations = [];

function drawAllPlanes() {
  planeEquations = []; // reset danh sách
  const planes = document.querySelectorAll('#planeList > div');
  const select1 = document.getElementById('plane1Select');
  const select2 = document.getElementById('plane2Select');
  select1.innerHTML = "";
  select2.innerHTML = "";

  planes.forEach((div, index) => {
    const inputs = div.querySelectorAll('input');
    const a = parseFloat(inputs[0].value);
    const b = parseFloat(inputs[1].value);
    const c = parseFloat(inputs[2].value);
    const d = parseFloat(inputs[3].value);
    planeEquations.push({ a, b, c, d });

    // render mặt phẳng
    drawPlaneFromParams(a, b, c, d);

    // update dropdown
    const option = `<option value="${index}">Mặt ${index + 1}</option>`;
    select1.innerHTML += option;
    select2.innerHTML += option;
  });
}
function intersectPlanes(p1, p2) {
  const n1 = new THREE.Vector3(p1.a, p1.b, p1.c);
  const n2 = new THREE.Vector3(p2.a, p2.b, p2.c);
  const dir = new THREE.Vector3().crossVectors(n1, n2);

  if (dir.length() < 1e-6) {
    alert("⚠️ Hai mặt phẳng song song hoặc trùng nhau (không có giao tuyến)");
    return;
  }

  const A = new THREE.Matrix3();
  A.set(
    p1.a, p1.b, p1.c,
    p2.a, p2.b, p2.c,
    dir.x, dir.y, dir.z
  );

  const D = new THREE.Vector3(-p1.d, -p2.d, 0);
  const Ainv = A.clone().invert();

  if (!Ainv) {
    alert("⚠️ Không tìm được điểm giao");
    return;
  }

  const point = D.applyMatrix3(Ainv);

  const points = [];
  for (let t = -50; t <= 50; t += 1) {
    const pt = point.clone().add(dir.clone().normalize().multiplyScalar(t));
    points.push(pt);
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
  const line = new THREE.Line(geometry, material);
  scene.add(line);
}
function drawIntersection() {
  const i1 = parseInt(document.getElementById('plane1Select').value);
  const i2 = parseInt(document.getElementById('plane2Select').value);

  if (isNaN(i1) || isNaN(i2) || i1 === i2) {
    alert("⚠️ Vui lòng chọn hai mặt phẳng khác nhau");
    return;
  }

  const p1 = planeEquations[i1];
  const p2 = planeEquations[i2];

  intersectPlanes(p1, p2);
}

function drawLine3D() {
  const xExpr = document.getElementById('x0').value;
  const yExpr = document.getElementById('y0').value;
  const zExpr = document.getElementById('z0').value;

  const tMin = -10, tMax = 10, steps = 100;
  const points = [];

  for (let i = 0; i <= steps; i++) {
    const t = tMin + (tMax - tMin) * i / steps;
    const x = math.evaluate(xExpr, { t });
    const y = math.evaluate(yExpr, { t });
    const z = math.evaluate(zExpr, { t });
    points.push(new THREE.Vector3(x, y, z));
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  const line = new THREE.Line(geometry, material);

  scene.add(line);
}
function addPlaneInput() {
  const planeList = document.getElementById('planeList');
  const div = document.createElement('div');
  div.className = "flex space-x-1";
  div.innerHTML = `
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="a">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="b">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="c">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="d">
      <button onclick="this.parentElement.remove()" class="text-red-400">✖️</button>
    `;
  planeList.appendChild(div);
}


function drawPlaneFromParams(a, b, c, d) {
  const geometry = new THREE.PlaneGeometry(100, 100);
  const normal = new THREE.Vector3(a, b, c).normalize();
  const center = normal.clone().multiplyScalar(-d / normal.lengthSq());

  const material = new THREE.MeshStandardMaterial({
    color: Math.random() * 0xffffff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.4
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(center);
  mesh.lookAt(center.clone().add(normal));
  scene.add(mesh);
}


const historyList = document.getElementById('historyList');

function addToHistory(label, object3D) {
  const li = document.createElement('li');
  li.classList.add('flex', 'justify-between', 'items-center');

  const span = document.createElement('span');
  span.textContent = label;
  span.classList.add('cursor-pointer', 'hover:text-yellow-300', 'truncate');

  let visible = true;
  span.addEventListener('click', () => {
    visible = !visible;
    object3D.visible = visible;
    span.style.textDecoration = visible ? 'none' : 'line-through';
  });

  const deleteBtn = document.createElement('button');
  deleteBtn.textContent = '🗑';
  deleteBtn.classList.add('ml-2', 'hover:text-red-500');
  deleteBtn.addEventListener('click', () => {
    scene.remove(object3D);      // Xoá khỏi scene
    li.remove();                // Xoá khỏi giao diện lịch sử
  });

  li.appendChild(span);
  li.appendChild(deleteBtn);
  historyList.appendChild(li);
}

function updateLightMode() {
  const mode = document.getElementById("lightMode").value;
  const materialType = document.getElementById("materialType").value;
  const textureInput = document.getElementById("textureImage");
  const textureLabel = document.getElementById("textureLabel");

  if (!surfaceMesh) return;

  let newMaterial;

  // Ẩn/hiện phần chọn ảnh
  if (materialType === 'texture') {
    textureInput.classList.remove("hidden");
    textureLabel.classList.remove("hidden");
  } else {
    textureInput.classList.add("hidden");
    textureLabel.classList.add("hidden");
  }

  const texLoader = new THREE.TextureLoader();

  switch (materialType) {
    case 'phong':
      newMaterial = new THREE.MeshPhongMaterial({
        color: 0xffaa00,
        shininess: 100,
        side: THREE.DoubleSide
      });
      break;
    case 'lambert':
      newMaterial = new THREE.MeshLambertMaterial({
        color: 0x99ccff,
        side: THREE.DoubleSide
      });
      break;
    case 'toon':
      newMaterial = new THREE.MeshToonMaterial({
        color: 0xff99cc,
        gradientMap: null,
        side: THREE.DoubleSide
      });
      break;
    case 'texture':
      if (textureInput.files && textureInput.files[0]) {
        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;

            const texturedMat = new THREE.MeshStandardMaterial({
              map: texture,
              metalness: 0.2,
              roughness: mode === 'soft' ? 0.9 : 0.3,
              flatShading: mode === 'strong',
              side: THREE.DoubleSide
            });

            applyMaterial(texturedMat); // Áp dụng texture lên surfaceMesh
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(textureInput.files[0]);
        return; // ⚠️ QUAN TRỌNG! Tránh chạy tiếp các lệnh sau
      } else {
        alert("Vui lòng chọn ảnh.");
        return;
      }

      break;
    case 'standard':
    default:
      const baseTexture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
      newMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        map: baseTexture,
        metalness: 0.5,
        roughness: mode === 'soft' ? 0.9 : 0.3,
        flatShading: mode === 'strong',
        side: THREE.DoubleSide
      });
  }

  // Wireframe override
  if (mode === 'wireframe') {
    newMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      wireframe: true
    });
  }

  applyMaterial(newMaterial);
}

function applyMaterial(material) {
  if (surfaceMesh instanceof THREE.Mesh) {
    surfaceMesh.material.dispose();
    surfaceMesh.material = material;
  }
}
// Tính tích phân 1D và vẽ
function computeIntegral1D() {
  const formula = document.getElementById("integralFormula1D").value.replace(/^f\(x\)\s*=\s*/, '');
  const a = math.evaluate(document.getElementById("a1D").value); // Hỗ trợ π, e, sqrt()
  const b = math.evaluate(document.getElementById("b1D").value);
  const steps = parseInt(document.getElementById("integralSteps").value);
  const method = document.getElementById("integralMethod").value;

  const showSteps = document.getElementById("showIntegralSteps").checked;
  const expr = math.compile(formula);

  let area = 0;
  const dx = (b - a) / steps;
  const xVals = [], yVals = [], barData = [];
  let stepsHTML = `<table class="w-full table-auto border-collapse"><thead><tr class="border-b"><th>x</th><th>f(x)</th><th>f(x)·dx</th></tr></thead><tbody>`;

  if (method === "midpoint") {
    for (let i = 0; i < steps; i++) {
      const x = a + (i + 0.5) * dx;
      const y = expr.evaluate({ x });
      const slice = y * dx;
      area += slice;
      xVals.push(x);
      yVals.push(y);
      barData.push({ x: x, y: y });
      if (showSteps) {
        stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>${slice.toFixed(6)}</td></tr>`;
      }
    }
  } else if (method === "trapezoidal") {
    for (let i = 0; i <= steps; i++) {
      const x = a + i * dx;
      const y = expr.evaluate({ x });
      xVals.push(x);
      yVals.push(y);
      barData.push({ x, y });
      if (i === 0 || i === steps) area += y / 2;
      else area += y;
      if (showSteps) {
        stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>-</td></tr>`;
      }
    }
    area *= dx;
  } else if (method === "simpson" && steps % 2 === 0) {
    for (let i = 0; i <= steps; i++) {
      const x = a + i * dx;
      const y = expr.evaluate({ x });
      xVals.push(x);
      yVals.push(y);
      barData.push({ x, y });
      if (i === 0 || i === steps) area += y;
      else if (i % 2 === 0) area += 2 * y;
      else area += 4 * y;
      if (showSteps) {
        stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>-</td></tr>`;
      }
    }
    area *= dx / 3;
  } else {
    alert("Simpson's Rule requires even number of intervals.");
    return;
  }

  stepsHTML += `</tbody></table>`;
  document.getElementById("resultIntegral1D").innerText =
    `∫ f(x) dx từ ${a} đến ${b} ≈ ${area.toFixed(6)} (phương pháp: ${method})`;

  const detailDiv = document.getElementById("integralStepsTable");
  if (showSteps) {
    detailDiv.innerHTML = stepsHTML;
    detailDiv.classList.remove("hidden");
  } else {
    detailDiv.innerHTML = "";
    detailDiv.classList.add("hidden");
  }

  // VẼ BIỂU ĐỒ
  const ctx = document.getElementById("integralGraph1D").getContext("2d");

  if (window.chartIntegral1D) {
    window.chartIntegral1D.destroy(); // Tránh lỗi canvas dùng lại
  }

  window.chartIntegral1D = new Chart(ctx, {
    type: "bar", // Biểu đồ thanh + đường
    data: {
      datasets: [
        {
          type: "line",
          label: "f(x)",
          data: xVals.map((x, i) => ({ x: x, y: yVals[i] })),
          borderColor: "blue",
          backgroundColor: "rgba(59,130,246,0.2)",
          tension: 0.3,
          fill: true,
          parsing: false
        },
        {
          type: "bar",
          label: "Diện tích lát",
          data: barData,
          backgroundColor: "rgba(34,197,94,0.6)",
          borderWidth: 0,
          parsing: false,
          barThickness: Math.max(1, 300 / steps)
        }
      ]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          type: "linear",
          title: { display: true, text: "x" }
        },
        y: {
          title: { display: true, text: "f(x)" }
        }
      },
      plugins: {
        legend: { position: "top" },
      }
    }
  });
}


const showSteps = document.getElementById("showIntegralSteps").checked;
const detailDiv = document.getElementById("integralStepsTable");
if (showSteps) {
  detailDiv.innerHTML = stepsHTML;
  detailDiv.classList.remove("hidden");
} else {
  detailDiv.innerHTML = "";
  detailDiv.classList.add("hidden");
}

// Tính tích phân 2D đơn giản bằng phương pháp hình chữ nhật
function computeIntegral2D() {
  const formula = document.getElementById("integralFormula2D").value.replace(/^f\(x,y\)\s*=\s*/, '');
  const xMin = parseFloat(document.getElementById("a2D").value);
  const xMax = parseFloat(document.getElementById("b2D").value);
  const yMin = parseFloat(document.getElementById("c2D").value);
  const yMax = parseFloat(document.getElementById("d2D").value);
  const selectedMap = document.getElementById("colormapSelect").value;

  const expr = math.compile(formula);

  const stepsX = parseInt(document.getElementById("stepsX").value);
  const stepsY = parseInt(document.getElementById("stepsY").value);

  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  let sum = 0;
  for (let i = 0; i <= stepsX; i++) {
    const x = xMin + i * dx;
    for (let j = 0; j <= stepsY; j++) {
      const y = yMin + j * dy;
      const val = expr.evaluate({ x, y });
      if (isFinite(val)) sum += val * dx * dy;
    }
  }

  document.getElementById("resultIntegral2D").innerText =
    `∬ f(x,y) dxdy từ (${xMin},${yMin}) đến (${xMax},${yMax}) = ${sum.toFixed(6)}`;
  visualizeIntegral2D();
  draw2DHeatmap(formula, xMin, xMax, yMin, yMax, stepsX, stepsY, selectedMap);

}

function draw2DHeatmap(formula, xMin, xMax, yMin, yMax, stepsX, stepsY, colormapName = "viridis") {
  const ctx = document.getElementById("integralHeatmap2D")?.getContext("2d");
  if (!ctx) return;

  const expr = math.compile(formula);
  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  const data = [];
  let zMin = Infinity, zMax = -Infinity;

  for (let i = 0; i < stepsX; i++) {
    const x = xMin + i * dx + dx / 2;
    for (let j = 0; j < stepsY; j++) {
      const y = yMin + j * dy + dy / 2;
      try {
        const z = expr.evaluate({ x, y });
        if (!isFinite(z)) continue;
        data.push({ x, y, v: z });
        zMin = Math.min(zMin, z);
        zMax = Math.max(zMax, z);
      } catch (e) {
        console.warn(`Lỗi tại (${x},${y}):`, e.message);
      }
    }
  }

  if (window.heatmap2DChart) window.heatmap2DChart.destroy();

  window.heatmap2DChart = new Chart(ctx, {
    type: 'matrix',
    data: {
      datasets: [{
        label: 'f(x,y)',
        data: data,
        backgroundColor(ctx) {
          const point = ctx.dataset?.data?.[ctx.dataIndex];
          if (!point || typeof point.v !== "number") return "rgba(0,0,0,0)";
          const normalized = (point.v - zMin) / (zMax - zMin || 1);
          return getColorFromMap(normalized, colormapName);
        },

        width(ctx) {
          const area = ctx.chart.chartArea;
          if (!area) return 10;
          return area.width / stepsX;
        },
        height(ctx) {
          const area = ctx.chart.chartArea;
          if (!area) return 10;
          return area.height / stepsY;
        }
      }]
    },
    options: {
      maintainAspectRatio: true,
      responsive: true,
      plugins: {
        tooltip: {
          callbacks: {
            title: () => '',
            label: ctx => {
              const d = ctx.raw;
              return `x: ${d.x.toFixed(2)}, y: ${d.y.toFixed(2)}, z: ${d.v.toFixed(2)}`;
            }
          }
        },
        legend: { display: false }
      },
      scales: {
        x: {
          type: 'linear',
          min: xMin,
          max: xMax,
          title: { display: true, text: 'x' }
        },
        y: {
          type: 'linear',
          min: yMin,
          max: yMax,
          title: { display: true, text: 'y' }
        }
      }
    }
  });
}
document.getElementById("colormapSelect").addEventListener("change", () => {
  computeIntegral2D(); // gọi lại toàn bộ hàm để cập nhật colormap
});


function getColorFromMap(t, mapName = "viridis") {
  t = Math.min(1, Math.max(0, t)); // đảm bảo t ∈ [0,1]

  // Các colormap phổ biến
  switch (mapName) {
    case 'plasma':
      return plasmaColorMap(t);
    case 'turbo':
      return turboColorMap(t);
    case 'gray':
      const g = Math.floor(255 * t);
      return `rgba(${g},${g},${g},1)`;
    case 'viridis':
    default:
      return viridisColorMap(t);
  }
}

// Colormap viridis (giảm nhẹ để phù hợp)
function viridisColorMap(t) {
  const r = Math.floor(255 * Math.max(0, Math.min(1, 0.267 + 1.5 * t)));
  const g = Math.floor(255 * Math.max(0, Math.min(1, 0.004 + 2.0 * t)));
  const b = Math.floor(255 * Math.max(0, Math.min(1, 0.329 + 1.2 * t)));
  return `rgba(${r},${g},${b},1)`;
}

function plasmaColorMap(t) {
  const r = Math.floor(255 * Math.min(1, Math.max(0, 1.5 * t)));
  const g = Math.floor(255 * Math.abs(Math.sin(t * Math.PI)));
  const b = Math.floor(255 * (1 - t));
  return `rgba(${r},${g},${b},1)`;
}

function turboColorMap(t) {
  // https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html
  const r = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.75)))));
  const g = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.5)))));
  const b = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.25)))));
  return `rgba(${r},${g},${b},1)`;
}


function visualizeIntegral2D() {
  const formula = document.getElementById("integralFormula2D").value.replace(/^f\(x,y\)\s*=\s*/, '');
  const xMin = parseFloat(document.getElementById("a2D").value);
  const xMax = parseFloat(document.getElementById("b2D").value);
  const yMin = parseFloat(document.getElementById("c2D").value);
  const yMax = parseFloat(document.getElementById("d2D").value);

  const stepsX = parseInt(document.getElementById("stepsX").value);
  const stepsY = parseInt(document.getElementById("stepsY").value);

  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  const expr = math.compile(formula);
  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const colors = [];
  const color = new THREE.Color();

  for (let i = 0; i < stepsX; i++) {
    for (let j = 0; j < stepsY; j++) {
      const x1 = xMin + i * dx;
      const y1 = yMin + j * dy;
      const x2 = xMin + (i + 1) * dx;
      const y2 = yMin + (j + 1) * dy;

      const z11 = expr.evaluate({ x: x1, y: y1 });
      const z12 = expr.evaluate({ x: x1, y: y2 });
      const z21 = expr.evaluate({ x: x2, y: y1 });
      const z22 = expr.evaluate({ x: x2, y: y2 });

      // 2 mặt tam giác tạo hình chữ nhật
      vertices.push(x1, y1, 0, x1, y1, -z11, x2, y1, -z21);
      vertices.push(x1, y1, 0, x2, y1, -z21, x2, y1, 0);

      vertices.push(x1, y2, 0, x1, y2, -z12, x2, y2, -z22);
      vertices.push(x1, y2, 0, x2, y2, -z22, x2, y2, 0);

      const avgZ1 = (z11 + z21) / 2;
      const avgZ2 = (z12 + z22) / 2;
      for (let k = 0; k < 6; k++) {
        color.setHSL(0.6 - 0.6 * (avgZ1 / 10), 1.0, 0.5);
        colors.push(color.r, color.g, color.b);
      }
      for (let k = 0; k < 6; k++) {
        color.setHSL(0.6 - 0.6 * (avgZ2 / 10), 1.0, 0.5);
        colors.push(color.r, color.g, color.b);
      }
    }
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.6
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.name = "integralSurface";

  // Xóa mesh cũ nếu có
  const old = scene.getObjectByName("integralSurface");
  if (old) scene.remove(old);

  scene.add(mesh);

  
  // 🔍 Camera di chuyển lại gần mô hình sau khi vẽ
  if (camera && controls) {
    const centerX = (xMin + xMax) / 2;
    const centerY = (yMin + yMax) / 2;
    const centerZ = 3; // cao hơn một chút để thấy rõ bề mặt

    controls.target.set(centerX, centerY, 0);
    camera.position.set(centerX, centerY + (xMax - xMin) * 1.5, centerZ + 5);
    controls.update();
  }
}


// Xuất ảnh
function saveImage() {
  renderer.render(scene, camera);
  const link = document.createElement('a');
  link.download = 'screenshot.png';
  link.href = renderer.domElement.toDataURL('image/png');
  link.click();
}

// // Auto rotate toggle
// let autoRotate = true;
// document.addEventListener('keydown', e => {
//     if (e.key && e.key.toLowerCase() === 'r') {
//         autoRotate = !autoRotate;
//         console.log('Toggled autoRotate:', autoRotate);
//     }
// });
// ✅ Đặt biến này ở đầu file hoặc trước khi dùng đến
// let autoRotate = true;

// // ✅ Hiển thị trạng thái ban đầu (nếu có)
// const statusEl = document.getElementById('autoRotateStatus');
// function updateAutoRotateStatus() {
//     if (statusEl) {
//         statusEl.textContent = `Auto-Rotate: ${autoRotate ? 'On' : 'Off'}`;
//     }
// }

// // ✅ Bắt phím R để bật/tắt chế độ xoay tự động
// document.addEventListener('keydown', e => {
//     if (e.key && e.key.toLowerCase() === 'r') {
//         autoRotate = !autoRotate;
//         updateAutoRotateStatus();
//     }
// });
let autoRotate = true;

const toggleButton = document.getElementById('autoRotateToggle');

function updateAutoRotateUI() {
  toggleButton.textContent = autoRotate ? 'On' : 'Off';
  toggleButton.classList.toggle('bg-green-600', autoRotate);
  toggleButton.classList.toggle('bg-red-600', !autoRotate);
}

toggleButton.addEventListener('click', () => {
  autoRotate = !autoRotate;
  updateAutoRotateUI();
});

let formulaVisible = true;
const formulaToggle = document.getElementById('formulaToggle');

function updateFormulaToggleUI() {
  formulaToggle.textContent = formulaVisible ? 'On' : 'Off';
  formulaToggle.classList.toggle('bg-green-600', formulaVisible);
  formulaToggle.classList.toggle('bg-red-600', !formulaVisible);

  if (formulaLabel) {
    formulaLabel.visible = formulaVisible;
  }
}

formulaToggle.addEventListener('click', () => {
  formulaVisible = !formulaVisible;
  updateFormulaToggleUI();
});


function animate() {
  requestAnimationFrame(animate);
  if (autoRotate) scene.rotation.y += 0.001;
  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
});
let previousCameraPos = new THREE.Vector3(); // Lưu camera cũ
let previousTarget = new THREE.Vector3();    // Lưu target cũ nếu dùng controls.target

function setViewDirection() {
  const view = document.getElementById("viewSelector").value;

  // Lưu camera trước đó nếu chưa lưu
  if (!previousCameraPos) previousCameraPos = new THREE.Vector3();
  if (!previousTarget) previousTarget = new THREE.Vector3();
  previousCameraPos.copy(camera.position);
  previousTarget.copy(controls.target);

  scene.rotation.set(0, 0, 0);

  switch (view) {
    case 'xy': // Nhìn từ trên xuống
      camera.position.set(0, 100, 0);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;

      if (zAxis) zAxis.visible = false;
      if (zLabel) zLabel.visible = false;
      break;

    case 'yz': // Nhìn từ trục X (trái -> phải)
      camera.position.set(100, 0, 0);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;

      if (xAxis) xAxis.visible = false;
      if (xLabel) xLabel.visible = false;
      break;

    case 'xz': // Nhìn từ trước (trục Y lên)
      camera.position.set(0, 0, 100);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;

      if (yAxis) yAxis.visible = false;
      if (yLabel) yLabel.visible = false;
      break;

    default: // Trở về 3D
      camera.position.copy(previousCameraPos);
      controls.target.copy(previousTarget);
      controls.enableRotate = true;
      autoRotate = true;

      // Hiện lại các trục
      if (xAxis) xAxis.visible = true;
      if (yAxis) yAxis.visible = true;
      if (zAxis) zAxis.visible = true;
      if (xLabel) xLabel.visible = true;
      if (yLabel) yLabel.visible = true;
      if (zLabel) zLabel.visible = true;
      break;
  }

  controls.update();
  camera.lookAt(controls.target);
}

let points3D = []; // Danh sách các điểm đã thêm

function addPoint(pos) {
  // Tạo điểm
  const point = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 16, 16),
    new THREE.MeshStandardMaterial({ color: 0xff3333 }).clone()
  );
  point.position.copy(pos);
  scene.add(point);

  // Tạo nhãn
  const label = createLabel(`(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, pos.clone().add(new THREE.Vector3(1, 1, 0)), '#fff');

  // Lưu lại để quản lý
  points3D.push({ point, label, pos: pos.clone() });

  // Nếu có điểm trước đó thì vẽ vector (mũi tên)
  if (points3D.length >= 2) {
    const from = points3D[points3D.length - 2].pos;
    const to = pos;
    const dir = new THREE.Vector3().subVectors(to, from);
    const arrow = new THREE.ArrowHelper(dir.clone().normalize(), from.clone(), dir.length(), 0xffff00);
    scene.add(arrow);

    // Lưu vào lịch sử (tùy chọn)
    addToHistory(`Vector từ (${from.x.toFixed(1)}, ${from.y.toFixed(1)}, ${from.z.toFixed(1)}) đến (${to.x.toFixed(1)}, ${to.y.toFixed(1)}, ${to.z.toFixed(1)})`, arrow);
  }

  addToHistory(`Điểm (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, point);
}

function drawVectorFromInput() {
  const x1 = parseFloat(document.getElementById("x1").value);
  const y1 = parseFloat(document.getElementById("y1").value);
  const z1 = parseFloat(document.getElementById("z1").value);

  const x2 = parseFloat(document.getElementById("x2").value);
  const y2 = parseFloat(document.getElementById("y2").value);
  const z2 = parseFloat(document.getElementById("z2").value);

  if (
    isNaN(x1) || isNaN(y1) || isNaN(z1) ||
    isNaN(x2) || isNaN(y2) || isNaN(z2)
  ) {
    alert("Vui lòng nhập đầy đủ và hợp lệ các tọa độ.");
    return;
  }

  const from = new THREE.Vector3(x1, y1, z1);
  const to = new THREE.Vector3(x2, y2, z2);
  const dir = new THREE.Vector3().subVectors(to, from);
  const length = dir.length();
  const arrow = new THREE.ArrowHelper(dir.clone().normalize(), from, length, 0x00ff00);
  scene.add(arrow);

  // Thêm điểm và nhãn nếu muốn lưu
  addPoint(from);
  addPoint(to);

  addToHistory(`Vector từ (${x1}, ${y1}, ${z1}) đến (${x2}, ${y2}, ${z2})`, arrow);
}

//////////////
// Các hàm được dùng trong HTML cần gán vào window
window.drawVectorFromInput = drawVectorFromInput;
// window.toggleMiniForm = toggleMiniForm;
// window.switchTab = switchTab;
// window.toggleMenu = toggleMenu;
// window.toggleDiv = toggleDiv;
window.plotPrimitive = plotPrimitive;
window.plotSurface = plotSurface;
window.plot2D = plot2D;
window.plotPolar = plotPolar;
window.drawLine3D = drawLine3D;
window.addPlaneInput = addPlaneInput;
window.drawAllPlanes = drawAllPlanes;
window.plotCustom3D = plotCustom3D;
window.drawIntersection = drawIntersection;
window.saveImage = saveImage;
window.updateLightMode = updateLightMode;
window.toggle = toggle;
window.gridHelper = gridHelper;
// window.axisGroup = axisGroup;
window.axisTicksGroup = axisTicksGroup;
window.sphere = sphere; // nếu bạn đặt `sphereLine` đại diện cho mặt cầu 3D
window.heart = heart;
window.torus = torus;
window.spiral = spiral;
window.wave = wave;
window.saddle = saddle;
window.ellipsoid = ellipsoid;
window.paraboloid = paraboloid;
window.sincosWave = sincosWave;
window.mobius = mobius;
window.cone = cone;
window.cycloid = cycloid;
window.line = heart;  // nếu `line` dùng cho đường cong tùy chỉnh
window.setViewDirection = setViewDirection;
// Gán vào window để có thể dùng trong HTML
// window.xAxis = xAxis;
// window.yAxis = yAxis;
// window.zAxis = zAxis;
window.updateAxisAll = updateAxisAll;
window.oLabel = oLabel;
window.xLabel = xLabel;
window.yLabel = yLabel;
window.zLabel = zLabel;
window.computeIntegral2D = computeIntegral2D;
window.computeIntegral1D = computeIntegral1D;
  </script>

</body>

</html>