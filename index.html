<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Math 3D Plotter</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.1.0/dist/chartjs-chart-matrix.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111827;
    }

    canvas {
      display: block;
    }

    select option {
      color: #d1d5db;
      /* Tailwind's text-gray-300 */
      background-color: #1f2937;
      /* Tailwind's bg-gray-800 */
    }

    .tab-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      text-align: left;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .tab-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .active-tab {
      background-color: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.2);
    }

    /* áº¨n ná»n thanh cuá»™n cho Chrome, Edge, Safari */
    .custom-scroll::-webkit-scrollbar {
      width: 8px;
    }

    .custom-scroll::-webkit-scrollbar-track {
      background: transparent;
      /* ná»n trong suá»‘t */
    }

    .custom-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.3);
      /* thanh kÃ©o má» nháº¹ */
      border-radius: 4px;
    }

    /* Cho Firefox */
    .custom-scroll {
      scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
      scrollbar-width: thin;
    }
  </style>
</head>

<body>

  <!-- NÃºt má»Ÿ mini form -->
  <div class="fixed bottom-4 right-4 z-20 text-right">
    <button onclick="toggleMiniForm()"
      class="bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-full shadow-lg">
      âš™ï¸ CÃ i Äáº·t
    </button>

    <!-- Mini form vá»›i tabs -->
    <div id="miniForm"
      class="hidden mt-3 p-4 bg-black/80 backdrop-blur-md rounded-2xl shadow-2xl w-[28rem] max-h-[70vh] overflow-y-auto text-white border border-white/10">
      <script>
        function toggleMiniForm() {
          const form = document.getElementById('miniForm');
          form.classList.toggle('hidden');
        }
      </script>
      <!-- Flex chá»©a ná»™i dung vÃ  nÃºt tab dá»c -->
      <div class="flex space-x-4 text-left">

        <!-- Ná»™i dung tab bÃªn trÃ¡i -->
        <div class="flex-1">
          <!-- Tab: Hiá»ƒn thá»‹ -->
          <div id="tab-display" class="tab-content space-y-3">
            <div class="flex flex-wrap gap-2 text-sm">
              <!-- NÃºt toggle auto rotate -->
              <div id="toggleContainer" class="flex flex-wrap gap-4 text-white font-mono text-sm mt-2"></div>

              <script>
                const toggles = [
                  { id: "autoRotateToggle", label: "Auto-Rotate" },
                  { id: "formulaToggle", label: "Hiá»ƒn thá»‹ CÃ´ng Thá»©c" },
                  { id: "axisTicksToggle", label: "Show Axis Ticks" },
                  { id: "axisToggle", label: "Show Axes" }
                ];

                const toggleContainer = document.getElementById('toggleContainer');

                toggles.forEach(({ id, label }) => {
                  const group = document.createElement('div');
                  group.className = 'flex items-center space-x-2';

                  const span = document.createElement('span');
                  span.textContent = label;

                  const button = document.createElement('button');
                  button.id = id;
                  button.className = 'px-3 py-1 rounded bg-green-600 hover:bg-green-700 text-white shadow';
                  button.textContent = 'On';

                  group.appendChild(span);
                  group.appendChild(button);
                  toggleContainer.appendChild(group);
                });
              </script>

              <hr class="w-px h-auto border-l border-l border-gray-300 mx-2" />
            </div>
            <button onclick="toggle(axisGroup)" class="border px-3 py-1 rounded">Oxyz</button>
            <button onclick="toggle(gridHelper)" class="border px-3 py-1 rounded">LÆ°á»›i</button>
            <hr class="my-2 border-t border-dashed border-gray-300" />

            <div class="text-sm text-gray-600">
              <!-- Ná»™i dung khÃ¡c -->
              <p>ThÃ´ng tin bá»• sung, ghi chÃº hoáº·c hÆ°á»›ng dáº«n á»Ÿ Ä‘Ã¢y.</p>
            </div>
          </div>

          <div id="tab-sample" class="tab-content hidden">
            <select id="primitiveShape" class="border bg-transparent text-white rounded px-3 py-1 text-sm">
              <option value="none">Chá»n khá»‘i 2D/3D</option>
              <option value="cube">HÃ¬nh Láº­p PhÆ°Æ¡ng</option>
              <option value="sphere">HÃ¬nh Cáº§u</option>
              <option value="cylinder">HÃ¬nh Trá»¥</option>
              <option value="cone">HÃ¬nh NÃ³n</option>
              <option value="circle">HÃ¬nh TrÃ²n 2D</option>
              <option value="ellipse">Ellipse</option>
              <option value="triangle">Tam GiÃ¡c 2D</option>
              <option value="pentagon">NgÅ© GiÃ¡c 2D</option>
              <option value="hexagon">Lá»¥c GiÃ¡c 2D</option>
              <option value="pyramid">HÃ¬nh ChÃ³p</option>
              <option value="plane">Máº·t Pháº³ng</option>
            </select>
            <button onclick="plotPrimitive()" class="border px-3 py-1 rounded">â• ThÃªm</button>
            <hr class="my-2 border-t border-dashed border-gray-300" />

            <!-- HTML -->
            <div id="buttonContainer" class="overflow-auto max-h-80 grid grid-cols-2 sm:grid-cols-2 gap-2 text-sm">
            </div>

            <script>
              const objectButtons = [
                { label: 'âšª Khá»‘i Cáº§u', ref: 'sphere' },
                { label: 'â¤ï¸ TrÃ¡i Tim', ref: 'heart' },
                { label: 'ğŸŒ€ HÃ¬nh Xuyáº¿n', ref: 'torus' },
                { label: 'ğŸ”ƒ Xoáº¯n á»c', ref: 'spiral' },
                { label: 'ğŸŒŠ SÃ³ng Sin', ref: 'wave' },
                { label: 'ğŸ”º YÃªn Ngá»±a', ref: 'saddle' },
                { label: 'ğŸ§Š Elipsoid', ref: 'ellipsoid' },
                { label: 'ğŸ“ˆ Parabol 3D', ref: 'paraboloid' },
                { label: 'ğŸŒ€ Sin-Cos Wave', ref: 'sincosWave' },
                { label: 'â™¾ï¸ Mobius', ref: 'mobius' },
                { label: 'ğŸ”» Cone', ref: 'cone' },
                { label: 'ğŸŒ€ Cycloid', ref: 'cycloid' }
              ];


              const buttonContainer = document.getElementById('buttonContainer');

              objectButtons.forEach(({ label, ref }) => {
                const btn = document.createElement('button');
                btn.textContent = label;
                btn.className = 'border px-3 py-1 rounded';
                btn.onclick = () => toggle(window[ref]); // Truy cáº­p Ä‘á»‘i tÆ°á»£ng toÃ n cá»¥c
                buttonContainer.appendChild(btn);
              });
            </script>
          </div>

          <!-- Tab: GÃ³c NhÃ¬n -->
          <div id="tab-view" class="tab-content hidden">
            <span>Chá»n gÃ³c nhÃ¬n:</span>
            <select id="viewSelector" onchange="setViewDirection()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full mt-1">
              <option value="default">3D Tá»± Do</option>
              <option value="xy">XY (TrÃªn)</option>
              <option value="yz">YZ (TrÃ¡i)</option>
              <option value="xz">XZ (TrÆ°á»›c)</option>
            </select>
          </div>

          <!-- Tab: Ãnh sÃ¡ng -->
          <div id="tab-light" class="tab-content hidden space-y-3">
            <span>Cháº¿ Ä‘á»™ Ã¡nh sÃ¡ng:</span>
            <select id="lightMode" onchange="updateLightMode()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full">
              <option value="soft">Má»m</option>
              <option value="strong">Máº¡nh</option>
              <option value="wireframe">Chá»‰ khung</option>
            </select>

            <!-- Material Picker -->
            <span>Loáº¡i váº­t liá»‡u:</span>
            <select id="materialType" onchange="updateLightMode()"
              class="border bg-transparent text-white rounded px-2 py-1 text-sm w-full">
              <option value="standard">Standard</option>
              <option value="phong">Phong</option>
              <option value="lambert">Lambert</option>
              <option value="toon">Toon</option>
              <option value="texture">Texture</option>
            </select>

            <!-- Texture Picker (chá»‰ hiá»‡n náº¿u chá»n texture) -->
            <span id="textureLabel" class="hidden">Chá»n áº£nh ná»n:</span>
            <input type="file" id="textureImage" accept="image/*" class="hidden w-full text-white"
              onchange="updateLightMode()" />
          </div>


          <!-- Tab: Vector -->
          <div id="tab-vector" class="tab-content hidden space-y-3">
            <span>Vector:</span>
            <div id="vector-inputs" class="grid grid-cols-3 gap-3 text-sm font-medium mt-2"></div>
            <script>
              const vectorInputs = [
                { label: "X1", id: "x1" },
                { label: "Y1", id: "y1" },
                { label: "Z1", id: "z1" },
                { label: "X2", id: "x2" },
                { label: "Y2", id: "y2" },
                { label: "Z2", id: "z2" },
              ];

              const container = document.getElementById("vector-inputs");

              vectorInputs.forEach(({ label, id }) => {
                const wrapper = document.createElement("label");
                wrapper.className = "flex items-center space-x-1";

                const span = document.createElement("span");
                span.textContent = label + ":";

                const input = document.createElement("input");
                input.type = "number";
                input.id = id;
                input.step = "0.1";
                input.className = "w-20 p-1 border rounded text-black";

                wrapper.appendChild(span);
                wrapper.appendChild(input);
                container.appendChild(wrapper);
              });
            </script>
            <button onclick="drawVectorFromInput()" class="border px-3 py-1 rounded">Váº½ vector</button>
          </div>

          <!-- Tab: Trá»¥c -->
          <div id="tab-axis" class="tab-content hidden space-y-3">
            <span>ğŸšï¸ Äá»™ phÃ¢n giáº£i:</span>
            <input id="resolution" type="range" min="5" max="50" value="25" class="w-full">

            <div id="axis-inputs" class="grid grid-cols-2 gap-3 text-sm font-medium mt-2"></div>

            <script>
              const axisParams = [
                { label: 'X min', id: 'xMin', value: -50 },
                { label: 'X max', id: 'xMax', value: 50 },
                { label: 'Y min', id: 'yMin', value: -50 },
                { label: 'Y max', id: 'yMax', value: 50 }
              ];

              const axisInputsContainer = document.getElementById('axis-inputs');

              axisParams.forEach(param => {
                const label = document.createElement('label');
                label.className = 'flex flex-col';

                label.innerHTML = `
                  ${param.label}
                  <input id="${param.id}" type="number" value="${param.value}" class="text-black px-2 py-1 rounded-lg">
                `;

                axisInputsContainer.appendChild(label);
              });
            </script>
          </div>

          <div id="tab-history" class="tab-content hidden">
            <span>ğŸ§¾ Lá»‹ch Sá»­:</span>
            <ul id="historyList" class="space-y-1 text-sm list-disc list-inside"></ul>
          </div>
          <!-- Tab: Xuáº¥t áº£nh -->
          <div id="tab-export" class="tab-content hidden">
            <button onclick="saveImage()"
              class="w-full bg-red-600 hover:bg-red-700 transition px-4 py-2 rounded-xl font-semibold mt-2">
              ğŸ“¸ Xuáº¥t áº¢nh
            </button>
          </div>
          <!-- Tab: TÃ­ch PhÃ¢n -->
          <div id="tab-integral" class="tab-content custom-scroll overflow-auto max-h-80 hidden space-y-4 text-sm">
            <div class="grid grid-cols-2 gap-2 text-sm font-medium m-2">

              <label for="integralMethod" class="block">PhÆ°Æ¡ng phÃ¡p tÃ­nh:</label>
              <select id="integralMethod" class="border bg-transparent text-white rounded p-1 text-sm">
                <option value="midpoint">Midpoint</option>
                <option value="trapezoidal">Trapezoidal</option>
                <option value="simpson">Simpson</option>
              </select>
              <label for="integralSteps" class="block mt-2">Sá»‘ Ä‘oáº¡n chia (n):</label>
              <input id="integralSteps" type="number" min="10" value="200" class="text-black p-1 rounded-lg" />
            </div>


            <span>ğŸ“ˆ TÃ­nh TÃ­ch PhÃ¢n 1 Biáº¿n (âˆ« f(x) dx):</span>
            <div class="grid grid-cols-2 gap-2 text-sm font-medium m-2">

              <input id="integralFormula1D" type="text" placeholder="f(x) = x^2"
                class="w-full text-black px-2 py-1 rounded" />
              <div class="grid grid-cols-2 gap-2">
                <input id="a1D" type="text" placeholder="Nháº­p a (vÃ­ dá»¥: 0, pi, sqrt(2))"
                  class="text-black px-2 py-1 rounded border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-400" />
                <input id="b1D" type="text" placeholder="Nháº­p b (vÃ­ dá»¥: 2*pi, e)"
                  class="text-black px-2 py-1 rounded border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-400" />
              </div>
            </div>
            <!-- âœ… THÃŠM PHáº¦N NÃ€Y NGAY SAU BUTTON "TÃ­nh vÃ  Váº½" -->
            <div class="space-y-2">
              <label class="inline-flex items-center space-x-2">
                <input type="checkbox" id="showIntegralSteps" class="text-black">
                <span>Hiá»‡n chi tiáº¿t tá»«ng bÆ°á»›c</span>
              </label>
              <div id="integralStepsTable"
                class="overflow-auto max-h-64 bg-black/20 p-2 rounded hidden text-xs text-white font-mono"></div>
            </div>


            <button onclick="computeIntegral1D()" class="border px-3 py-1 rounded">ğŸ“Š TÃ­nh vÃ  Váº½</button>
            <canvas id="integralGraph1D" width="600" height="250" class="bg-white rounded shadow-md"></canvas>
            <div id="resultIntegral1D" class="text-green-400 font-bold"></div>

            <hr class="border-t border-gray-300" />

            <span>ğŸ“Š TÃ­nh TÃ­ch PhÃ¢n 2 Biáº¿n (âˆ¬ f(x,y) dxdy):</span>
            <input id="integralFormula2D" type="text" placeholder="f(x,y) = x*y"
              class="w-full text-black px-2 py-1 rounded" />
            <div class="grid grid-cols-2 gap-2">
              <input id="stepsX" type="number" value="50" class="text-black w-full px-2 py-1 rounded" />
              <input id="stepsY" type="number" value="50" class="text-black w-full px-2 py-1 rounded" />

              <input id="a2D" type="number" placeholder="x min" class="text-black px-2 py-1 rounded" />
              <input id="b2D" type="number" placeholder="x max" class="text-black px-2 py-1 rounded" />
              <input id="c2D" type="number" placeholder="y min" class="text-black px-2 py-1 rounded" />
              <input id="d2D" type="number" placeholder="y max" class="text-black px-2 py-1 rounded" />
            </div>
            <label for="colormapSelect" class="block mb-2 text-sm font-medium text-gray-700">Chá»n Colormap:</label>
            <select id="colormapSelect" class="mb-4 px-4 py-2 border rounded-md">
              <option value="viridis">Viridis</option>
              <option value="plasma">Plasma</option>
              <option value="turbo">Turbo</option>
              <option value="gray">Gray</option>
            </select>

            <button onclick="computeIntegral2D()" class="border px-3 py-1 rounded">ğŸ§® TÃ­nh</button>
            <div id="resultIntegral2D" class="text-yellow-300 font-bold"></div>
            <canvas id="integralHeatmap2D" width="600" height="250" class="mt-4 border border-gray-300"></canvas>

          </div>

        </div>

        <!-- NÃºt tab dá»c bÃªn pháº£i -->
        <div
          class="custom-scroll overflow-auto max-h-80 flex flex-col border-l border-white/20 p-2 space-y-2 text-sm font-semibold min-w-[7rem]">
          <button class="tab-btn active-tab" onclick="switchTab(event, 'tab-display')">ğŸ›ï¸ Hiá»ƒn Thá»‹</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-view')">ğŸ§­ GÃ³c NhÃ¬n</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-sample')">Máº«u HÃ¬nh</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-light')">ğŸ’¡ Ãnh SÃ¡ng</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-vector')">Vector</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-axis')">ğŸ“ Trá»¥c</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-history')">ğŸ§¾ Lá»‹ch sá»­</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-export')">ğŸ“¸ Xuáº¥t</button>
          <button class="tab-btn" onclick="switchTab(event, 'tab-integral')">âˆ« TÃ­ch PhÃ¢n</button>

          <script>
            function switchTab(evt, tabId) {
              // áº¨n toÃ n bá»™ tab content
              document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));

              // Bá» active-tab khá»i táº¥t cáº£ nÃºt
              document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active-tab'));

              // Hiá»‡n tab Ä‘Æ°á»£c chá»n
              document.getElementById(tabId).classList.remove('hidden');

              // ÄÃ¡nh dáº¥u nÃºt Ä‘ang Ä‘Æ°á»£c chá»n
              evt.currentTarget.classList.add('active-tab');
            }
          </script>
        </div>

      </div>
    </div>

  </div>

  <!-- NÃºt 3 gáº¡ch Ä‘á»ƒ báº­t menu -->
  <button onclick="toggleMenu()" class="fixed top-4 right-4 z-40 p-2 bg-black/80 text-white rounded-md shadow-md">
    <!-- Biá»ƒu tÆ°á»£ng 3 gáº¡ch -->
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"
      stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
    </svg>
  </button>

  <!-- Floating Menu -->
  <div id="floatingMenu"
    class="hidden fixed top-4 right-20 translate-x-1/2 z-30 bg-black/80 text-white rounded-xl px-4 py-3 space-y-2 shadow-xl border border-white/10">
    <script>
      function toggleMenu() {
        const menu = document.getElementById('floatingMenu');
        menu.classList.toggle('hidden');
      }
      function toggleDiv(id) {
        const el = document.getElementById(id);
        if (el) {
          el.classList.toggle('hidden');
        }
      }
      const panels = [
        { id: 'formulaPanel', label: 'ğŸ“ CÃ´ng Thá»©c' },
        { id: 'formulaPanel2D', label: 'ğŸ“ CÃ´ng Thá»©c 2D' },
        { id: 'geometryPanel', label: 'ğŸ“ PhÆ°Æ¡ng TrÃ¬nh HÃ¬nh Há»c' },
        { id: 'customFormula', label: 'CÃ´ng thá»©c tÃ¹y chá»‰nh' }

      ];

      document.addEventListener('DOMContentLoaded', () => {
        const floatingMenu = document.getElementById('floatingMenu');
        if (!floatingMenu) return;

        panels.forEach(panel => {
          const wrapper = document.createElement('div');
          wrapper.className = 'flex items-center space-x-2';

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `toggle${panel.id.charAt(0).toUpperCase() + panel.id.slice(1)}`;
          checkbox.onchange = () => toggleDiv(panel.id);

          const label = document.createElement('label');
          label.htmlFor = checkbox.id;
          label.textContent = panel.label;

          wrapper.appendChild(checkbox);
          wrapper.appendChild(label);
          floatingMenu.appendChild(wrapper);
        });
      });
    </script>
  </div>

  <div id="geometryPanel"
    class="hidden absolute top-[200px] left-96 bg-black/60 p-5 rounded-2xl text-white space-y-4 z-10 w-96 max-h-[70vh] overflow-y-auto shadow-2xl border border-white/10">

    <div class="space-y-2">
      <span>ğŸ“Œ Giao tuyáº¿n giá»¯a hai máº·t pháº³ng</span>
      <div class="grid grid-cols-2 gap-2 text-sm">
        <select id="plane1Select" class="text-black px-2 py-1 rounded"></select>
        <select id="plane2Select" class="text-black px-2 py-1 rounded"></select>
      </div>
      <button onclick="drawIntersection()" class="bg-yellow-600 hover:bg-yellow-700 w-full py-1 rounded">ğŸ“ Váº½ giao
        tuyáº¿n</button>
    </div>
    <!-- ÄÆ°á»ng tháº³ng -->
    <div class="space-y-2">
      <span>ğŸ“ ÄÆ°á»ng tháº³ng (tham sá»‘)</span>
      <input id="x0" class="text-black w-full px-2 py-1 rounded" placeholder="x = x0 + at">
      <input id="y0" class="text-black w-full px-2 py-1 rounded" placeholder="y = y0 + bt">
      <input id="z0" class="text-black w-full px-2 py-1 rounded" placeholder="z = z0 + ct">
      <button onclick="drawLine3D()" class="bg-green-600 hover:bg-green-700 w-full py-2 rounded">ğŸ“ˆ Váº½ Ä‘Æ°á»ng
        tháº³ng</button>
    </div>
    <div class="space-y-2">
      <span>ğŸ§® Danh sÃ¡ch phÆ°Æ¡ng trÃ¬nh máº·t pháº³ng</span>
      <span>ğŸ§± Máº·t Pháº³ng (ax + by + cz + d = 0)</span>
      <div id="planeList" class="space-y-2"></div>
      <button onclick="addPlaneInput()" class="bg-gray-600 hover:bg-gray-700 w-full py-1 rounded">â• ThÃªm máº·t
        pháº³ng</button>
      <button onclick="drawAllPlanes()" class="bg-blue-600 hover:bg-blue-700 w-full py-1 rounded">ğŸ“ Váº½ táº¥t cáº£</button>
    </div>
    <span>ğŸ¯ Kiá»ƒm tra quan há»‡ giá»¯a 2 vector</span>
    <div class="grid grid-cols-2 gap-2">
      <input id="v1" class="text-black px-2 py-1 rounded" placeholder="VD: [1,2,3]">
      <input id="v2" class="text-black px-2 py-1 rounded" placeholder="VD: [-1,4,2]">
    </div>
    <button onclick="checkVectors()" class="w-full py-1 rounded bg-indigo-600 hover:bg-indigo-700 mt-2">ğŸ” Kiá»ƒm
      Tra</button>
    <div id="checkResult" class="text-sm text-white mt-2"></div>
    <script>
      function checkVectors() {
        const v1 = JSON.parse(document.getElementById('v1').value);
        const v2 = JSON.parse(document.getElementById('v2').value);
        const vec1 = new THREE.Vector3(...v1);
        const vec2 = new THREE.Vector3(...v2);

        const dot = vec1.dot(vec2);
        const cross = new THREE.Vector3().crossVectors(vec1, vec2);
        let result = "";

        if (dot === 0) result += "âœ… Hai vector vuÃ´ng gÃ³c<br/>";
        if (cross.length() === 0) result += "âœ… Hai vector song song<br/>";
        if (!result) result = "âŒ KhÃ´ng vuÃ´ng gÃ³c, khÃ´ng song song";

        document.getElementById('checkResult').innerHTML = result;
      }

    </script>
  </div>
  <div id="formulaPanel2D"
    class="hidden absolute top-[200px] left-4 bg-black/60 backdrop-blur-md p-5 rounded-2xl text-white space-y-4 z-10 w-80 max-h-[70vh] overflow-y-auto shadow-2xl border border-white/10">
    <div class="space-y-2 mt-6">
      <span>ğŸ“ˆ HÃ m Sá»‘ 2D: y = f(x)</span>
      <input id="inputFormula2D" type="text" class="w-full text-black px-3 py-2 rounded-lg"
        placeholder="y = x^3 - 3x - 1" />
      <button onclick="plot2D()" class="w-full bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-xl font-semibold">
        ğŸ“ˆ Váº½ Äá»“ Thá»‹ 2D
      </button>
      <canvas id="graph2D" class="w-full bg-white rounded-xl p-2 shadow-xl" height="300"></canvas>
      <script>
        let chart2D;

        function plot2D() {
          const input = document.getElementById("inputFormula2D").value.trim();
          if (!/^y\s*=/.test(input)) {
            alert("Vui lÃ²ng nháº­p cÃ´ng thá»©c dÆ°á»›i dáº¡ng: y = f(x)");
            return;
          }


          const exprStr = input
            .replace(/^y\s*=\s*/, "")   // bá» pháº§n y =
            .replace(/âˆ’/g, "-")         // thay dáº¥u trá»« Unicode
            .replace(/Ã—/g, "*")         // thay dáº¥u nhÃ¢n Unicode náº¿u cÃ³
            .replace(/Ã·/g, "/");        // thay dáº¥u chia Unicode náº¿u cÃ³

          let expr;
          try {
            expr = math.compile(exprStr);
          } catch (e) {
            alert("CÃ´ng thá»©c sai: " + e.message);
            return;
          }

          const xValues = [];
          const yValues = [];
          for (let x = -10; x <= 10; x += 0.1) {
            try {
              const y = expr.evaluate({ x });
              if (typeof y === "number" && isFinite(y)) {
                xValues.push(x);
                yValues.push(y);
              } else {
                xValues.push(x);
                yValues.push(null);
              }
            } catch {
              xValues.push(x);
              yValues.push(null);
            }
          }

          if (chart2D) chart2D.destroy();

          const ctx = document.getElementById("graph2D").getContext("2d");
          chart2D = new Chart(ctx, {
            type: "line",
            data: {
              labels: xValues,
              datasets: [{
                label: input,
                data: yValues,
                borderColor: "rgb(75, 192, 192)",
                borderWidth: 2,
                pointRadius: 0,
                fill: false,
              }],
            },
            options: {
              responsive: true,
              scales: {
                x: { type: "linear", title: { display: true, text: "x" } },
                y: { title: { display: true, text: "y" } },
              },
            },
          });
        }
      </script>
    </div>
  </div>
  <div id="customFormula"
    class="hidden absolute top-[200px] left-96 bg-black/60 p-5 rounded-2xl text-white space-y-4 z-10 w-96 max-h-[70vh] overflow-y-auto shadow-2xl border border-white/10">
    <div class="space-y-2">
      <span>ğŸ“ˆ CÃ´ng Thá»©c r = f(Î¸)</span>
      <input id="polarFormula" type="text" class="w-full text-black px-3 py-2 rounded-lg"
        placeholder="r = 10 * sin(3 * theta)">
      <button onclick="plotPolar()"
        class="w-full bg-purple-600 hover:bg-purple-700 transition px-4 py-2 rounded-xl font-semibold">ğŸ“‰ Váº½ Äá»“
        Thá»‹
        Cá»±c</button>
    </div>

    <div class="space-y-2">
      <span>ğŸ§® CÃ´ng Thá»©c TÃ¹y Chá»‰nh (x, y, z)</span>
      <input id="customX" type="text" class="w-full text-black px-3 py-2 rounded-lg" placeholder="x = ...">
      <input id="customY" type="text" class="w-full text-black px-3 py-2 rounded-lg" placeholder="y = ...">
      <input id="customZ" type="text" class="w-full text-black px-3 py-2 rounded-lg" placeholder="z = ...">
      <div class="grid grid-cols-3 gap-2 text-sm text-white font-medium">
        <label class="flex flex-col">t min <input id="tMin" type="number" value="0"
            class="w-full text-black px-2 py-1 rounded-lg"></label>
        <label class="flex flex-col">t max <input id="tMax" type="number" value="6.28"
            class="w-full text-black px-2 py-1 rounded-lg"></label>
        <label class="flex flex-col">res <input id="tRes" type="number" value="200"
            class="w-full text-black px-2 py-1 rounded-lg"></label>
      </div>
      <button onclick="plotCustom3D()"
        class="w-full bg-yellow-500 hover:bg-yellow-600 transition px-4 py-2 rounded-xl font-semibold">ğŸ§ª Váº½ HÃ¬nh
        TÃ¹y
        Chá»‰nh</button>
    </div>
  </div>
  <div id="formulaPanel"
    class="hidden absolute top-[200px] left-4 bg-black/60 backdrop-blur-md p-5 rounded-2xl text-white space-y-4 z-10 w-80 max-h-[70vh] overflow-y-auto shadow-2xl border border-white/10">


    <div class="space-y-2">
      <span>ğŸ§® CÃ´ng Thá»©c z = f(x, y)</span>
      <input id="inputFormula" type="text" class="w-full text-black px-3 py-2 rounded-lg"
        placeholder="z = sin(x) + cos(y)">
      <select id="mode" class="w-full text-black px-3 py-2 rounded-lg">
        <option value="surface">Bá» Máº·t Má»‹n</option>
        <option value="line">Dáº¡ng Line</option>
      </select>
      <button onclick="plotSurface()"
        class="w-full bg-green-600 hover:bg-green-700 transition px-4 py-2 rounded-xl font-semibold">ğŸ“Š Váº½ Äá»“
        Thá»‹</button>

      <div class="space-y-2">
        <span>ğŸ§® Äáº¡o hÃ m & Vi phÃ¢n</span>
        <button onclick="computeDerivatives()"
          class="w-full bg-blue-600 hover:bg-blue-700 transition px-4 py-2 rounded-xl font-semibold">ğŸ§® TÃ­nh Äáº¡o
          HÃ m</button>

        <div id="derivativeResult" class="text-sm text-white bg-white/10 p-2 rounded-lg whitespace-pre-line mt-2"></div>

        <button onclick="plotDerivative('dx')" class="border px-3 py-1 rounded">âˆ‚z/âˆ‚x</button>
        <button onclick="plotDerivative('dy')" class="border px-3 py-1 rounded">âˆ‚z/âˆ‚y</button>
        <button onclick="plotDerivative('dx2')" class="border px-3 py-1 rounded">âˆ‚Â²z/âˆ‚xÂ²</button>
        <button onclick="plotDerivative('dy2')" class="border px-3 py-1 rounded">âˆ‚Â²z/âˆ‚yÂ²</button>
        <button onclick="plotDerivative('dxdy')" class="border px-3 py-1 rounded">âˆ‚Â²z/âˆ‚xâˆ‚y</button>
        <script>
          let derivatives = {}; // lÆ°u láº¡i cÃ¡c cÃ´ng thá»©c Ä‘áº¡o hÃ m
          function plotDerivative(key) {
            const formula = derivatives[key];
            if (!formula) {
              alert("â— Vui lÃ²ng nháº¥n 'TÃ­nh Äáº¡o HÃ m' trÆ°á»›c khi váº½ Ä‘á»“ thá»‹.");
              return;
            }

            const formulaInput = document.getElementById("inputFormula");
            formulaInput.value = "z = " + formula;
            plotSurface(); // váº½ láº¡i Ä‘á»“ thá»‹ dá»±a trÃªn input
          }
          function computeDerivatives() {
            const input = document.getElementById("inputFormula").value;
            const expr = input.replace(/^z\s*=\s*/, "");

            try {
              const dz_dx = math.derivative(expr, 'x').toString();
              const dz_dy = math.derivative(expr, 'y').toString();
              const d2z_dx2 = math.derivative(dz_dx, 'x').toString();
              const d2z_dy2 = math.derivative(dz_dy, 'y').toString();
              const d2z_dxdy = math.derivative(dz_dx, 'y').toString();

              // TÃ­nh vi phÃ¢n Ä‘áº§y Ä‘á»§
              const differential = `dz = (${dz_dx}) dx + (${dz_dy}) dy`;

              // LÆ°u cÃ´ng thá»©c Ä‘á»ƒ váº½ Ä‘á»“ thá»‹
              derivatives = {
                dx: dz_dx,
                dy: dz_dy,
                dx2: d2z_dx2,
                dy2: d2z_dy2,
                dxdy: d2z_dxdy
              };

              const result = `
          âˆ‚z/âˆ‚x = ${dz_dx}
          âˆ‚z/âˆ‚y = ${dz_dy}
          âˆ‚Â²z/âˆ‚xÂ² = ${d2z_dx2}
          âˆ‚Â²z/âˆ‚yÂ² = ${d2z_dy2}
          âˆ‚Â²z/âˆ‚xâˆ‚y = ${d2z_dxdy}
          
          ${differential}
                `.trim();

              document.getElementById("derivativeResult").innerText = result;

            } catch (err) {
              document.getElementById("derivativeResult").innerText = "âŒ Lá»—i cÃ´ng thá»©c hoáº·c khÃ´ng thá»ƒ tÃ­nh Ä‘áº¡o hÃ m.";
            }
          }
        </script>


      </div>

    </div>


  </div>



  <script>


    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(60, 60, 60);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Label renderer
    const labelRenderer = new THREE.CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;


    let gridHelper = new THREE.GridHelper(100, 20);
    scene.add(gridHelper);

    // Light
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(50, 50, 100);
    scene.add(light);

    // HÃ m táº¡o trá»¥c
    let axisGroup = new THREE.Group(); // NhÃ³m chá»©a cÃ¡c trá»¥c
    scene.add(axisGroup);

    function createFullAxis(axis = 'x', length = 50, color = 0xffffff) {
      const dirMap = {
        x: new THREE.Vector3(1, 0, 0),
        y: new THREE.Vector3(0, 1, 0),
        z: new THREE.Vector3(0, 0, 1)
      };

      const dir = dirMap[axis];
      if (!dir) return;

      // ÄÆ°á»ng trá»¥c tá»« -length Ä‘áº¿n +length
      const points = [
        dir.clone().multiplyScalar(-length),
        dir.clone().multiplyScalar(length)
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color });
      const line = new THREE.Line(geometry, material);
      axisGroup.add(line); // âœ… ThÃªm vÃ o group

      // MÅ©i tÃªn dÆ°Æ¡ng
      const arrowPos1 = dir.clone().multiplyScalar(length);
      const arrow1 = new THREE.ArrowHelper(dir.clone().normalize(), arrowPos1, 3, color, 1, 0.5);
      axisGroup.add(arrow1); // âœ…

      // MÅ©i tÃªn Ã¢m
      const dirNeg = dir.clone().negate();
      const arrowPos2 = dirNeg.clone().multiplyScalar(length);
      const arrow2 = new THREE.ArrowHelper(dirNeg.normalize(), arrowPos2, 3, color, 1, 0.5);
      axisGroup.add(arrow2); // âœ…
    }

    let showAxis = true;
    const axisToggleBtn = document.getElementById('axisToggle');

    function updateAxisUI() {
      axisToggleBtn.textContent = showAxis ? 'On' : 'Off';
      axisToggleBtn.classList.toggle('bg-green-600', showAxis);
      axisToggleBtn.classList.toggle('bg-red-600', !showAxis);

      axisGroup.visible = showAxis;

      // CSS2DObject khÃ´ng áº©n theo group.visible nÃªn cáº§n xá»­ lÃ½ thá»§ cÃ´ng
      axisGroup.children.forEach(child => {
        if (child instanceof THREE.CSS2DObject) {
          child.visible = showAxis;
        }
      });
    }


    axisToggleBtn.addEventListener('click', () => {
      showAxis = !showAxis;
      updateAxisUI();
    });

    // Gá»i cÃ¡c trá»¥c nhÆ° trÆ°á»›c
    createFullAxis('x', 50, 0xff0000);
    createFullAxis('y', 50, 0x00ff00);
    createFullAxis('z', 50, 0x00ffff);


    // Labels
    function createLabel(text, pos, color) {
      const div = document.createElement('div');
      div.textContent = text;
      div.style.color = color;
      div.style.fontWeight = 'bold';
      const label = new THREE.CSS2DObject(div);
      label.position.copy(pos);
      axisGroup.add(label); // ğŸŸ¢ add vÃ o group luÃ´n
      return label; // âœ… tráº£ vá» Ä‘á»‘i tÆ°á»£ng label

    }
    const oLabel = createLabel('.', new THREE.Vector3(0, 0, 0), 'white');
    const xLabel = createLabel('X', new THREE.Vector3(55, 0, 0), 'red');
    const yLabel = createLabel('Y', new THREE.Vector3(0, 55, 0), 'lime');
    const zLabel = createLabel('Z', new THREE.Vector3(0, 0, 55), 'cyan');

    let showAxisTicks = true;
    const axisTicksToggleBtn = document.getElementById('axisTicksToggle');
    let axisTicksGroup = new THREE.Group(); // NhÃ³m Ä‘á»ƒ dá»… áº©n/hiá»‡n táº¥t cáº£ tick

    function updateAxisTicksUI() {
      axisTicksToggleBtn.textContent = showAxisTicks ? 'On' : 'Off';
      axisTicksToggleBtn.classList.toggle('bg-green-600', showAxisTicks);
      axisTicksToggleBtn.classList.toggle('bg-red-600', !showAxisTicks);

      // Báº­t táº¯t cÃ¡c tick (Line)
      axisTicksGroup.children.forEach(child => {
        if (child instanceof THREE.Line) {
          child.visible = showAxisTicks;
        }

        // Náº¿u lÃ  label (CSS2DObject)
        if (child instanceof THREE.CSS2DObject) {
          child.visible = showAxisTicks;
        }
      });
    }


    axisTicksToggleBtn.addEventListener('click', () => {
      showAxisTicks = !showAxisTicks;
      updateAxisTicksUI();
    });

    // DÃ¹ng nhÃ³m Ä‘á»ƒ chá»©a táº¥t cáº£ ticks
    function addAxisTicks(axis = 'x', step = 5, min = -50, max = 50, color = 'white') {
      const dirVectors = {
        x: {
          from: (i) => [new THREE.Vector3(i, -0.5, 0), new THREE.Vector3(i, 0.5, 0)],
          pos: (i) => new THREE.Vector3(i, 0, 0)
        },
        y: {
          from: (i) => [new THREE.Vector3(-0.5, i, 0), new THREE.Vector3(0.5, i, 0)],
          pos: (i) => new THREE.Vector3(0, i, 0)
        },
        z: {
          from: (i) => [new THREE.Vector3(0, -0.5, i), new THREE.Vector3(0, 0.5, i)],
          pos: (i) => new THREE.Vector3(0, 0, i)
        }
      };

      const data = dirVectors[axis];
      if (!data) return;

      const material = new THREE.LineBasicMaterial({ color });

      for (let i = min; i <= max; i += step) {
        if (i === 0) continue;

        const points = data.from(i);
        const tick = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(points),
          material
        );
        axisTicksGroup.add(tick);

        const label = createLabel(`${i}`, data.pos(i), color);
        axisTicksGroup.add(label);
      }
    }

    // ThÃªm ticks 1 láº§n
    addAxisTicks('x', 5, -50, 50, 'white');
    addAxisTicks('y', 5, -50, 50, 'white');
    addAxisTicks('z', 5, -50, 50, 'white');
    scene.add(axisTicksGroup);





    function createFormulaLabel(text, position = new THREE.Vector3(0, 0, 0)) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;

      ctx.fillStyle = 'white';
      ctx.font = 'bold 32px monospace';
      ctx.fillText(text, 20, 80);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);

      sprite.scale.set(10, 2.5, 1); // tÃ¹y chá»‰nh kÃ­ch thÆ°á»›c
      sprite.position.copy(position.clone().add(new THREE.Vector3(0, 5, 0))); // Ä‘áº·t phÃ­a trÃªn Ä‘á»“ thá»‹

      return sprite;
    }


    // âœ… HÃ m ná»™i suy tuyáº¿n tÃ­nh
    const lerp = (a, b, t) => a + (b - a) * t;

    // âœ… Táº¡o Ä‘iá»ƒm tá»« hÃ m 1 biáº¿n
    function createParametricPoints(fn, [t0, t1], steps) {
      return Array.from({ length: steps + 1 }, (_, i) => fn(lerp(t0, t1, i / steps)));
    }

    // âœ… Táº¡o Ä‘oáº¡n ná»‘i tá»« hÃ m 2 biáº¿n (u, v)
    function createParametricSegments(fn, [u0, u1], [v0, v1], segments) {
      const points = [];

      for (let i = 1; i < segments; i++) {
        const u = lerp(u0, u1, i / segments);
        for (let j = 0; j < segments; j++) {
          const v1a = lerp(v0, v1, j / segments);
          const v1b = lerp(v0, v1, (j + 1) / segments);
          points.push(fn(u, v1a), fn(u, v1b)); // vÄ© tuyáº¿n
        }
      }

      for (let j = 0; j < segments; j++) {
        const v = lerp(v0, v1, j / segments);
        for (let i = 0; i < segments; i++) {
          const u1a = lerp(u0, u1, i / segments);
          const u1b = lerp(u0, u1, (i + 1) / segments);
          points.push(fn(u1a, v), fn(u1b, v)); // kinh tuyáº¿n
        }
      }

      return points;
    }
    // geometryFunctions.js

    // ğŸ¯ Máº·t cáº§u 3D
    function sphere3D(theta, phi, r = 5) {
      return new THREE.Vector3(
        r * Math.sin(theta) * Math.cos(phi),
        r * Math.sin(theta) * Math.sin(phi),
        r * Math.cos(theta)
      );
    }

    // â¤ï¸ TrÃ¡i tim 3D
    function heart3D(t, s = 2.5) {
      return new THREE.Vector3(
        s * 16 * Math.pow(Math.sin(t), 3),
        s * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)),
        s * 4 * Math.sin(2 * t)
      );
    }
    // ğŸ”· HÃ¬nh xuyáº¿n (Torus)
    function torus3D(u, v, R = 4, r = 1.5) {
      return new THREE.Vector3(
        (R + r * Math.cos(v)) * Math.cos(u),
        (R + r * Math.cos(v)) * Math.sin(u),
        r * Math.sin(v)
      );
    }

    // ğŸ”· SÃ³ng Sin 3D
    function wave3D(x, z, A = 1, f = 1) {
      return new THREE.Vector3(
        x,
        A * Math.sin(f * (x ** 2 + z ** 2)),
        z
      );
    }

    // ğŸ”· HÃ¬nh xoáº¯n á»‘c
    function spiral3D(t, a = 0.1, b = 0.2) {
      return new THREE.Vector3(
        a * t * Math.cos(t),
        a * t * Math.sin(t),
        b * t
      );
    }

    // ğŸ”· Máº·t yÃªn ngá»±a (Hyperbolic Paraboloid)
    function saddle3D(x, z) {
      return new THREE.Vector3(
        x,
        x * x - z * z,
        z
      );
    }

    // ğŸ”· Elipsoid
    function ellipsoid3D(theta, phi, rx = 4, ry = 2, rz = 1.5) {
      return new THREE.Vector3(
        rx * Math.sin(theta) * Math.cos(phi),
        ry * Math.sin(theta) * Math.sin(phi),
        rz * Math.cos(theta)
      );
    }
    // ğŸ”¶ Máº·t Parabol 3D
    function paraboloid3D(x, z, a = 0.5) {
      return new THREE.Vector3(
        x,
        a * (x * x + z * z),
        z
      );
    }
    // ğŸ”¶ Máº·t sÃ³ng Sin-Cos 3D
    function sincosWave3D(x, z, a = 1) {
      return new THREE.Vector3(
        x,
        a * Math.sin(x) * Math.cos(z),
        z
      );
    }
    // ğŸ”¶ Mobius Strip (Dáº£i Mobius)
    function mobius3D(u, v, R = 2) {
      const halfV = v / 2;
      return new THREE.Vector3(
        Math.cos(u) * (R + halfV * Math.cos(u / 2)),
        Math.sin(u) * (R + halfV * Math.cos(u / 2)),
        halfV * Math.sin(u / 2)
      );
    }
    // ğŸ”¶ HÃ¬nh ChÃ³p Xoay (Cone)
    function cone3D(theta, h, r = 1) {
      return new THREE.Vector3(
        r * (1 - h) * Math.cos(theta),
        h,
        r * (1 - h) * Math.sin(theta)
      );
    }
    // ğŸ”¶ Cycloid 3D
    function cycloid3D(t, r = 1) {
      return new THREE.Vector3(
        r * (t - Math.sin(t)),
        0,
        r * (1 - Math.cos(t))
      );
    }

    // ğŸ¯ Táº¡o cÃ¡c Ä‘á»‘i tÆ°á»£ng hÃ¬nh há»c
    const heart = new THREE.LineLoop(
      new THREE.BufferGeometry().setFromPoints(createParametricPoints(heart3D, [0, Math.PI * 2], 500)),
      new THREE.LineBasicMaterial({ color: 0xff66cc })
    );

    const sphere = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(sphere3D, [0, Math.PI], [0, Math.PI * 2], 30)),
      new THREE.LineBasicMaterial({ color: 0x66ccff })
    );

    const torus = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(torus3D, [0, Math.PI * 2], [0, Math.PI * 2], 50)),
      new THREE.LineBasicMaterial({ color: 0xffcc00 })
    );

    const spiral = new THREE.LineLoop(
      new THREE.BufferGeometry().setFromPoints(createParametricPoints(spiral3D, [0, 10 * Math.PI], 1000)),
      new THREE.LineBasicMaterial({ color: 0x00ff99 })
    );

    const wave = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(wave3D, [-5, 5], [-5, 5], 50)),
      new THREE.LineBasicMaterial({ color: 0x3366ff })
    );

    const saddle = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(saddle3D, [-3, 3], [-3, 3], 50)),
      new THREE.LineBasicMaterial({ color: 0xff6666 })
    );

    const ellipsoid = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(ellipsoid3D, [0, Math.PI], [0, Math.PI * 2], 30)),
      new THREE.LineBasicMaterial({ color: 0x00ccff })
    );
    // ğŸ”¶ Máº·t Parabol 3D
    const paraboloid = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(paraboloid3D, [-3, 3], [-3, 3], 50)),
      new THREE.LineBasicMaterial({ color: 0xcc00cc })
    );

    // ğŸ”¶ SÃ³ng Sin-Cos 3D
    const sincosWave = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(sincosWave3D, [-5, 5], [-5, 5], 50)),
      new THREE.LineBasicMaterial({ color: 0x00cccc })
    );

    // ğŸ”¶ Dáº£i Mobius
    const mobius = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(mobius3D, [0, Math.PI * 2], [-1, 1], 100)),
      new THREE.LineBasicMaterial({ color: 0xff9966 })
    );

    // ğŸ”¶ HÃ¬nh ChÃ³p Xoay (Cone)
    const cone = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints(createParametricSegments(cone3D, [0, Math.PI * 2], [0, 1], 50)),
      new THREE.LineBasicMaterial({ color: 0x9999ff })
    );

    // ğŸ”¶ Cycloid 3D
    const cycloid = new THREE.LineLoop(
      new THREE.BufferGeometry().setFromPoints(createParametricPoints(cycloid3D, [0, 4 * Math.PI], 300)),
      new THREE.LineBasicMaterial({ color: 0xffcc99 })
    );

    // âœ… Danh sÃ¡ch Ä‘á»‘i tÆ°á»£ng Ä‘á»ƒ xá»­ lÃ½ chung
    const allObjects = [heart, sphere, torus, spiral, wave, saddle, ellipsoid, paraboloid, sincosWave, mobius, cone, cycloid];

    // âœ… áº¨n táº¥t cáº£ khi táº£i trang vÃ  thÃªm vÃ o scene
    allObjects.forEach(obj => {
      obj.visible = false;
      scene.add(obj);
    });

    // Toggle visibility
    function toggle(...objects) {
      objects.forEach(obj => {
        if (obj) obj.visible = !obj.visible;
      });
    }

    // Váº½ Ä‘á»“ thá»‹ máº·t
    let surfaceMesh;
    let currentLabel;
    let formulaLabel; // thÃªm dÃ²ng nÃ y


    function plotSurface() {
      let formulaRaw = document.getElementById("inputFormula").value
        .toLowerCase()
        .replace(/âˆ’/g, '-')    // dáº¥u trá»« unicode
        .replace(/Ã—/g, '*')    // dáº¥u nhÃ¢n unicode
        .replace(/Ã·/g, '/')    // dáº¥u chia unicode
        .replace(/\s+/g, '');  // xoÃ¡ khoáº£ng tráº¯ng
      const mode = document.getElementById("mode").value;
      const resolution = parseInt(document.getElementById("resolution").value);
      const lightMode = document.getElementById("lightMode").value;

      const xMin = parseFloat(document.getElementById("xMin").value);
      const xMax = parseFloat(document.getElementById("xMax").value);
      const yMin = parseFloat(document.getElementById("yMin").value);
      const yMax = parseFloat(document.getElementById("yMax").value);

      let depVar = null;
      const vars = ['x', 'y', 'z'];
      let indepVars = [];

      for (let v of vars) {
        if (formulaRaw.startsWith(v + '=')) {
          depVar = v;
          indepVars = vars.filter(w => w !== v);
          break;
        }
      }

      if (!depVar) {
        alert('â— Vui lÃ²ng nháº­p cÃ´ng thá»©c dÆ°á»›i dáº¡ng: z = f(x, y)');
        return;
      }

      const exprBody = formulaRaw.split('=')[1];
      let expr;
      try {
        expr = math.compile(exprBody);
      } catch (e) {
        alert('Lá»—i cÃ´ng thá»©c: ' + e.message);
        return;
      }

      if (surfaceMesh) scene.remove(surfaceMesh);

      const geometry = new THREE.BufferGeometry();
      const stepX = (xMax - xMin) / resolution;
      const stepY = (yMax - yMin) / resolution;
      const countX = resolution + 1;
      const countY = resolution + 1;
      const points = [];

      for (let i = 0; i <= resolution; i++) {
        const u = xMin + i * stepX;
        for (let j = 0; j <= resolution; j++) {
          const v = yMin + j * stepY;
          let x = 0, y = 0, z = 0;
          const varsObj = {};
          varsObj[indepVars[0]] = u;
          varsObj[indepVars[1]] = v;
          try {
            const result = expr.evaluate(varsObj);
            if (depVar === 'x') {
              x = result; y = u; z = v;
            } else if (depVar === 'y') {
              x = u; y = result; z = v;
            } else {
              x = u; y = v; z = result;
            }
          } catch (e) {
            x = y = z = NaN;
          }
          points.push(x, y, z);
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
      // === TÃNH TOÃN UV MAPPING (Ã¡p dá»¥ng Ã¡nh xáº¡ pháº³ng tá»« x,y) ===
      const uv = [];
      for (let i = 0; i <= resolution; i++) {
        const u = xMin + i * stepX;
        for (let j = 0; j <= resolution; j++) {
          const v = yMin + j * stepY;

          // ÄÆ°a x vÃ  y vá» khoáº£ng [0,1]
          const uCoord = (u - xMin) / (xMax - xMin);
          const vCoord = (v - yMin) / (yMax - yMin); // KhÃ´ng Ä‘áº£o trá»¥c Y

          uv.push(uCoord, vCoord);
        }
      }
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));

      if (mode === 'surface') {
        const indices = [];
        for (let i = 0; i < countX - 1; i++) {
          for (let j = 0; j < countY - 1; j++) {
            const a = i * countY + j;
            const b = a + 1;
            const c = a + countY;
            const d = c + 1;
            indices.push(a, b, d, a, d, c);
          }
        }
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        let material;
        if (lightMode === 'wireframe') {
          material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
        } else {
          const texLoader = new THREE.TextureLoader();
          const texture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
          material = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            map: texture,
            metalness: 0.5,
            roughness: lightMode === 'soft' ? 0.9 : 0.3,
            flatShading: lightMode === 'strong',
            side: THREE.DoubleSide,
          });
        }
        surfaceMesh = new THREE.Mesh(geometry, material);
      } else {
        const group = new THREE.Group();
        for (let i = 0; i < countX; i++) {
          const linePoints = [];
          for (let j = 0; j < countY; j++) {
            const idx = i * countY + j;
            linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
          }
          const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
          group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffff00 })));
        }
        for (let j = 0; j < countY; j++) {
          const linePoints = [];
          for (let i = 0; i < countX; i++) {
            const idx = i * countY + j;
            linePoints.push(new THREE.Vector3(points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]));
          }
          const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
          group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffaa00 })));
        }
        surfaceMesh = group;
      }
      scene.add(surfaceMesh);
      if (formulaLabel) scene.remove(formulaLabel); // XoÃ¡ label cÅ© náº¿u cÃ³
      formulaLabel = createFormulaLabel(formulaRaw, new THREE.Vector3(0, 0, 0));
      scene.add(formulaLabel);



      addToHistory(`Bá» máº·t: ${formulaRaw}`, surfaceMesh);

    }

    function plotPrimitive() {
      const choice = document.getElementById("primitiveShape").value;
      let mesh;
      const material = new THREE.MeshStandardMaterial({ color: 0x33ffff });

      switch (choice) {
        case 'cube':
          mesh = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), material);
          break;
        case 'sphere':
          mesh = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), material);
          break;
        case 'cylinder':
          mesh = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 15, 32), material);
          break;
        case 'cone':
          mesh = new THREE.Mesh(new THREE.ConeGeometry(5, 15, 32), material);
          break;
        case 'circle':
          mesh = new THREE.Mesh(new THREE.CircleGeometry(8, 32), material);
          break;
        case 'ellipse':
          const ellipse = new THREE.Shape();
          ellipse.absellipse(0, 0, 8, 4, 0, Math.PI * 2, false, 0);
          const ellipseGeom = new THREE.ShapeGeometry(ellipse);
          mesh = new THREE.Mesh(ellipseGeom, material);
          break;
        case 'triangle':
          const triShape = new THREE.Shape();
          triShape.moveTo(0, 10);
          triShape.lineTo(-8.66, -5);
          triShape.lineTo(8.66, -5);
          triShape.lineTo(0, 10);
          const triGeom = new THREE.ShapeGeometry(triShape);
          mesh = new THREE.Mesh(triGeom, material);
          break;
        case 'pentagon':
          mesh = polygonMesh(5, 6, material);
          break;
        case 'hexagon':
          mesh = polygonMesh(6, 6, material);
          break;
        case 'pyramid':
          const geom = new THREE.ConeGeometry(7, 10, 4);
          mesh = new THREE.Mesh(geom, material);
          break;
        case 'plane':
          mesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), material);
          break;
        default:
          alert("HÃ£y chá»n khá»‘i hÃ¬nh.");
          return;
      }

      mesh.position.set(Math.random() * 20 - 10, Math.random() * 20 - 10, Math.random() * 20 - 10);
      scene.add(mesh);

    }

    let customCurve; // lÆ°u Ä‘Æ°á»ng cÅ© Ä‘á»ƒ xÃ³a trÆ°á»›c khi váº½ má»›i

    function plotCustom3D() {
      const tMin = parseFloat(document.getElementById("tMin").value);
      const tMax = parseFloat(document.getElementById("tMax").value);
      const res = parseInt(document.getElementById("tRes").value);

      const rawX = document.getElementById("customX").value.trim().toLowerCase();
      const rawY = document.getElementById("customY").value.trim().toLowerCase();
      const rawZ = document.getElementById("customZ").value.trim().toLowerCase();

      if (!rawX.startsWith("x = ") || !rawY.startsWith("y = ") || !rawZ.startsWith("z = ")) {
        alert("Vui lÃ²ng nháº­p Ä‘Ãºng Ä‘á»‹nh dáº¡ng: x = ..., y = ..., z = ...");
        return;
      }

      const xExpr = rawX.split("=")[1];
      const yExpr = rawY.split("=")[1];
      const zExpr = rawZ.split("=")[1];

      let fx, fy, fz;
      try {
        fx = math.compile(xExpr);
        fy = math.compile(yExpr);
        fz = math.compile(zExpr);
      } catch (e) {
        alert("Lá»—i trong cÃ´ng thá»©c: " + e.message);
        return;
      }

      // XoÃ¡ Ä‘Æ°á»ng cong cÅ© náº¿u cÃ³
      if (customCurve) scene.remove(customCurve);

      const points = [];
      for (let i = 0; i <= res; i++) {
        const t = tMin + ((tMax - tMin) * i / res);

        const context = {
          t: t,
          theta: t,
          u: t,
          v: t
        };

        try {
          const x = fx.evaluate(context);
          const y = fy.evaluate(context);
          const z = fz.evaluate(context);

          if (isFinite(x) && isFinite(y) && isFinite(z)) {
            points.push(new THREE.Vector3(x, y, z));
          }
        } catch (e) {
          console.warn("Lá»—i khi Ä‘Ã¡nh giÃ¡ táº¡i t =", t, ":", e.message);
        }
      }

      if (points.length < 2) {
        alert("KhÃ´ng Ä‘á»§ Ä‘iá»ƒm há»£p lá»‡ Ä‘á»ƒ váº½ Ä‘Æ°á»ng.");
        return;
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0xff44aa });
      customCurve = new THREE.Line(geometry, material);
      scene.add(customCurve);
      addToHistory(`TÃ¹y chá»‰nh 3D`, customCurve);

    }

    // HÃ m há»— trá»£ táº¡o Ä‘a giÃ¡c 2D Ä‘á»u (pentagon, hexagon,...)
    function polygonMesh(sides, radius, material) {
      const shape = new THREE.Shape();
      for (let i = 0; i <= sides; i++) {
        const angle = (i / sides) * Math.PI * 2;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        if (i === 0) shape.moveTo(x, y);
        else shape.lineTo(x, y);
      }
      const geometry = new THREE.ShapeGeometry(shape);
      return new THREE.Mesh(geometry, material);
    }


    // Váº½ Ä‘á»“ thá»‹ cá»±c
    function plotPolar() {
      const formula = document.getElementById("polarFormula").value;
      const expr = math.compile(formula);
      const points = [];

      for (let i = 0; i <= 1000; i++) {
        const theta = (i / 1000) * Math.PI * 2;
        let r = 0;
        try { r = expr.evaluate({ theta }); } catch (e) { }
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        points.push(new THREE.Vector3(x, 0, y));
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const polarCurve = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff9933 }));
      scene.add(polarCurve);
      addToHistory(`Äá»“ thá»‹ cá»±c: ${formula}`, polarCurve);

    }



    let planeEquations = [];

    function drawAllPlanes() {
      planeEquations = []; // reset danh sÃ¡ch
      const planes = document.querySelectorAll('#planeList > div');
      const select1 = document.getElementById('plane1Select');
      const select2 = document.getElementById('plane2Select');
      select1.innerHTML = "";
      select2.innerHTML = "";

      planes.forEach((div, index) => {
        const inputs = div.querySelectorAll('input');
        const a = parseFloat(inputs[0].value);
        const b = parseFloat(inputs[1].value);
        const c = parseFloat(inputs[2].value);
        const d = parseFloat(inputs[3].value);
        planeEquations.push({ a, b, c, d });

        // render máº·t pháº³ng
        drawPlaneFromParams(a, b, c, d);

        // update dropdown
        const option = `<option value="${index}">Máº·t ${index + 1}</option>`;
        select1.innerHTML += option;
        select2.innerHTML += option;
      });
    }
    function intersectPlanes(p1, p2) {
      const n1 = new THREE.Vector3(p1.a, p1.b, p1.c);
      const n2 = new THREE.Vector3(p2.a, p2.b, p2.c);
      const dir = new THREE.Vector3().crossVectors(n1, n2);

      if (dir.length() < 1e-6) {
        alert("âš ï¸ Hai máº·t pháº³ng song song hoáº·c trÃ¹ng nhau (khÃ´ng cÃ³ giao tuyáº¿n)");
        return;
      }

      const A = new THREE.Matrix3();
      A.set(
        p1.a, p1.b, p1.c,
        p2.a, p2.b, p2.c,
        dir.x, dir.y, dir.z
      );

      const D = new THREE.Vector3(-p1.d, -p2.d, 0);
      const Ainv = A.clone().invert();

      if (!Ainv) {
        alert("âš ï¸ KhÃ´ng tÃ¬m Ä‘Æ°á»£c Ä‘iá»ƒm giao");
        return;
      }

      const point = D.applyMatrix3(Ainv);

      const points = [];
      for (let t = -50; t <= 50; t += 1) {
        const pt = point.clone().add(dir.clone().normalize().multiplyScalar(t));
        points.push(pt);
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
      const line = new THREE.Line(geometry, material);
      scene.add(line);
    }
    function drawIntersection() {
      const i1 = parseInt(document.getElementById('plane1Select').value);
      const i2 = parseInt(document.getElementById('plane2Select').value);

      if (isNaN(i1) || isNaN(i2) || i1 === i2) {
        alert("âš ï¸ Vui lÃ²ng chá»n hai máº·t pháº³ng khÃ¡c nhau");
        return;
      }

      const p1 = planeEquations[i1];
      const p2 = planeEquations[i2];

      intersectPlanes(p1, p2);
    }

    function drawLine3D() {
      const xExpr = document.getElementById('x0').value;
      const yExpr = document.getElementById('y0').value;
      const zExpr = document.getElementById('z0').value;

      const tMin = -10, tMax = 10, steps = 100;
      const points = [];

      for (let i = 0; i <= steps; i++) {
        const t = tMin + (tMax - tMin) * i / steps;
        const x = math.evaluate(xExpr, { t });
        const y = math.evaluate(yExpr, { t });
        const z = math.evaluate(zExpr, { t });
        points.push(new THREE.Vector3(x, y, z));
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      const line = new THREE.Line(geometry, material);

      scene.add(line);
    }
    function addPlaneInput() {
      const planeList = document.getElementById('planeList');
      const div = document.createElement('div');
      div.className = "flex space-x-1";
      div.innerHTML = `
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="a">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="b">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="c">
      <input type="number" class="text-black w-12 px-1 py-1 rounded" placeholder="d">
      <button onclick="this.parentElement.remove()" class="text-red-400">âœ–ï¸</button>
    `;
      planeList.appendChild(div);
    }



    function drawPlaneFromParams(a, b, c, d) {
      const geometry = new THREE.PlaneGeometry(100, 100);
      const normal = new THREE.Vector3(a, b, c).normalize();
      const center = normal.clone().multiplyScalar(-d / normal.lengthSq());

      const material = new THREE.MeshStandardMaterial({
        color: Math.random() * 0xffffff,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.4
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(center);
      mesh.lookAt(center.clone().add(normal));
      scene.add(mesh);
    }


    const historyList = document.getElementById('historyList');

    function addToHistory(label, object3D) {
      const li = document.createElement('li');
      li.classList.add('flex', 'justify-between', 'items-center');

      const span = document.createElement('span');
      span.textContent = label;
      span.classList.add('cursor-pointer', 'hover:text-yellow-300', 'truncate');

      let visible = true;
      span.addEventListener('click', () => {
        visible = !visible;
        object3D.visible = visible;
        span.style.textDecoration = visible ? 'none' : 'line-through';
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'ğŸ—‘';
      deleteBtn.classList.add('ml-2', 'hover:text-red-500');
      deleteBtn.addEventListener('click', () => {
        scene.remove(object3D);      // XoÃ¡ khá»i scene
        li.remove();                // XoÃ¡ khá»i giao diá»‡n lá»‹ch sá»­
      });

      li.appendChild(span);
      li.appendChild(deleteBtn);
      historyList.appendChild(li);
    }

    function updateLightMode() {
      const mode = document.getElementById("lightMode").value;
      const materialType = document.getElementById("materialType").value;
      const textureInput = document.getElementById("textureImage");
      const textureLabel = document.getElementById("textureLabel");

      if (!surfaceMesh) return;

      let newMaterial;

      // áº¨n/hiá»‡n pháº§n chá»n áº£nh
      if (materialType === 'texture') {
        textureInput.classList.remove("hidden");
        textureLabel.classList.remove("hidden");
      } else {
        textureInput.classList.add("hidden");
        textureLabel.classList.add("hidden");
      }

      const texLoader = new THREE.TextureLoader();

      switch (materialType) {
        case 'phong':
          newMaterial = new THREE.MeshPhongMaterial({
            color: 0xffaa00,
            shininess: 100,
            side: THREE.DoubleSide
          });
          break;
        case 'lambert':
          newMaterial = new THREE.MeshLambertMaterial({
            color: 0x99ccff,
            side: THREE.DoubleSide
          });
          break;
        case 'toon':
          newMaterial = new THREE.MeshToonMaterial({
            color: 0xff99cc,
            gradientMap: null,
            side: THREE.DoubleSide
          });
          break;
        case 'texture':
          if (textureInput.files && textureInput.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const img = new Image();
              img.onload = function () {
                const texture = new THREE.Texture(img);
                texture.needsUpdate = true;

                const texturedMat = new THREE.MeshStandardMaterial({
                  map: texture,
                  metalness: 0.2,
                  roughness: mode === 'soft' ? 0.9 : 0.3,
                  flatShading: mode === 'strong',
                  side: THREE.DoubleSide
                });

                applyMaterial(texturedMat); // Ãp dá»¥ng texture lÃªn surfaceMesh
              };
              img.src = e.target.result;
            };
            reader.readAsDataURL(textureInput.files[0]);
            return; // âš ï¸ QUAN TRá»ŒNG! TrÃ¡nh cháº¡y tiáº¿p cÃ¡c lá»‡nh sau
          } else {
            alert("Vui lÃ²ng chá»n áº£nh.");
            return;
          }

          break;
        case 'standard':
        default:
          const baseTexture = texLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
          newMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            map: baseTexture,
            metalness: 0.5,
            roughness: mode === 'soft' ? 0.9 : 0.3,
            flatShading: mode === 'strong',
            side: THREE.DoubleSide
          });
      }

      // Wireframe override
      if (mode === 'wireframe') {
        newMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          wireframe: true
        });
      }

      applyMaterial(newMaterial);
    }

    function applyMaterial(material) {
      if (surfaceMesh instanceof THREE.Mesh) {
        surfaceMesh.material.dispose();
        surfaceMesh.material = material;
      }
    }
    // TÃ­nh tÃ­ch phÃ¢n 1D vÃ  váº½
    function computeIntegral1D() {
      const formula = document.getElementById("integralFormula1D").value.replace(/^f\(x\)\s*=\s*/, '');
      const a = math.evaluate(document.getElementById("a1D").value); // Há»— trá»£ Ï€, e, sqrt()
      const b = math.evaluate(document.getElementById("b1D").value);
      const steps = parseInt(document.getElementById("integralSteps").value);
      const method = document.getElementById("integralMethod").value;

      const showSteps = document.getElementById("showIntegralSteps").checked;
      const expr = math.compile(formula);

      let area = 0;
      const dx = (b - a) / steps;
      const xVals = [], yVals = [], barData = [];
      let stepsHTML = `<table class="w-full table-auto border-collapse"><thead><tr class="border-b"><th>x</th><th>f(x)</th><th>f(x)Â·dx</th></tr></thead><tbody>`;

      if (method === "midpoint") {
        for (let i = 0; i < steps; i++) {
          const x = a + (i + 0.5) * dx;
          const y = expr.evaluate({ x });
          const slice = y * dx;
          area += slice;
          xVals.push(x);
          yVals.push(y);
          barData.push({ x: x, y: y });
          if (showSteps) {
            stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>${slice.toFixed(6)}</td></tr>`;
          }
        }
      } else if (method === "trapezoidal") {
        for (let i = 0; i <= steps; i++) {
          const x = a + i * dx;
          const y = expr.evaluate({ x });
          xVals.push(x);
          yVals.push(y);
          barData.push({ x, y });
          if (i === 0 || i === steps) area += y / 2;
          else area += y;
          if (showSteps) {
            stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>-</td></tr>`;
          }
        }
        area *= dx;
      } else if (method === "simpson" && steps % 2 === 0) {
        for (let i = 0; i <= steps; i++) {
          const x = a + i * dx;
          const y = expr.evaluate({ x });
          xVals.push(x);
          yVals.push(y);
          barData.push({ x, y });
          if (i === 0 || i === steps) area += y;
          else if (i % 2 === 0) area += 2 * y;
          else area += 4 * y;
          if (showSteps) {
            stepsHTML += `<tr><td>${x.toFixed(4)}</td><td>${y.toFixed(4)}</td><td>-</td></tr>`;
          }
        }
        area *= dx / 3;
      } else {
        alert("Simpson's Rule requires even number of intervals.");
        return;
      }

      stepsHTML += `</tbody></table>`;
      document.getElementById("resultIntegral1D").innerText =
        `âˆ« f(x) dx tá»« ${a} Ä‘áº¿n ${b} â‰ˆ ${area.toFixed(6)} (phÆ°Æ¡ng phÃ¡p: ${method})`;

      const detailDiv = document.getElementById("integralStepsTable");
      if (showSteps) {
        detailDiv.innerHTML = stepsHTML;
        detailDiv.classList.remove("hidden");
      } else {
        detailDiv.innerHTML = "";
        detailDiv.classList.add("hidden");
      }

      // Váº¼ BIá»‚U Äá»’
      const ctx = document.getElementById("integralGraph1D").getContext("2d");

      if (window.chartIntegral1D) {
        window.chartIntegral1D.destroy(); // TrÃ¡nh lá»—i canvas dÃ¹ng láº¡i
      }

      window.chartIntegral1D = new Chart(ctx, {
        type: "bar", // Biá»ƒu Ä‘á»“ thanh + Ä‘Æ°á»ng
        data: {
          datasets: [
            {
              type: "line",
              label: "f(x)",
              data: xVals.map((x, i) => ({ x: x, y: yVals[i] })),
              borderColor: "blue",
              backgroundColor: "rgba(59,130,246,0.2)",
              tension: 0.3,
              fill: true,
              parsing: false
            },
            {
              type: "bar",
              label: "Diá»‡n tÃ­ch lÃ¡t",
              data: barData,
              backgroundColor: "rgba(34,197,94,0.6)",
              borderWidth: 0,
              parsing: false,
              barThickness: Math.max(1, 300 / steps)
            }
          ]
        },
        options: {
          responsive: true,
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "x" }
            },
            y: {
              title: { display: true, text: "f(x)" }
            }
          },
          plugins: {
            legend: { position: "top" },
          }
        }
      });
    }


    const showSteps = document.getElementById("showIntegralSteps").checked;
    const detailDiv = document.getElementById("integralStepsTable");
    if (showSteps) {
      detailDiv.innerHTML = stepsHTML;
      detailDiv.classList.remove("hidden");
    } else {
      detailDiv.innerHTML = "";
      detailDiv.classList.add("hidden");
    }

    // TÃ­nh tÃ­ch phÃ¢n 2D Ä‘Æ¡n giáº£n báº±ng phÆ°Æ¡ng phÃ¡p hÃ¬nh chá»¯ nháº­t
    function computeIntegral2D() {
      const formula = document.getElementById("integralFormula2D").value.replace(/^f\(x,y\)\s*=\s*/, '');
      const xMin = parseFloat(document.getElementById("a2D").value);
      const xMax = parseFloat(document.getElementById("b2D").value);
      const yMin = parseFloat(document.getElementById("c2D").value);
      const yMax = parseFloat(document.getElementById("d2D").value);
      const selectedMap = document.getElementById("colormapSelect").value;


      const expr = math.compile(formula);

      const stepsX = parseInt(document.getElementById("stepsX").value);
      const stepsY = parseInt(document.getElementById("stepsY").value);

      const dx = (xMax - xMin) / stepsX;
      const dy = (yMax - yMin) / stepsY;

      let sum = 0;
      for (let i = 0; i <= stepsX; i++) {
        const x = xMin + i * dx;
        for (let j = 0; j <= stepsY; j++) {
          const y = yMin + j * dy;
          const val = expr.evaluate({ x, y });
          if (isFinite(val)) sum += val * dx * dy;
        }
      }


      document.getElementById("resultIntegral2D").innerText =
        `âˆ¬ f(x,y) dxdy tá»« (${xMin},${yMin}) Ä‘áº¿n (${xMax},${yMax}) = ${sum.toFixed(6)}`;
      visualizeIntegral2D();

      draw2DHeatmap(formula, xMin, xMax, yMin, yMax, stepsX, stepsY, selectedMap);

    }
    function draw2DHeatmap(formula, xMin, xMax, yMin, yMax, stepsX, stepsY, colormapName = "viridis") {
      const ctx = document.getElementById("integralHeatmap2D")?.getContext("2d");
      if (!ctx) return;

      const expr = math.compile(formula);
      const dx = (xMax - xMin) / stepsX;
      const dy = (yMax - yMin) / stepsY;

      const data = [];
      let zMin = Infinity, zMax = -Infinity;

      for (let i = 0; i < stepsX; i++) {
        const x = xMin + i * dx + dx / 2;
        for (let j = 0; j < stepsY; j++) {
          const y = yMin + j * dy + dy / 2;
          try {
            const z = expr.evaluate({ x, y });
            if (!isFinite(z)) continue;
            data.push({ x, y, v: z });
            zMin = Math.min(zMin, z);
            zMax = Math.max(zMax, z);
          } catch (e) {
            console.warn(`Lá»—i táº¡i (${x},${y}):`, e.message);
          }
        }
      }

      if (window.heatmap2DChart) window.heatmap2DChart.destroy();

      window.heatmap2DChart = new Chart(ctx, {
        type: 'matrix',
        data: {
          datasets: [{
            label: 'f(x,y)',
            data: data,
            backgroundColor(ctx) {
              const point = ctx.dataset?.data?.[ctx.dataIndex];
              if (!point || typeof point.v !== "number") return "rgba(0,0,0,0)";
              const normalized = (point.v - zMin) / (zMax - zMin || 1);
              return getColorFromMap(normalized, colormapName);
            },

            width(ctx) {
              const area = ctx.chart.chartArea;
              if (!area) return 10;
              return area.width / stepsX;
            },
            height(ctx) {
              const area = ctx.chart.chartArea;
              if (!area) return 10;
              return area.height / stepsY;
            }
          }]
        },
        options: {
          maintainAspectRatio: true,
          responsive: true,
          plugins: {
            tooltip: {
              callbacks: {
                title: () => '',
                label: ctx => {
                  const d = ctx.raw;
                  return `x: ${d.x.toFixed(2)}, y: ${d.y.toFixed(2)}, z: ${d.v.toFixed(2)}`;
                }
              }
            },
            legend: { display: false }
          },
          scales: {
            x: {
              type: 'linear',
              min: xMin,
              max: xMax,
              title: { display: true, text: 'x' }
            },
            y: {
              type: 'linear',
              min: yMin,
              max: yMax,
              title: { display: true, text: 'y' }
            }
          }
        }
      });
    }
    document.getElementById("colormapSelect").addEventListener("change", () => {
      computeIntegral2D(); // gá»i láº¡i toÃ n bá»™ hÃ m Ä‘á»ƒ cáº­p nháº­t colormap
    });


    function getColorFromMap(t, mapName = "viridis") {
      t = Math.min(1, Math.max(0, t)); // Ä‘áº£m báº£o t âˆˆ [0,1]

      // CÃ¡c colormap phá»• biáº¿n
      switch (mapName) {
        case 'plasma':
          return plasmaColorMap(t);
        case 'turbo':
          return turboColorMap(t);
        case 'gray':
          const g = Math.floor(255 * t);
          return `rgba(${g},${g},${g},1)`;
        case 'viridis':
        default:
          return viridisColorMap(t);
      }
    }

    // Colormap viridis (giáº£m nháº¹ Ä‘á»ƒ phÃ¹ há»£p)
    function viridisColorMap(t) {
      const r = Math.floor(255 * Math.max(0, Math.min(1, 0.267 + 1.5 * t)));
      const g = Math.floor(255 * Math.max(0, Math.min(1, 0.004 + 2.0 * t)));
      const b = Math.floor(255 * Math.max(0, Math.min(1, 0.329 + 1.2 * t)));
      return `rgba(${r},${g},${b},1)`;
    }

    function plasmaColorMap(t) {
      const r = Math.floor(255 * Math.min(1, Math.max(0, 1.5 * t)));
      const g = Math.floor(255 * Math.abs(Math.sin(t * Math.PI)));
      const b = Math.floor(255 * (1 - t));
      return `rgba(${r},${g},${b},1)`;
    }

    function turboColorMap(t) {
      // https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html
      const r = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.75)))));
      const g = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.5)))));
      const b = Math.floor(255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.25)))));
      return `rgba(${r},${g},${b},1)`;
    }


    function visualizeIntegral2D() {
      const formula = document.getElementById("integralFormula2D").value.replace(/^f\(x,y\)\s*=\s*/, '');
      const xMin = parseFloat(document.getElementById("a2D").value);
      const xMax = parseFloat(document.getElementById("b2D").value);
      const yMin = parseFloat(document.getElementById("c2D").value);
      const yMax = parseFloat(document.getElementById("d2D").value);

      const stepsX = parseInt(document.getElementById("stepsX").value);
      const stepsY = parseInt(document.getElementById("stepsY").value);

      const dx = (xMax - xMin) / stepsX;
      const dy = (yMax - yMin) / stepsY;

      const expr = math.compile(formula);
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const colors = [];
      const color = new THREE.Color();

      for (let i = 0; i < stepsX; i++) {
        for (let j = 0; j < stepsY; j++) {
          const x1 = xMin + i * dx;
          const y1 = yMin + j * dy;
          const x2 = xMin + (i + 1) * dx;
          const y2 = yMin + (j + 1) * dy;

          const z11 = expr.evaluate({ x: x1, y: y1 });
          const z12 = expr.evaluate({ x: x1, y: y2 });
          const z21 = expr.evaluate({ x: x2, y: y1 });
          const z22 = expr.evaluate({ x: x2, y: y2 });

          // 2 máº·t tam giÃ¡c táº¡o hÃ¬nh chá»¯ nháº­t
          vertices.push(x1, y1, 0, x1, y1, z11, x2, y1, z21);
          vertices.push(x1, y1, 0, x2, y1, z21, x2, y1, 0);

          vertices.push(x1, y2, 0, x1, y2, z12, x2, y2, z22);
          vertices.push(x1, y2, 0, x2, y2, z22, x2, y2, 0);

          const avgZ1 = (z11 + z21) / 2;
          const avgZ2 = (z12 + z22) / 2;
          for (let k = 0; k < 6; k++) {
            color.setHSL(0.6 - 0.6 * (avgZ1 / 10), 1.0, 0.5);
            colors.push(color.r, color.g, color.b);
          }
          for (let k = 0; k < 6; k++) {
            color.setHSL(0.6 - 0.6 * (avgZ2 / 10), 1.0, 0.5);
            colors.push(color.r, color.g, color.b);
          }
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.6
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.name = "integralSurface";

      // XÃ³a mesh cÅ© náº¿u cÃ³
      const old = scene.getObjectByName("integralSurface");
      if (old) scene.remove(old);

      scene.add(mesh);
    }


    // Xuáº¥t áº£nh
    function saveImage() {
      renderer.render(scene, camera);
      const link = document.createElement('a');
      link.download = 'screenshot.png';
      link.href = renderer.domElement.toDataURL('image/png');
      link.click();
    }

    // // Auto rotate toggle
    // let autoRotate = true;
    // document.addEventListener('keydown', e => {
    //     if (e.key && e.key.toLowerCase() === 'r') {
    //         autoRotate = !autoRotate;
    //         console.log('Toggled autoRotate:', autoRotate);
    //     }
    // });
    // âœ… Äáº·t biáº¿n nÃ y á»Ÿ Ä‘áº§u file hoáº·c trÆ°á»›c khi dÃ¹ng Ä‘áº¿n
    // let autoRotate = true;

    // // âœ… Hiá»ƒn thá»‹ tráº¡ng thÃ¡i ban Ä‘áº§u (náº¿u cÃ³)
    // const statusEl = document.getElementById('autoRotateStatus');
    // function updateAutoRotateStatus() {
    //     if (statusEl) {
    //         statusEl.textContent = `Auto-Rotate: ${autoRotate ? 'On' : 'Off'}`;
    //     }
    // }

    // // âœ… Báº¯t phÃ­m R Ä‘á»ƒ báº­t/táº¯t cháº¿ Ä‘á»™ xoay tá»± Ä‘á»™ng
    // document.addEventListener('keydown', e => {
    //     if (e.key && e.key.toLowerCase() === 'r') {
    //         autoRotate = !autoRotate;
    //         updateAutoRotateStatus();
    //     }
    // });
    let autoRotate = true;

    const toggleButton = document.getElementById('autoRotateToggle');

    function updateAutoRotateUI() {
      toggleButton.textContent = autoRotate ? 'On' : 'Off';
      toggleButton.classList.toggle('bg-green-600', autoRotate);
      toggleButton.classList.toggle('bg-red-600', !autoRotate);
    }

    toggleButton.addEventListener('click', () => {
      autoRotate = !autoRotate;
      updateAutoRotateUI();
    });

    let formulaVisible = true;
    const formulaToggle = document.getElementById('formulaToggle');

    function updateFormulaToggleUI() {
      formulaToggle.textContent = formulaVisible ? 'On' : 'Off';
      formulaToggle.classList.toggle('bg-green-600', formulaVisible);
      formulaToggle.classList.toggle('bg-red-600', !formulaVisible);

      if (formulaLabel) {
        formulaLabel.visible = formulaVisible;
      }
    }

    formulaToggle.addEventListener('click', () => {
      formulaVisible = !formulaVisible;
      updateFormulaToggleUI();
    });


    function animate() {
      requestAnimationFrame(animate);
      if (autoRotate) scene.rotation.y += 0.001;
      controls.update();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });
    let previousCameraPos = new THREE.Vector3(); // LÆ°u camera cÅ©
    let previousTarget = new THREE.Vector3();    // LÆ°u target cÅ© náº¿u dÃ¹ng controls.target

    function setViewDirection() {
      const view = document.getElementById("viewSelector").value;

      // LÆ°u camera trÆ°á»›c Ä‘Ã³ náº¿u chÆ°a lÆ°u
      if (!previousCameraPos) previousCameraPos = new THREE.Vector3();
      if (!previousTarget) previousTarget = new THREE.Vector3();
      previousCameraPos.copy(camera.position);
      previousTarget.copy(controls.target);

      scene.rotation.set(0, 0, 0);

      switch (view) {
        case 'xy': // NhÃ¬n tá»« trÃªn xuá»‘ng
          camera.position.set(0, 100, 0);
          controls.target.set(0, 0, 0);
          controls.enableRotate = false;
          autoRotate = false;

          if (zAxis) zAxis.visible = false;
          if (zLabel) zLabel.visible = false;
          break;

        case 'yz': // NhÃ¬n tá»« trá»¥c X (trÃ¡i -> pháº£i)
          camera.position.set(100, 0, 0);
          controls.target.set(0, 0, 0);
          controls.enableRotate = false;
          autoRotate = false;

          if (xAxis) xAxis.visible = false;
          if (xLabel) xLabel.visible = false;
          break;

        case 'xz': // NhÃ¬n tá»« trÆ°á»›c (trá»¥c Y lÃªn)
          camera.position.set(0, 0, 100);
          controls.target.set(0, 0, 0);
          controls.enableRotate = false;
          autoRotate = false;

          if (yAxis) yAxis.visible = false;
          if (yLabel) yLabel.visible = false;
          break;

        default: // Trá»Ÿ vá» 3D
          camera.position.copy(previousCameraPos);
          controls.target.copy(previousTarget);
          controls.enableRotate = true;
          autoRotate = true;

          // Hiá»‡n láº¡i cÃ¡c trá»¥c
          if (xAxis) xAxis.visible = true;
          if (yAxis) yAxis.visible = true;
          if (zAxis) zAxis.visible = true;
          if (xLabel) xLabel.visible = true;
          if (yLabel) yLabel.visible = true;
          if (zLabel) zLabel.visible = true;
          break;
      }

      controls.update();
      camera.lookAt(controls.target);
    }

    let points3D = []; // Danh sÃ¡ch cÃ¡c Ä‘iá»ƒm Ä‘Ã£ thÃªm

    function addPoint(pos) {
      // Táº¡o Ä‘iá»ƒm
      const point = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0xff3333 }).clone()
      );
      point.position.copy(pos);
      scene.add(point);

      // Táº¡o nhÃ£n
      const label = createLabel(`(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, pos.clone().add(new THREE.Vector3(1, 1, 0)), '#fff');

      // LÆ°u láº¡i Ä‘á»ƒ quáº£n lÃ½
      points3D.push({ point, label, pos: pos.clone() });

      // Náº¿u cÃ³ Ä‘iá»ƒm trÆ°á»›c Ä‘Ã³ thÃ¬ váº½ vector (mÅ©i tÃªn)
      if (points3D.length >= 2) {
        const from = points3D[points3D.length - 2].pos;
        const to = pos;
        const dir = new THREE.Vector3().subVectors(to, from);
        const arrow = new THREE.ArrowHelper(dir.clone().normalize(), from.clone(), dir.length(), 0xffff00);
        scene.add(arrow);

        // LÆ°u vÃ o lá»‹ch sá»­ (tÃ¹y chá»n)
        addToHistory(`Vector tá»« (${from.x.toFixed(1)}, ${from.y.toFixed(1)}, ${from.z.toFixed(1)}) Ä‘áº¿n (${to.x.toFixed(1)}, ${to.y.toFixed(1)}, ${to.z.toFixed(1)})`, arrow);
      }

      addToHistory(`Äiá»ƒm (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`, point);
    }

    function drawVectorFromInput() {
      const x1 = parseFloat(document.getElementById("x1").value);
      const y1 = parseFloat(document.getElementById("y1").value);
      const z1 = parseFloat(document.getElementById("z1").value);

      const x2 = parseFloat(document.getElementById("x2").value);
      const y2 = parseFloat(document.getElementById("y2").value);
      const z2 = parseFloat(document.getElementById("z2").value);

      if (
        isNaN(x1) || isNaN(y1) || isNaN(z1) ||
        isNaN(x2) || isNaN(y2) || isNaN(z2)
      ) {
        alert("Vui lÃ²ng nháº­p Ä‘áº§y Ä‘á»§ vÃ  há»£p lá»‡ cÃ¡c tá»a Ä‘á»™.");
        return;
      }

      const from = new THREE.Vector3(x1, y1, z1);
      const to = new THREE.Vector3(x2, y2, z2);
      const dir = new THREE.Vector3().subVectors(to, from);
      const length = dir.length();
      const arrow = new THREE.ArrowHelper(dir.clone().normalize(), from, length, 0x00ff00);
      scene.add(arrow);

      // ThÃªm Ä‘iá»ƒm vÃ  nhÃ£n náº¿u muá»‘n lÆ°u
      addPoint(from);
      addPoint(to);

      addToHistory(`Vector tá»« (${x1}, ${y1}, ${z1}) Ä‘áº¿n (${x2}, ${y2}, ${z2})`, arrow);
    }

    //////////////
    // CÃ¡c hÃ m Ä‘Æ°á»£c dÃ¹ng trong HTML cáº§n gÃ¡n vÃ o window
    window.drawVectorFromInput = drawVectorFromInput;
    // window.toggleMiniForm = toggleMiniForm;
    // window.switchTab = switchTab;
    // window.toggleMenu = toggleMenu;
    // window.toggleDiv = toggleDiv;
    window.plotPrimitive = plotPrimitive;
    window.plotSurface = plotSurface;
    window.plot2D = plot2D;
    window.plotPolar = plotPolar;
    window.drawLine3D = drawLine3D;
    window.addPlaneInput = addPlaneInput;
    window.drawAllPlanes = drawAllPlanes;
    window.plotCustom3D = plotCustom3D;
    window.drawIntersection = drawIntersection;
    window.saveImage = saveImage;
    window.updateLightMode = updateLightMode;
    window.toggle = toggle;
    window.gridHelper = gridHelper;
    window.axisGroup = axisGroup;
    window.axisTicksGroup = axisTicksGroup;
    window.sphere = sphere; // náº¿u báº¡n Ä‘áº·t `sphereLine` Ä‘áº¡i diá»‡n cho máº·t cáº§u 3D
    window.heart = heart;
    window.torus = torus;
    window.spiral = spiral;
    window.wave = wave;
    window.saddle = saddle;
    window.ellipsoid = ellipsoid;
    window.paraboloid = paraboloid;
    window.sincosWave = sincosWave;
    window.mobius = mobius;
    window.cone = cone;
    window.cycloid = cycloid;
    window.line = heart;  // náº¿u `line` dÃ¹ng cho Ä‘Æ°á»ng cong tÃ¹y chá»‰nh
    window.setViewDirection = setViewDirection;
    // GÃ¡n vÃ o window Ä‘á»ƒ cÃ³ thá»ƒ dÃ¹ng trong HTML
    //window.xAxis = xAxis;
    //window.yAxis = yAxis;
    //window.zAxis = zAxis;
    window.oLabel = oLabel;
    window.xLabel = xLabel;
    window.yLabel = yLabel;
    window.zLabel = zLabel;
    window.computeIntegral2D = computeIntegral2D;
    window.computeIntegral1D = computeIntegral1D;
  </script>

</body>

</html>
