const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(60, 60, 60);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Label renderer
const labelRenderer = new THREE.CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
labelRenderer.domElement.style.position = "absolute";
labelRenderer.domElement.style.top = "0";
labelRenderer.domElement.style.pointerEvents = "none";
document.body.appendChild(labelRenderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

let gridHelper = new THREE.GridHelper(100, 20);
scene.add(gridHelper);

// Light
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const light = new THREE.PointLight(0xffffff, 1);
light.position.set(50, 50, 100);
scene.add(light);

// H√†m t·∫°o tr·ª•c
let axisGroup = new THREE.Group(); // Nh√≥m ch·ª©a c√°c tr·ª•c
scene.add(axisGroup);

// ----- Hi·ªÉn th·ªã -----
let autoRotate = true;
const displayParams = {
  // Toggle
  autoRotate: true,
  showFormula: true,

  // Tr·ª•c
  axisLength: 50,
  step: 5,
  min: -50,
  max: 50,
  axisColor: "#ffffff",

  // Hi·ªÉn th·ªã
  showAxisLabels: true,
  showAxisTicks: true,

  // Nh√£n tr·ª•c
  labelX: "X",
  labelY: "Y",
  labelZ: "Z",
  viewAngle: "isometric", // g√≥c nh√¨n m·∫∑c ƒë·ªãnh
  gridPlane: "XZ", // m·∫∑t ph·∫≥ng m·∫∑c ƒë·ªãnh
  octant: "all",
  // N√∫t h√†nh ƒë·ªông
  toggleGrid: () => {
    toggle(gridHelper);
  },
  updateAxes: () => {
    updateAxisAllGUI(); // c·∫≠p nh·∫≠t tr·ª•c & ticks
    updateGrid(); // c·∫≠p nh·∫≠t lu√¥n l∆∞·ªõi
  },
};
function createFullAxis(axis = "x", length = 50, color = 0xffffff) {
  const dirMap = {
    x: new THREE.Vector3(1, 0, 0),
    y: new THREE.Vector3(0, 1, 0),
    z: new THREE.Vector3(0, 0, 1),
  };
  const dir = dirMap[axis];
  if (!dir) return;

  const oct = displayParams.octant;

  // V·∫Ω t·ª´ng ƒëo·∫°n nh·ªè ƒë·ªÉ ki·ªÉm tra octant
  const step = 1; // ƒë·ªô ph√¢n m·∫£nh
  for (let i = -length; i < length; i += step) {
    const a = dir.clone().multiplyScalar(i);
    const b = dir.clone().multiplyScalar(i + step);

    if (inOctant(a, oct) && inOctant(b, oct)) {
      const geom = new THREE.BufferGeometry().setFromPoints([a, b]);
      const mat = new THREE.LineBasicMaterial({ color });
      const line = new THREE.Line(geom, mat);
      axisGroup.add(line);
    }
  }

  // V·∫Ω m≈©i t√™n d∆∞∆°ng
  const posP = dir.clone().multiplyScalar(length);
  if (inOctant(posP, oct)) {
    const arrow1 = new THREE.ArrowHelper(dir.clone().normalize(), posP, 3, color, 1, 0.5);
    axisGroup.add(arrow1);
  }

  // V·∫Ω m≈©i t√™n √¢m
  const posN = dir.clone().multiplyScalar(-length);
  if (inOctant(posN, oct)) {
    const arrow2 = new THREE.ArrowHelper(dir.clone().negate().normalize(), posN, 3, color, 1, 0.5);
    axisGroup.add(arrow2);
  }
}


// G·ªçi c√°c tr·ª•c nh∆∞ tr∆∞·ªõc
createFullAxis("x", 50, 0xff0000);
createFullAxis("y", 50, 0x00ff00);
createFullAxis("z", 50, 0x00ffff);

// Labels
// Labels v·ªõi offset
let shapeLabels = [];

function createLabel(text, pos, color = "#000000", offset = new THREE.Vector3(0.1,0.1,0.2)) {
  const div = document.createElement("div");
  div.textContent = text;
  div.style.color = color;
  div.style.fontWeight = "bold";
  div.style.fontSize = "20px";
  div.style.userSelect = "none"; // kh√¥ng ch·ªçn nh√£n
  const label = new THREE.CSS2DObject(div);
  label.position.copy(pos.clone().add(offset)); // ‚úÖ v·ªã tr√≠ + offset
  axisGroup.add(label); // add v√†o group
  shapeLabels.push(label); // ‚úÖ l∆∞u l·∫°i ƒë·ªÉ qu·∫£n l√Ω
  return label;
}

const oLabel = createLabel(".", new THREE.Vector3(0, 0, 0), "white");
const xLabel = createLabel("X", new THREE.Vector3(55, 0, 0), "red");
const yLabel = createLabel("Y", new THREE.Vector3(0, 55, 0), "lime");
const zLabel = createLabel("Z", new THREE.Vector3(0, 0, 55), "cyan");

let axisTicksGroup = new THREE.Group(); // Nh√≥m ƒë·ªÉ d·ªÖ ·∫©n/hi·ªán t·∫•t c·∫£ tick

// D√πng nh√≥m ƒë·ªÉ ch·ª©a t·∫•t c·∫£ ticks
function addAxisTicks(
  axis = "x",
  step = 5,
  min = -50,
  max = 50,
  color = "white"
) {
  const dirVectors = {
    x: {
      from: (i) => [
        new THREE.Vector3(i, -0.5, 0),
        new THREE.Vector3(i, 0.5, 0),
      ],
      pos: (i) => new THREE.Vector3(i, 0, 0),
    },
    y: {
      from: (i) => [
        new THREE.Vector3(-0.5, i, 0),
        new THREE.Vector3(0.5, i, 0),
      ],
      pos: (i) => new THREE.Vector3(0, i, 0),
    },
    z: {
      from: (i) => [
        new THREE.Vector3(0, -0.5, i),
        new THREE.Vector3(0, 0.5, i),
      ],
      pos: (i) => new THREE.Vector3(0, 0, i),
    },
  };

  const data = dirVectors[axis];
  if (!data) return;

  const material = new THREE.LineBasicMaterial({ color });

  for (let i = min; i <= max; i += step) {
      // ‚úÖ ki·ªÉm tra xem tick n√†y c√≥ n·∫±m trong octant ƒë∆∞·ª£c ch·ªçn kh√¥ng
  if (!inOctant(data.pos(i), displayParams.octant)) continue;
    if (i === 0) continue;

    const points = data.from(i);
    const tick = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(points),
      material
    );
    axisTicksGroup.add(tick);

    const label = createLabel(`${i}`, data.pos(i), color);
    axisTicksGroup.add(label);
  }
}
function updateAxisAllGUI() {
  const {
    axisLength,
    axisColor,
    showAxisLabels,
    showAxisTicks,
    step,
    min,
    max,
    labelX,
    labelY,
    labelZ,
    octant,   // üëà l·∫•y th√™m octant
  } = displayParams;

  // clear c≈©
  axisGroup.clear();
  axisTicksGroup.clear();

  const labelMap = { x: labelX, y: labelY, z: labelZ };
  const labelColor = { x: "red", y: "lime", z: "cyan" };

  ["x", "y", "z"].forEach((axis) => {
    // V·∫Ω tr·ª•c
    createFullAxis(axis, axisLength, new THREE.Color(axisColor));

    // ======= Nh√£n tr·ª•c =======
    if (showAxisLabels) {
      const len = axisLength + 5;
      let pos;

      if (octant === "all") {
        // M·∫∑c ƒë·ªãnh ·ªü ph√≠a d∆∞∆°ng
        if (axis === "x") pos = new THREE.Vector3(len, 0, 0);
        if (axis === "y") pos = new THREE.Vector3(0, len, 0);
        if (axis === "z") pos = new THREE.Vector3(0, 0, len);
      } else {
        // L·∫•y d·∫•u t·ª´ octant, v√≠ d·ª• "+-+"
        const [sx, sy, sz] = octant.split("").map(s => s === "+" ? 1 : -1);
        if (axis === "x") pos = new THREE.Vector3(sx * len, 0, 0);
        if (axis === "y") pos = new THREE.Vector3(0, sy * len, 0);
        if (axis === "z") pos = new THREE.Vector3(0, 0, sz * len);
      }

      createLabel(labelMap[axis], pos, labelColor[axis]);
    }

    // ======= Tick tr·ª•c =======
    if (showAxisTicks) {
      addAxisTicks(axis, step, min, max, axisColor);
    }
  });

  // Nh√£n g·ªëc O
  if (showAxisLabels) {
    createLabel(".", new THREE.Vector3(0, 0, 0), "white");
  }
}


// Th√™m ticks 1 l·∫ßn
addAxisTicks("x", 5, -50, 50, "white");
addAxisTicks("y", 5, -50, 50, "white");
addAxisTicks("z", 5, -50, 50, "white");
scene.add(axisTicksGroup);

function createFormulaLabel(text, position = new THREE.Vector3(0, 0, 0)) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = 512;
  canvas.height = 128;

  ctx.fillStyle = "white";
  ctx.font = "bold 32px monospace";
  ctx.fillText(text, 20, 80);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({
    map: texture,
    transparent: true,
  });
  const sprite = new THREE.Sprite(material);

  sprite.scale.set(10, 2.5, 1); // t√πy ch·ªânh k√≠ch th∆∞·ªõc
  sprite.position.copy(position.clone().add(new THREE.Vector3(0, 5, 0))); // ƒë·∫∑t ph√≠a tr√™n ƒë·ªì th·ªã

  return sprite;
}
let worldGroup = new THREE.Group();
scene.add(worldGroup);

// ƒê∆∞a c√°c ph·∫ßn hi·ªÉn th·ªã v√†o worldGroup
worldGroup.add(axisGroup);
worldGroup.add(axisTicksGroup);
worldGroup.add(gridHelper);


// T·∫°o tab GUI
const guiHelper = new GuiHelperTabs();
const guiDisplay = guiHelper.addTab("Hi·ªÉn th·ªã", 350, {
  icon: "üñ•Ô∏è",
  label: "Hi·ªÉn th·ªã",
});

  guiDisplay.add(displayParams, "viewAngle", {
    "üîº Top": "top",
    "‚û°Ô∏è Right": "right",
    "‚¨ÖÔ∏è Front": "front",
    "üü™ Isometric": "isometric",
    "‚è∫ Custom": "custom",
  }).name("üëÅÔ∏è G√≥c nh√¨n");
  guiDisplay.add(displayParams, "gridPlane", {
    "XY": "XY",
    "XZ": "XZ",
    "YZ": "YZ",
  }).name("üìä M·∫∑t ph·∫≥ng l∆∞·ªõi").onChange(updateGrid);

guiDisplay.add(displayParams, "octant", {
  "To√†n b·ªô": "all",
  "+++ (X>0,Y>0,Z>0)": "+++",
  "++- (X>0,Y>0,Z<0)": "++-",
  "+-+ (X>0,Y<0,Z>0)": "+-+",
  "+-- (X>0,Y<0,Z<0)": "+--",
  "-++ (X<0,Y>0,Z>0)": "-++",
  "-+- (X<0,Y>0,Z<0)": "-+-",
  "--+ (X<0,Y<0,Z>0)": "--+",
  "--- (X<0,Y<0,Z<0)": "---",
}).name("üß≠ Octant").onChange(() => {
  updateAxisAllGUI();
  updateGrid();

  // üëÅÔ∏è ƒê·∫∑t l·∫°i camera nh√¨n th·∫•y 3 tr·ª•c
  camera.position.set(60, 60, 60);
  controls.target.set(0, 0, 0);
  controls.update();
});

function inOctant(v, octant) {
  if (octant === "all") return true;
  const [sx, sy, sz] = octant.split("").map(s => s === "+" ? 1 : -1);
  return (Math.sign(v.x) === sx || v.x === 0) &&
         (Math.sign(v.y) === sy || v.y === 0) &&
         (Math.sign(v.z) === sz || v.z === 0);
}

// H√†m ti·ªán √≠ch t·∫°o folder c·∫•u h√¨nh tr·ª•c + ticks
function addAxisAndTicksFolder(gui, params) {
  const folder = guiHelper.addFolderWithTooltip(
    gui,
    "‚öôÔ∏è C·∫•u h√¨nh tr·ª•c & ticks",
    "",
    "Thi·∫øt l·∫≠p ƒë·ªô d√†i, m√†u s·∫Øc, nh√£n tr·ª•c v√† b∆∞·ªõc nh·∫£y cho ticks"
  );

  // --- C·∫•u h√¨nh tr·ª•c ---
  folder.add(params, "axisLength", 10, 200, 1).name("ƒê·ªô d√†i tr·ª•c");
  folder.domElement.classList.add("axis-folder");
  folder.addColor(params, "axisColor").name("M√†u tr·ª•c");
  folder.add(params, "labelX").name("Nh√£n X");
  folder.add(params, "labelY").name("Nh√£n Y");
  folder.add(params, "labelZ").name("Nh√£n Z");

  // --- C·∫•u h√¨nh ticks ---
  folder.add(params, "step", 1, 20, 1).name("B∆∞·ªõc");
  folder.add(params, "min", -100, 0, 1).name("Min");
  folder.add(params, "max", 0, 100, 1).name("Max");

  // Checkbox d√πng addWithIcon
  guiHelper.addWithIcon(folder, displayParams, "showAxisLabels", "üî§", {
    label: "Hi·ªÉn th·ªã nh√£n tr·ª•c",
    columns: 2  // hi·ªÉn th·ªã 2 c·ªôt
  });
  
  guiHelper.addWithIcon(folder, displayParams, "showAxisTicks", "üìè", {
    label: "Hi·ªÉn th·ªã ticks tr√™n tr·ª•c",
    columns: 2
  });
  

  // N√∫t c·∫≠p nh·∫≠t tr·ª•c
  folder.add(params, "updateAxes").name("üîÑ C·∫≠p nh·∫≠t Tr·ª•c & Ticks");

  return folder;
}

// G·ªçi h√†m
const fAxisTicks = addAxisAndTicksFolder(guiDisplay, displayParams);

// --- N√∫t h√†nh ƒë·ªông ---
const fActions = guiHelper.addFolderWithTooltip(
  guiDisplay,
  "‚ö° H√†nh ƒë·ªông",
  "",
  "C√°c n√∫t th·ª±c hi·ªán thao t√°c nhanh nh∆∞ b·∫≠t/t·∫Øt l∆∞·ªõi ho·∫∑c c·∫≠p nh·∫≠t tr·ª•c"
);

// Th√™m c√°c n√∫t v√†o folder n√†y
fActions.add(displayParams, "toggleGrid").name("üü© B·∫≠t/T·∫Øt L∆∞·ªõi");
// --- Toggle ---
guiHelper.addWithIcon(fActions, displayParams, "autoRotate", "üîÑ", {
  label: "Auto-Rotate",
  columns: 2,
  onChange: (v) => { autoRotate = v; }
});

guiHelper.addWithIcon(fActions, displayParams, "showFormula", "üìñ", {
  label: "Hi·ªÉn th·ªã c√¥ng th·ª©c",
  columns: 2,
  onChange: (v) => { 
    formulaVisible = v; 
    if (formulaLabel) formulaLabel.visible = v;
  }
});

function updateGrid() {
  // X√≥a l∆∞·ªõi c≈©
  if (gridHelper) {
    worldGroup.remove(gridHelper);
    gridHelper.geometry.dispose();
    gridHelper.material.dispose();
  }

  const { min, max, step, gridPlane, axisColor, octant } = displayParams;
  const vertices = [];

  let dir1, dir2;
  switch (gridPlane) {
    case "XY": dir1 = "x"; dir2 = "y"; break;
    case "YZ": dir1 = "y"; dir2 = "z"; break;
    case "XZ": default: dir1 = "x"; dir2 = "z"; break;
  }

  const segment = 1; // chia nh·ªè ƒë·ªÉ ki·ªÉm tra

  for (let i = min; i <= max; i += step) {
    // line song song tr·ª•c dir1
    for (let j = min; j < max; j += segment) {
      const a1 = new THREE.Vector3();
      const b1 = new THREE.Vector3();
      a1[dir1] = j; a1[dir2] = i;
      b1[dir1] = j + segment; b1[dir2] = i;

      if (inOctant(a1, octant) && inOctant(b1, octant)) {
        vertices.push(...a1.toArray(), ...b1.toArray());
      }
    }

    // line song song tr·ª•c dir2
    for (let j = min; j < max; j += segment) {
      const a2 = new THREE.Vector3();
      const b2 = new THREE.Vector3();
      a2[dir1] = i; a2[dir2] = j;
      b2[dir1] = i; b2[dir2] = j + segment;

      if (inOctant(a2, octant) && inOctant(b2, octant)) {
        vertices.push(...a2.toArray(), ...b2.toArray());
      }
    }
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
  const mat = new THREE.LineBasicMaterial({ color: axisColor, opacity: 0.3, transparent: true });
  gridHelper = new THREE.LineSegments(geom, mat);

  worldGroup.add(gridHelper);
}

// ----- N√∫t Tr·ª£ gi√∫p -----
displayParams.help = () => {
  alert(
    `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab Hi·ªÉn th·ªã:

üîÑ Auto-Rotate: B·∫≠t/t·∫Øt t·ª± ƒë·ªông xoay to√†n c·∫£nh.
üìñ Hi·ªÉn th·ªã c√¥ng th·ª©c: B·∫≠t/t·∫Øt nh√£n c√¥ng th·ª©c trong kh√¥ng gian.

üìê C·∫•u h√¨nh tr·ª•c:
- ƒê·ªô d√†i tr·ª•c: ƒêi·ªÅu ch·ªânh chi·ªÅu d√†i c√°c tr·ª•c X, Y, Z.
- M√†u tr·ª•c: Ch·ªçn m√†u hi·ªÉn th·ªã cho tr·ª•c.
- Nh√£n X/Y/Z: ƒê·ªïi k√Ω hi·ªáu nh√£n cho t·ª´ng tr·ª•c.

üìè C·∫•u h√¨nh ticks:
- B∆∞·ªõc: Kho·∫£ng c√°ch gi·ªØa c√°c ticks (v·∫°ch chia).
- Min/Max: Gi·ªõi h·∫°n hi·ªÉn th·ªã tr√™n tr·ª•c.
- Hi·ªÉn th·ªã nh√£n: B·∫≠t/t·∫Øt ch·ªØ s·ªë tr√™n ticks.
- Hi·ªÉn th·ªã ticks: B·∫≠t/t·∫Øt v·∫°ch chia tr√™n tr·ª•c.

üü© B·∫≠t/T·∫Øt L∆∞·ªõi: ·∫®n/hi·ªán l∆∞·ªõi n·ªÅn.
üîÑ C·∫≠p nh·∫≠t Tr·ª•c & Ticks: T·∫£i l·∫°i to√†n b·ªô tr·ª•c v√† l∆∞·ªõi theo c·∫•u h√¨nh m·ªõi.
`
  );
};

// Th√™m v√†o GUI
guiDisplay.add(displayParams, "help").name("‚ùì Tr·ª£ gi√∫p");

const sampleParams = {
  primitiveShape: "none",
  motionEffect: "",
  customMotionCode: "",
  shapeType: "box",
  shapeSize: 1,
  shapeHeight: 1,
  shapeColor: "#44ccff",
};

const guiSample = guiHelper.addTab("Kh·ªëi M·∫´u", 340, {
  icon: "üßä",
  label: "Kh·ªëi M·∫´u",
});

guiSample
  .add(sampleParams, "primitiveShape", {
    "Ch·ªçn kh·ªëi 2D/3D": "none",
    "H√¨nh L·∫≠p Ph∆∞∆°ng": "cube",
    "H√¨nh C·∫ßu": "sphere",
    "H√¨nh Tr·ª•": "cylinder",
    "H√¨nh N√≥n": "cone",
    "H√¨nh Tr√≤n 2D": "circle",
    Ellipse: "ellipse",
    "Tam Gi√°c 2D": "triangle",
    "Ng≈© Gi√°c 2D": "pentagon",
    "L·ª•c Gi√°c 2D": "hexagon",
    "H√¨nh Ch√≥p": "pyramid",
    "M·∫∑t Ph·∫≥ng": "plane",
  })
  .name("üé® Ch·ªçn Kh·ªëi 2D/3D");

guiSample
  .add(sampleParams, "motionEffect", {
    "-- Kh√¥ng chuy·ªÉn ƒë·ªông --": "",
    "Quay quanh tr·ª•c Y": "rotateY",
    "Quay quanh tr·ª•c X": "rotateX",
    "N·∫£y l√™n xu·ªëng": "bounce",
    "G·ª£n s√≥ng": "wave",
    "Xoay li√™n t·ª•c": "spin",
    "L·∫Øc ngang": "shake",
    "Tr∆∞·ª£t tr√≤n": "circle",
    "G·ª£n s√≥ng tr·ª•c Z": "waveZ",
    "Tr√¥i n·ªïi": "float",
    Xoay: "rotate",
    "Ph·ªìng l√™n": "pulse",
    "Quay quanh t√¢m": "orbit",
    "Ch·ªõp m√†u": "flashColor",
  })
  .name("üåÄ Hi·ªáu ·ª®ng Chuy·ªÉn ƒê·ªông");

guiSample.add(sampleParams, "customMotionCode").name("Custom Motion (JS)");

const fShape = guiSample.addFolder("üß± T√πy Bi·∫øn Kh·ªëi 3D");
fShape
  .add(sampleParams, "shapeType", {
    Box: "box",
    Sphere: "sphere",
    Cylinder: "cylinder",
  })
  .name("Lo·∫°i Kh·ªëi");
fShape
  .add(sampleParams, "shapeSize", 0.1, 10, 0.1)
  .name("K√≠ch th∆∞·ªõc / B√°n k√≠nh");
fShape.add(sampleParams, "shapeHeight", 0.1, 10, 0.1).name("Chi·ªÅu Cao");
fShape.addColor(sampleParams, "shapeColor").name("M√†u s·∫Øc");
fShape
  .add({ createShape: () => createShape(sampleParams) }, "createShape")
  .name("‚ûï T·∫°o Kh·ªëi");

// Danh s√°ch preset (hi·ªÉn th·ªã trong GUI)
const presetShapes = {
  "‚ö™ Kh·ªëi C·∫ßu": "sphere",
  "‚ù§Ô∏è Tr√°i Tim": "heart",
  "üåÄ H√¨nh Xuy·∫øn": "torus",
  "üîÉ Xo·∫Øn ·ªêc": "spiral",
  "üåä S√≥ng Sin": "wave",
  "üî∫ Y√™n Ng·ª±a": "saddle",
  "üßä Elipsoid": "ellipsoid",
  "üìà Parabol 3D": "paraboloid",
  "üåÄ Sin-Cos Wave": "sincosWave",
  "‚ôæÔ∏è Mobius": "mobius",
  "üîª Cone": "cone",
  "üåÄ Cycloid": "cycloid",
};

// T·∫°o GUI ch·ªçn kh·ªëi
guiSample
  .add({ preset: "sphere" }, "preset", presetShapes)
  .name("üì¶ Kh·ªëi M·∫´u")
  .onChange((val) => {
    if (allObjects[val]) toggle(allObjects[val]);
  });

// ----- N√∫t Tr·ª£ gi√∫p -----
sampleParams.help = () => {
  alert(
    `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab Kh·ªëi M·∫´u:

üé® Ch·ªçn Kh·ªëi 2D/3D:
- Ch·ªçn nhanh c√°c kh·ªëi c∆° b·∫£n nh∆∞ Cube, Sphere, Cylinder, Cone, Circle, Ellipse, Tam gi√°c, Ng≈© gi√°c, L·ª•c gi√°c, Ch√≥p, M·∫∑t ph·∫≥ng.

üåÄ Hi·ªáu ·ª®ng Chuy·ªÉn ƒê·ªông:
- Th√™m chuy·ªÉn ƒë·ªông ƒë·ªông cho kh·ªëi ƒë√£ ch·ªçn.
- V√≠ d·ª•: Quay quanh tr·ª•c, N·∫£y, G·ª£n s√≥ng, L·∫Øc, Quay quanh t√¢m, Ch·ªõp m√†u...

üíª Custom Motion (JS):
- T·ª± vi·∫øt code JavaScript ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông t√πy bi·∫øn cho kh·ªëi.

üß± T√πy Bi·∫øn Kh·ªëi 3D:
- Lo·∫°i Kh·ªëi: Box, Sphere, Cylinder.
- K√≠ch th∆∞·ªõc / B√°n k√≠nh: ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc kh·ªëi.
- Chi·ªÅu cao: ƒêi·ªÅu ch·ªânh ƒë·ªô cao (ƒë·ªëi v·ªõi Cylinder, Box, Cone).
- M√†u s·∫Øc: Ch·ªçn m√†u kh·ªëi.
- ‚ûï T·∫°o Kh·ªëi: Sinh kh·ªëi m·ªõi theo c·∫•u h√¨nh.

üì¶ Kh·ªëi M·∫´u:
- Danh s√°ch c√°c kh·ªëi ƒë·∫∑c bi·ªát (Heart, Torus, Spiral, Mobius, Paraboloid...).
- Ch·ªçn ƒë·ªÉ hi·ªÉn th·ªã/·∫©n c√°c kh·ªëi trong worldGroup.
`
  );
};

// Th√™m n√∫t Tr·ª£ gi√∫p v√†o GUI
guiSample.add(sampleParams, "help").name("‚ùì Tr·ª£ gi√∫p");
function createShape(params) {
  const type = params.shapeType;
  const size = params.shapeSize;
  const height = params.shapeHeight;
  const color = params.shapeColor;

  let geometry;

  switch (type) {
    case "box":
      geometry = new THREE.BoxGeometry(size, height, size);
      break;
    case "sphere":
      geometry = new THREE.SphereGeometry(size, 32, 32);
      break;
    case "cylinder":
      geometry = new THREE.CylinderGeometry(size, size, height, 32);
      break;
    default:
      console.warn("Lo·∫°i kh·ªëi ch∆∞a h·ªó tr·ª£:", type);
      return;
  }

  const material = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);

  // ƒê·∫∑t v·ªã tr√≠ ng·∫´u nhi√™n ƒë·ªÉ d·ªÖ nh√¨n
  mesh.position.set(
    (Math.random() - 0.5) * 5,
    (Math.random() - 0.5) * 5,
    (Math.random() - 0.5) * 5
  );

  worldGroup.add(mesh);
  allObjects.push(mesh); // n·∫øu b·∫°n d√πng ƒë·ªÉ animate
}

// ----- G√≥c nh√¨n -----
const viewParams = {
  view: "default",
  help: () => {
    alert(
      `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab G√≥c Nh√¨n:

üëÅÔ∏è Ch·ªçn G√≥c Nh√¨n:
- 3D T·ª± Do: B·∫°n c√≥ th·ªÉ xoay, k√©o th·∫£ camera ƒë·ªÉ quan s√°t m√¥ h√¨nh t·ª´ m·ªçi g√≥c.
- XY (Tr√™n): Nh√¨n t·ª´ ph√≠a tr√™n xu·ªëng tr·ª•c XY.
- YZ (Tr√°i): Nh√¨n t·ª´ b√™n tr√°i theo tr·ª•c YZ.
- XZ (Tr∆∞·ªõc): Nh√¨n t·ª´ ph√≠a tr∆∞·ªõc theo tr·ª•c XZ.

üëâ D√πng ƒë·ªÉ nhanh ch√≥ng chuy·ªÉn ƒë·ªïi g√≥c camera khi quan s√°t m√¥ h√¨nh.`
    );
  },
};

const guiView = guiHelper.addTab("G√≥c Nh√¨n", 250, {
  icon: "üëÅÔ∏è",
  label: "G√≥c Nh√¨n",
});

guiView
  .add(viewParams, "view", {
    "3D T·ª± Do": "default",
    "XY (Tr√™n)": "xy",
    "YZ (Tr√°i)": "yz",
    "XZ (Tr∆∞·ªõc)": "xz",
  })
  .name("Ch·ªçn g√≥c nh√¨n")
  .onChange((val) => setViewDirection(val));

// üîπ N√∫t Tr·ª£ gi√∫p
guiView.add(viewParams, "help").name("‚ùì Tr·ª£ gi√∫p");

let previousCameraPos = new THREE.Vector3(); // L∆∞u camera c≈©
let previousTarget = new THREE.Vector3(); // L∆∞u target c≈© n·∫øu d√πng controls.target

function setViewDirection(view) {
  if (!previousCameraPos) previousCameraPos = new THREE.Vector3();
  if (!previousTarget) previousTarget = new THREE.Vector3();
  previousCameraPos.copy(camera.position);
  previousTarget.copy(controls.target);

  worldGroup.rotation.set(0, 0, 0);

  switch (view) {
    case "xy":
      camera.position.set(0, 100, 0);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;
      break;

    case "yz":
      camera.position.set(100, 0, 0);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;
      break;

    case "xz":
      camera.position.set(0, 0, 100);
      controls.target.set(0, 0, 0);
      controls.enableRotate = false;
      autoRotate = false;
      break;

    default:
      camera.position.copy(previousCameraPos);
      controls.target.copy(previousTarget);
      controls.enableRotate = true;
      autoRotate = true;
      break;
  }

  controls.update();
  camera.lookAt(controls.target);
}

// ----- √Ånh s√°ng n√¢ng cao -----
const lightParams = {
  lightMode: "soft",
  materialType: "standard",
  textureImage: null,
  lightColor: "#ffffff",
  lightIntensity: 1,
  lightType: "Directional",
  metalness: 0.5,
  roughness: 0.5,
  animateLight: false,
};

// GUI Tab
const guiLight = guiHelper.addTab("√Ånh S√°ng", 400, {
  icon: "üí°",
  label: "√Ånh S√°ng",
});

// Ch·∫ø ƒë·ªô √°nh s√°ng
guiLight
  .add(lightParams, "lightMode", {
    M·ªÅm: "soft",
    M·∫°nh: "strong",
    "Ch·ªâ khung": "wireframe",
  })
  .name("Ch·∫ø ƒë·ªô √°nh s√°ng")
  .onChange(updateLightMode);

// Lo·∫°i v·∫≠t li·ªáu
guiLight
  .add(lightParams, "materialType", {
    Standard: "standard",
    Phong: "phong",
    Lambert: "lambert",
    Toon: "toon",
    Texture: "texture",
  })
  .name("Lo·∫°i v·∫≠t li·ªáu")
  .onChange(updateLightMode);

// Metalness / Roughness (cho Standard / Texture)
guiLight
  .add(lightParams, "metalness", 0, 1, 0.01)
  .name("üíç Metalness")
  .onChange(updateLightMode);
guiLight
  .add(lightParams, "roughness", 0, 1, 0.01)
  .name("üßΩ Roughness")
  .onChange(updateLightMode);

// M√†u v√† c∆∞·ªùng ƒë·ªô √°nh s√°ng
guiLight
  .addColor(lightParams, "lightColor")
  .name("üé® M√†u √°nh s√°ng")
  .onChange(updateLightMode);
guiLight
  .add(lightParams, "lightIntensity", 0, 5, 0.1)
  .name("üí° C∆∞·ªùng ƒë·ªô")
  .onChange(updateLightMode);

// Lo·∫°i √°nh s√°ng
guiLight
  .add(lightParams, "lightType", {
    Directional: "Directional",
    Point: "Point",
    Spot: "Spot",
  })
  .name("Lo·∫°i √°nh s√°ng")
  .onChange(updateLightMode);

// Animation √°nh s√°ng
guiLight.add(lightParams, "animateLight").name("üîÑ Animate Light");

// Hidden file input cho Texture
const hiddenTextureInput = document.createElement("input");
hiddenTextureInput.type = "file";
hiddenTextureInput.accept = "image/*";
hiddenTextureInput.style.display = "none";
document.body.appendChild(hiddenTextureInput);

hiddenTextureInput.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    lightParams.textureImage = ev.target.result;
    updateLightMode();
  };
  reader.readAsDataURL(file);
});

// N√∫t ch·ªçn ·∫£nh
guiLight
  .add({ ch·ªçn·∫¢nh: () => hiddenTextureInput.click() }, "ch·ªçn·∫¢nh")
  .name("üìÇ Ch·ªçn Texture");

// Tr·ª£ gi√∫p
lightParams.help = () => {
  alert(
    `üí° H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab √Ånh S√°ng:

üîÜ Ch·∫ø ƒë·ªô √°nh s√°ng: M·ªÅm / M·∫°nh / Wireframe
üé® Lo·∫°i v·∫≠t li·ªáu: Standard / Phong / Lambert / Toon / Texture
üíç Metalness / üßΩ Roughness: cho v·∫≠t li·ªáu PBR
üé® M√†u v√† c∆∞·ªùng ƒë·ªô √°nh s√°ng
üí° Lo·∫°i √°nh s√°ng: Directional / Point / Spot
üîÑ Animate Light: √°nh s√°ng quay xung quanh
üìÇ Ch·ªçn Texture: t·∫£i ·∫£nh t·ª´ m√°y ƒë·ªÉ √°p d·ª•ng
`
  );
};
guiLight.add(lightParams, "help").name("‚ùì Tr·ª£ gi√∫p");

// ---------- √Ånh s√°ng worldGroup ----------
if (!worldGroup.light) {
  worldGroup.light = new THREE.DirectionalLight(
    lightParams.lightColor,
    lightParams.lightIntensity
  );
  worldGroup.add(worldGroup.light);
}

// -------- Update √°nh s√°ng + v·∫≠t li·ªáu --------
function updateLightMode() {
  const mode = lightParams.lightMode;
  const materialType = lightParams.materialType;
  if (!surfaceMesh) return;

  // --- C·∫≠p nh·∫≠t √°nh s√°ng ---
  if (worldGroup.light) worldGroup.remove(worldGroup.light);

  switch (lightParams.lightType) {
    case "Point":
      worldGroup.light = new THREE.PointLight(
        lightParams.lightColor,
        lightParams.lightIntensity
      );
      worldGroup.light.position.set(50, 50, 50);
      break;
    case "Spot":
      worldGroup.light = new THREE.SpotLight(
        lightParams.lightColor,
        lightParams.lightIntensity
      );
      worldGroup.light.position.set(50, 100, 50);
      worldGroup.light.angle = Math.PI / 6;
      break;
    default:
      worldGroup.light = new THREE.DirectionalLight(
        lightParams.lightColor,
        lightParams.lightIntensity
      );
      worldGroup.light.position.set(60, 60, 60);
  }
  worldGroup.add(worldGroup.light);

  // --- C·∫≠p nh·∫≠t v·∫≠t li·ªáu ---
  let newMaterial;
  const texLoader = new THREE.TextureLoader();

  switch (materialType) {
    case "phong":
      newMaterial = new THREE.MeshPhongMaterial({
        color: 0xffaa00,
        shininess: 100,
        side: THREE.DoubleSide,
      });
      break;
    case "lambert":
      newMaterial = new THREE.MeshLambertMaterial({
        color: 0x99ccff,
        side: THREE.DoubleSide,
      });
      break;
    case "toon":
      newMaterial = new THREE.MeshToonMaterial({
        color: 0xff99cc,
        gradientMap: null,
        side: THREE.DoubleSide,
      });
      break;
    case "texture":
      if (lightParams.textureImage) {
        const img = new Image();
        img.onload = function () {
          const texture = new THREE.Texture(img);
          texture.needsUpdate = true;
          const texturedMat = new THREE.MeshStandardMaterial({
            map: texture,
            metalness: lightParams.metalness,
            roughness: lightParams.roughness,
            flatShading: mode === "strong",
            side: THREE.DoubleSide,
          });
          applyMaterial(texturedMat);
        };
        img.src = lightParams.textureImage;
        return;
      } else {
        console.warn("Ch∆∞a ch·ªçn ·∫£nh texture.");
        return;
      }
    case "standard":
    default:
      const baseTexture = texLoader.load(
        "https://threejsfundamentals.org/threejs/resources/images/checker.png"
      );
      newMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        map: baseTexture,
        metalness: lightParams.metalness,
        roughness: lightParams.roughness,
        flatShading: mode === "strong",
        side: THREE.DoubleSide,
      });
  }

  if (mode === "wireframe") {
    newMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      wireframe: true,
    });
  }

  applyMaterial(newMaterial);
}

// -------- Apply Material --------
function applyMaterial(material) {
  if (surfaceMesh instanceof THREE.Mesh) {
    surfaceMesh.material.dispose();
    surfaceMesh.material = material;
  }
}

// -------- Animate Light (g·ªçi trong animate loop) --------
function animateLights(deltaTime) {
  if (lightParams.animateLight && worldGroup.light) {
    const t = Date.now() * 0.001;
    worldGroup.light.position.x = 60 * Math.sin(t);
    worldGroup.light.position.z = 60 * Math.cos(t);
  }
}

// ----- History -----
const historyParams = {
  entries: [], // üëà m·∫£ng l∆∞u l·ªãch s·ª≠

  addEntry: (text) => {
    historyParams.entries.push(text);
    updateHistoryBox();
  },

  clear: () => {
    historyParams.entries = [];
    updateHistoryBox();
  },

  help: () => {
    alert(
      `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab L·ªãch S·ª≠:

üìú M·ª•c ƒë√≠ch:
- L∆∞u l·∫°i c√°c h√†nh ƒë·ªông ho·∫∑c s·ª± ki·ªán quan tr·ªçng trong qu√° tr√¨nh l√†m vi·ªác.

‚úÖ Box l·ªãch s·ª≠:
- Hi·ªÉn th·ªã danh s√°ch c√°c s·ª± ki·ªán ƒë√£ l∆∞u.
- T·ª± ƒë·ªông ƒë√°nh s·ªë th·ª© t·ª± cho t·ª´ng d√≤ng.

üóëÔ∏è X√≥a L·ªãch S·ª≠:
- D√πng ƒë·ªÉ x√≥a to√†n b·ªô c√°c s·ª± ki·ªán ƒë√£ l∆∞u, ƒë∆∞a v·ªÅ tr·∫°ng th√°i tr·ªëng.

üõ†Ô∏è L∆∞u s·ª± ki·ªán m·ªõi:
- G·ªçi h√†m historyParams.addEntry("N·ªôi dung s·ª± ki·ªán") ƒë·ªÉ th√™m v√†o l·ªãch s·ª≠.

üëâ T√≠nh nƒÉng n√†y gi√∫p b·∫°n theo d√µi v√† ghi nh·ªõ c√°c b∆∞·ªõc thao t√°c ƒë√£ th·ª±c hi·ªán.`
    );
  },
};

const guiHistory = guiHelper.addTab("L·ªãch S·ª≠", 250, {
  icon: "üìú",
  label: "L·ªãch S·ª≠",
});

// ‚úÖ T·∫°o box hi·ªÉn th·ªã trong tab l·ªãch s·ª≠
const historyWrapper = document.createElement("div");
historyWrapper.style.width = "100%";
historyWrapper.style.minHeight = "150px";
historyWrapper.style.padding = "10px";
historyWrapper.style.marginTop = "8px";
historyWrapper.style.background = "#111";
historyWrapper.style.color = "#0f0";
historyWrapper.style.fontFamily = "monospace";
historyWrapper.style.fontSize = "12px";
historyWrapper.style.borderRadius = "6px";
historyWrapper.style.overflowY = "auto";

const historyBox = document.createElement("pre");
historyBox.style.whiteSpace = "pre-wrap";
historyBox.style.wordBreak = "break-word";
historyBox.textContent = "üìú Ch∆∞a c√≥ l·ªãch s·ª≠.";
historyWrapper.appendChild(historyBox);

guiHistory.domElement.appendChild(historyWrapper);

// ‚úÖ H√†m c·∫≠p nh·∫≠t l·ªãch s·ª≠ trong box
function updateHistoryBox() {
  if (historyParams.entries.length === 0) {
    historyBox.textContent = "üìú Ch∆∞a c√≥ l·ªãch s·ª≠.";
  } else {
    historyBox.textContent = historyParams.entries
      .map((e, i) => `${i + 1}. ${e}`)
      .join("\n");
  }
}

// ‚úÖ Th√™m n√∫t x√≥a l·ªãch s·ª≠
guiHistory.add(historyParams, "clear").name("üóëÔ∏è X√≥a L·ªãch S·ª≠");

// ‚úÖ Th√™m n√∫t tr·ª£ gi√∫p
guiHistory.add(historyParams, "help").name("‚ùì Tr·ª£ gi√∫p");

// ----- Export -----
const exportParams = {
  savePNG: () => saveAsPNG(),
  saveJPG: () => saveAsJPG(),
  saveGLTF: () => saveAsGLTF(),
};

const guiExport = guiHelper.addTab("Xu·∫•t ·∫¢nh", 250, {
  icon: "üì§",
  label: "Xu·∫•t ·∫¢nh",
});

guiExport.add(exportParams, "savePNG").name("üíæ Xu·∫•t PNG");
guiExport.add(exportParams, "saveJPG").name("üíæ Xu·∫•t JPG");
guiExport.add(exportParams, "saveGLTF").name("üíæ Xu·∫•t GLTF");
guiExport
  .add(
    {
      help: () => {
        alert(
          "üì§ H∆∞·ªõng d·∫´n Xu·∫•t ·∫¢nh:\n\n" +
            "üíæ Xu·∫•t PNG: L∆∞u ·∫£nh canvas hi·ªán t·∫°i d∆∞·ªõi d·∫°ng file PNG.\n" +
            "üíæ Xu·∫•t JPG: L∆∞u ·∫£nh canvas hi·ªán t·∫°i d∆∞·ªõi d·∫°ng file JPG.\n" +
            "üíæ Xu·∫•t GLTF: L∆∞u m√¥ h√¨nh 3D hi·ªán t·∫°i ·ªü ƒë·ªãnh d·∫°ng GLTF ƒë·ªÉ d√πng trong Blender/Three.js."
        );
      },
    },
    "help"
  )
  .name("‚ùì Tr·ª£ gi√∫p");
// Xu·∫•t ·∫£nh
function saveAsPNG() {
  renderer.render(scene, camera);
  const link = document.createElement("a");
  link.download = "screenshot.png";
  link.href = renderer.domElement.toDataURL("image/png");
  link.click();
}
// ----- T√≠ch Ph√¢n -----
const integralParams = {
  // 1 bi·∫øn
  func1D: "Math.sin(x)", // h√†m m·∫∑c ƒë·ªãnh
  a: 0,
  b: Math.PI,
  n: 100,
  method: "midpoint",
  showSteps: false,
  compute1D: () => computeIntegral1D(),
  result1D: "Ch∆∞a t√≠nh",
  // 2 bi·∫øn
  func2D: "Math.sin(x) * Math.cos(y)",
  ax: 0,
  bx: Math.PI,
  ay: 0,
  by: Math.PI,
  nx: 30,
  ny: 30,
  colormap: "viridis",
  compute2D: () => computeIntegral2D(),
  result2D: "Ch∆∞a t√≠nh",
};

const guiIntegral = guiHelper.addTab("T√≠ch Ph√¢n", 350, {
  icon: "‚à´",
  label: "T√≠ch Ph√¢n",
});

// --- T√≠ch ph√¢n 1 bi·∫øn ---
// --- T√≠ch ph√¢n 1 bi·∫øn ---
const f1 = guiIntegral.addFolder("üìà 1 Bi·∫øn (‚à´ f(x) dx)");
f1.add(integralParams, "func1D").name("H√†m f(x)");
f1.add(integralParams, "a", -10, 10, 0.1).name("C·∫≠n a");
f1.add(integralParams, "b", -10, 10, 0.1).name("C·∫≠n b");
f1.add(integralParams, "n", 10, 1000, 10).name("S·ªë ƒëi·ªÉm n");
f1.add(integralParams, "method", ["midpoint", "trapezoidal", "simpson"]).name(
  "Ph∆∞∆°ng ph√°p"
);
f1.add(integralParams, "showSteps").name("Hi·ªán t·ª´ng b∆∞·ªõc");
f1.add(integralParams, "result1D").name("K·∫øt qu·∫£").listen();
f1.add(
  {
    visualize3D: () => visualizeIntegral1D3D(),
  },
  "visualize3D"
).name("üü¶ V·∫Ω 3D");

// ‚úÖ T·∫°o canvas trong folder f1 nh∆∞ng ·∫©n ƒëi
const canvasWrapper1D = document.createElement("div");
canvasWrapper1D.style.width = "100%";
canvasWrapper1D.style.height = "250px";
canvasWrapper1D.style.padding = "10px";
canvasWrapper1D.style.display = "none"; // üëà ·∫©n m·∫∑c ƒë·ªãnh

const canvasIntegral = document.createElement("canvas");
canvasIntegral.id = "integralGraph1D";
canvasIntegral.width = 320;
canvasIntegral.height = 240;

canvasWrapper1D.appendChild(canvasIntegral);
f1.domElement.appendChild(canvasWrapper1D);

// ‚úÖ Th√™m n√∫t compute v√† hi·ªán canvas khi b·∫•m
f1.add(integralParams, "compute1D")
  .name("‚ñ∂Ô∏è T√≠nh 1 Bi·∫øn")
  .onChange(() => {
    canvasWrapper1D.style.display = "block"; // üëà hi·ªán canvas
    // integralParams.compute1D();                // g·ªçi h√†m t√≠nh
  });

// --- H√†m t√≠nh & v·∫Ω ---
function computeIntegral1D() {
  const formula = integralParams.func1D.replace(/^f\(x\)\s*=\s*/, "");
  const a =
    typeof integralParams.a === "string"
      ? math.evaluate(integralParams.a)
      : integralParams.a;
  const b =
    typeof integralParams.b === "string"
      ? math.evaluate(integralParams.b)
      : integralParams.b;
  const steps = parseInt(integralParams.n);
  const method = integralParams.method;
  const showSteps = integralParams.showSteps;

  const expr = math.compile(formula);

  let area = 0;
  const dx = (b - a) / steps;
  const xVals = [],
    yVals = [],
    barData = [];

  if (method === "midpoint") {
    for (let i = 0; i < steps; i++) {
      const x = a + (i + 0.5) * dx;
      const y = expr.evaluate({ x });
      const slice = y * dx;
      area += slice;
      xVals.push(x);
      yVals.push(y);
      barData.push({ x, y });
    }
  } else if (method === "trapezoidal") {
    for (let i = 0; i <= steps; i++) {
      const x = a + i * dx;
      const y = expr.evaluate({ x });
      xVals.push(x);
      yVals.push(y);
      barData.push({ x, y });
      if (i === 0 || i === steps) area += y / 2;
      else area += y;
    }
    area *= dx;
  } else if (method === "simpson" && steps % 2 === 0) {
    for (let i = 0; i <= steps; i++) {
      const x = a + i * dx;
      const y = expr.evaluate({ x });
      xVals.push(x);
      yVals.push(y);
      barData.push({ x, y });
      if (i === 0 || i === steps) area += y;
      else if (i % 2 === 0) area += 2 * y;
      else area += 4 * y;
    }
    area *= dx / 3;
  } else {
    alert("Simpson's Rule c·∫ßn s·ªë kho·∫£ng n ch·∫µn.");
    return;
  }

  // üëâ update k·∫øt qu·∫£ trong GUI
  integralParams.result1D = `‚âà ${area.toFixed(6)}`;
  // üëâ l∆∞u v√†o l·ªãch s·ª≠ (d√πng historyParams thay v√¨ historyData)
  const historyEntry = `H√†m: ${formula}, [${a}, ${b}], n=${steps}, ph∆∞∆°ng ph√°p=${method}, KQ=${area.toFixed(
    6
  )}`;
  historyParams.addEntry(historyEntry);
  // üëâ v·∫Ω b·∫±ng Chart.js
  const ctx = canvasIntegral.getContext("2d");
  if (window.chartIntegral1D) window.chartIntegral1D.destroy();

  window.chartIntegral1D = new Chart(ctx, {
    type: "bar",
    data: {
      datasets: [
        {
          type: "line",
          label: "f(x)",
          data: xVals.map((x, i) => ({ x, y: yVals[i] })),
          borderColor: "blue",
          backgroundColor: "rgba(59,130,246,0.2)",
          tension: 0.3,
          fill: true,
          parsing: false,
        },
        {
          type: "bar",
          label: "Di·ªán t√≠ch l√°t",
          data: barData,
          backgroundColor: "rgba(34,197,94,0.6)",
          borderWidth: 0,
          parsing: false,
          barThickness: Math.max(1, 300 / steps),
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { type: "linear", title: { display: true, text: "x" } },
        y: { title: { display: true, text: "f(x)" } },
      },
    },
  });
}
function visualizeIntegral1D3D() {
  const formula = integralParams.func1D.replace(/^f\(x\)\s*=\s*/, "");
  const a =
    typeof integralParams.a === "string"
      ? math.evaluate(integralParams.a)
      : integralParams.a;
  const b =
    typeof integralParams.b === "string"
      ? math.evaluate(integralParams.b)
      : integralParams.b;
  const steps = parseInt(integralParams.n);
  const expr = math.compile(formula);

  const dx = (b - a) / steps;
  const vertices = [];
  const colors = [];
  const color = new THREE.Color();

  const z0 = 0; // ƒë√°y
  for (let i = 0; i < steps; i++) {
    const x1 = a + i * dx;
    const x2 = a + (i + 1) * dx;
    const y1 = expr.evaluate({ x: x1 });
    const y2 = expr.evaluate({ x: x2 });

    // T·∫°o 2 tam gi√°c cho m·ªói l√°t (bar)
    vertices.push(
      x1,
      z0,
      0,
      x2,
      z0,
      0,
      x1,
      y1,
      0,

      x2,
      z0,
      0,
      x2,
      y2,
      0,
      x1,
      y1,
      0
    );

    // m√†u s·∫Øc theo chi·ªÅu cao
    const avgY = (y1 + y2) / 2;
    color.setHSL(0.3 - 0.3 * (avgY / 10), 1.0, 0.5);
    for (let k = 0; k < 6; k++) colors.push(color.r, color.g, color.b);
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(vertices, 3)
  );
  geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.8,
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.name = "integral1DSurface";

  const old = worldGroup.getObjectByName("integral1DSurface");
  if (old) worldGroup.remove(old);
  worldGroup.add(mesh);

  // C·∫≠p nh·∫≠t camera
  if (camera && controls) {
    const centerX = (a + b) / 2;
    const centerY = 0;
    let zMax = Math.max(...vertices.filter((v, i) => i % 3 === 1));
    controls.target.set(centerX, centerY, zMax / 2);
    camera.position.set(centerX, -(b - a) * 1.5, zMax + 2);
    controls.update();
  }
}

// ----- T√≠ch Ph√¢n 2D (d√πng integralParams) -----
const f2 = guiIntegral.addFolder("üìä 2 Bi·∫øn (‚à¨ f(x,y) dxdy)");
f2.add(integralParams, "func2D").name("H√†m f(x,y)");
f2.add(integralParams, "ax", -10, 10, 0.1).name("X min");
f2.add(integralParams, "bx", -10, 10, 0.1).name("X max");
f2.add(integralParams, "ay", -10, 10, 0.1).name("Y min");
f2.add(integralParams, "by", -10, 10, 0.1).name("Y max");
f2.add(integralParams, "nx", 10, 200, 1).name("Nx");
f2.add(integralParams, "ny", 10, 200, 1).name("Ny");
f2.add(integralParams, "colormap", ["viridis", "plasma", "turbo", "gray"])
  .name("Colormap")
  .onChange(() => computeIntegral2D());

guiIntegral
  .add(
    {
      help: () => {
        alert(
          "‚à´ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng T√≠ch Ph√¢n:\n\n" +
            "üìà 1 Bi·∫øn:\n" +
            "- Nh·∫≠p h√†m f(x), v√≠ d·ª•: Math.sin(x)\n" +
            "- Ch·ªçn c·∫≠n a, b v√† s·ªë ƒëi·ªÉm n ƒë·ªÉ chia nh·ªè.\n" +
            "- Ph∆∞∆°ng ph√°p: midpoint (h√¨nh ch·ªØ nh·∫≠t), trapezoidal (h√¨nh thang), simpson.\n" +
            "- B·∫•m ‚ñ∂Ô∏è T√≠nh 1 Bi·∫øn ƒë·ªÉ xem k·∫øt qu·∫£ v√† ƒë·ªì th·ªã.\n\n" +
            "üìä 2 Bi·∫øn:\n" +
            "- Nh·∫≠p h√†m f(x,y), v√≠ d·ª•: Math.sin(x)*Math.cos(y)\n" +
            "- Ch·ªçn mi·ªÅn X: [ax, bx], Y: [ay, by]\n" +
            "- Nx, Ny: s·ªë ƒëi·ªÉm chia theo X v√† Y.\n" +
            "- Colormap: ch·ªçn b·∫£ng m√†u hi·ªÉn th·ªã heatmap.\n" +
            "- B·∫•m ‚ñ∂Ô∏è T√≠nh 2 Bi·∫øn ƒë·ªÉ xem k·∫øt qu·∫£, heatmap v√† m√¥ h√¨nh 3D."
        );
      },
    },
    "help"
  )
  .name("‚ùì Tr·ª£ gi√∫p");

// ‚úÖ T·∫°o canvas heatmap nh∆∞ng ·∫©n ƒëi
const canvasWrapper2D = document.createElement("div");
canvasWrapper2D.style.width = "100%";
canvasWrapper2D.style.height = "250px";
canvasWrapper2D.style.padding = "10px";
canvasWrapper2D.style.display = "none"; // üëà ·∫©n m·∫∑c ƒë·ªãnh

const canvasHeatmap2D = document.createElement("canvas");
canvasHeatmap2D.id = "integralHeatmap2D";
canvasHeatmap2D.width = 320;
canvasHeatmap2D.height = 240;

canvasWrapper2D.appendChild(canvasHeatmap2D);
f2.domElement.appendChild(canvasWrapper2D);

const resultCtrl = f2
  .add(integralParams, "result2D")
  .name("K·∫øt qu·∫£ ‚à¨")
  .listen();

// ‚úÖ N√∫t compute 2D: hi·ªán canvas + ch·∫°y t√≠nh to√°n
f2.add(integralParams, "compute2D")
  .name("‚ñ∂Ô∏è T√≠nh 2 Bi·∫øn")
  .onChange(() => {
    canvasWrapper2D.style.display = "block"; // üëà hi·ªán canvas
    // integralParams.compute2D();               // g·ªçi h√†m t√≠nh
  });

// T√≠nh t√≠ch ph√¢n 2D ƒë∆°n gi·∫£n b·∫±ng ph∆∞∆°ng ph√°p h√¨nh ch·ªØ nh·∫≠t
function computeIntegral2D() {
  const formula =
    typeof integralParams.func2D === "string"
      ? integralParams.func2D.replace(/^f\(x,y\)\s*=\s*/, "")
      : String(integralParams.func2D);

  const xMin = parseFloat(integralParams.ax);
  const xMax = parseFloat(integralParams.bx);
  const yMin = parseFloat(integralParams.ay);
  const yMax = parseFloat(integralParams.by);
  const stepsX = parseInt(integralParams.nx);
  const stepsY = parseInt(integralParams.ny);
  const colormapName = integralParams.colormap || "viridis";

  const expr = math.compile(formula);
  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  let sum = 0;
  for (let i = 0; i <= stepsX; i++) {
    const x = xMin + i * dx;
    for (let j = 0; j <= stepsY; j++) {
      const y = yMin + j * dy;
      const val = expr.evaluate({ x, y });
      if (isFinite(val)) sum += val * dx * dy;
    }
  }

  integralParams.result2D = `‚âà ${sum.toFixed(6)}`; // c·∫≠p nh·∫≠t GUI t·ª± ƒë·ªông nh·ªù .listen()

  // --- ghi l·ªãch s·ª≠ ---
  const timestamp = new Date().toLocaleTimeString();
  const entry = `[${timestamp}] ‚à´‚à´ f(x,y) dxdy = ${sum.toFixed(
    6
  )} | f(x,y)=${formula}, [${xMin},${xMax}]√ó[${yMin},${yMax}] steps=(${stepsX},${stepsY})`;
  historyParams.addEntry(entry);

  // v·∫Ω heatmap v√† 3D surface b·∫±ng c√°c h√†m ƒë√£ vi·∫øt, truy·ªÅn tham s·ªë v√†o
  draw2DHeatmap(formula, xMin, xMax, yMin, yMax, stepsX, stepsY, colormapName);
  visualizeIntegral2D(formula, xMin, xMax, yMin, yMax, stepsX, stepsY);
}

function draw2DHeatmap(
  formula,
  xMin,
  xMax,
  yMin,
  yMax,
  stepsX,
  stepsY,
  colormapName = "viridis"
) {
  const ctx = document.getElementById("integralHeatmap2D")?.getContext("2d");
  if (!ctx) return;

  const expr = math.compile(formula);
  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;

  const data = [];
  let zMin = Infinity,
    zMax = -Infinity;

  for (let i = 0; i < stepsX; i++) {
    const x = xMin + i * dx + dx / 2;
    for (let j = 0; j < stepsY; j++) {
      const y = yMin + j * dy + dy / 2;
      try {
        const z = expr.evaluate({ x, y });
        if (!isFinite(z)) continue;
        data.push({ x, y, v: z });
        zMin = Math.min(zMin, z);
        zMax = Math.max(zMax, z);
      } catch (e) {
        console.warn(`L·ªói t·∫°i (${x},${y}):`, e.message);
      }
    }
  }

  if (window.heatmap2DChart) window.heatmap2DChart.destroy();

  window.heatmap2DChart = new Chart(ctx, {
    type: "matrix",
    data: {
      datasets: [
        {
          label: "f(x,y)",
          data: data,
          backgroundColor(ctx) {
            const point = ctx.dataset?.data?.[ctx.dataIndex];
            if (!point || typeof point.v !== "number") return "rgba(0,0,0,0)";
            const normalized = (point.v - zMin) / (zMax - zMin || 1);
            return getColorFromMap(normalized, colormapName);
          },

          width(ctx) {
            const area = ctx.chart.chartArea;
            if (!area) return 10;
            return area.width / stepsX;
          },
          height(ctx) {
            const area = ctx.chart.chartArea;
            if (!area) return 10;
            return area.height / stepsY;
          },
        },
      ],
    },
    options: {
      maintainAspectRatio: true,
      responsive: true,
      plugins: {
        tooltip: {
          callbacks: {
            title: () => "",
            label: (ctx) => {
              const d = ctx.raw;
              return `x: ${d.x.toFixed(2)}, y: ${d.y.toFixed(
                2
              )}, z: ${d.v.toFixed(2)}`;
            },
          },
        },
        legend: { display: false },
      },
      scales: {
        x: {
          type: "linear",
          min: xMin,
          max: xMax,
          title: { display: true, text: "x" },
        },
        y: {
          type: "linear",
          min: yMin,
          max: yMax,
          title: { display: true, text: "y" },
        },
      },
    },
  });
}

function getColorFromMap(t, mapName = "viridis") {
  t = Math.min(1, Math.max(0, t)); // ƒë·∫£m b·∫£o t ‚àà [0,1]

  // C√°c colormap ph·ªï bi·∫øn
  switch (mapName) {
    case "plasma":
      return plasmaColorMap(t);
    case "turbo":
      return turboColorMap(t);
    case "gray":
      const g = Math.floor(255 * t);
      return `rgba(${g},${g},${g},1)`;
    case "viridis":
    default:
      return viridisColorMap(t);
  }
}

// Colormap viridis (gi·∫£m nh·∫π ƒë·ªÉ ph√π h·ª£p)
function viridisColorMap(t) {
  const r = Math.floor(255 * Math.max(0, Math.min(1, 0.267 + 1.5 * t)));
  const g = Math.floor(255 * Math.max(0, Math.min(1, 0.004 + 2.0 * t)));
  const b = Math.floor(255 * Math.max(0, Math.min(1, 0.329 + 1.2 * t)));
  return `rgba(${r},${g},${b},1)`;
}

function plasmaColorMap(t) {
  const r = Math.floor(255 * Math.min(1, Math.max(0, 1.5 * t)));
  const g = Math.floor(255 * Math.abs(Math.sin(t * Math.PI)));
  const b = Math.floor(255 * (1 - t));
  return `rgba(${r},${g},${b},1)`;
}

function turboColorMap(t) {
  // https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html
  const r = Math.floor(
    255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.75))))
  );
  const g = Math.floor(
    255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.5))))
  );
  const b = Math.floor(
    255 * Math.max(0, Math.min(1, 1.0 - Math.abs(4.0 * (t - 0.25))))
  );
  return `rgba(${r},${g},${b},1)`;
}

function visualizeIntegral2D(formula, xMin, xMax, yMin, yMax, stepsX, stepsY) {
  const dx = (xMax - xMin) / stepsX;
  const dy = (yMax - yMin) / stepsY;
  const expr = math.compile(formula);

  function safeEval(x, y) {
    try {
      const z = expr.evaluate({ x, y });
      return isFinite(z) ? z : null;
    } catch {
      return null;
    }
  }

  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const colors = [];
  const color = new THREE.Color();
  const z0 = 0; // m·∫∑t ph·∫≥ng ƒë√°y

  // ===== M·∫∑t tr√™n (surface) + t∆∞·ªùng =====
  for (let i = 0; i < stepsX; i++) {
    for (let j = 0; j < stepsY; j++) {
      const x1 = xMin + i * dx;
      const y1 = yMin + j * dy;
      const x2 = xMin + (i + 1) * dx;
      const y2 = yMin + (j + 1) * dy;

      const z11 = safeEval(x1, y1);
      const z12 = safeEval(x1, y2);
      const z21 = safeEval(x2, y1);
      const z22 = safeEval(x2, y2);

      if (z11 == null || z12 == null || z21 == null || z22 == null) {
        continue; // b·ªè qua √¥ l·ªói
      }

      // --- M·∫∑t tr√™n (surface) ---
      vertices.push(x1, y1, z11, x2, y1, z21, x1, y2, z12);
      vertices.push(x2, y1, z21, x2, y2, z22, x1, y2, z12);

      const avgZ = (z11 + z12 + z21 + z22) / 4;
      for (let k = 0; k < 6; k++) {
        color.setHSL(0.6 - 0.6 * (avgZ / 10), 1.0, 0.5);
        colors.push(color.r, color.g, color.b);
      }

      // --- T∆∞·ªùng ƒë·ª©ng (k√©o xu·ªëng z=0) ---

      // c·∫°nh theo x (y = y1)
      vertices.push(x1, y1, z0, x1, y1, z11, x2, y1, z21);
      vertices.push(x1, y1, z0, x2, y1, z21, x2, y1, z0);

      // c·∫°nh theo x (y = y2)
      vertices.push(x1, y2, z0, x1, y2, z12, x2, y2, z22);
      vertices.push(x1, y2, z0, x2, y2, z22, x2, y2, z0);

      // c·∫°nh theo y (x = x1)
      vertices.push(x1, y1, z0, x1, y2, z12, x1, y1, z11);
      vertices.push(x1, y1, z0, x1, y2, z0, x1, y2, z12);

      // c·∫°nh theo y (x = x2)
      vertices.push(x2, y1, z0, x2, y2, z22, x2, y1, z21);
      vertices.push(x2, y1, z0, x2, y2, z0, x2, y2, z22);

      // m√†u t∆∞·ªùng
      for (let k = 0; k < 24; k++) {
        color.setHSL(0.6 - 0.6 * (avgZ / 10), 1.0, 0.3);
        colors.push(color.r, color.g, color.b);
      }
    }
  }

  // ===== M·∫∑t ƒë√°y (z=0) =====
  for (let i = 0; i < stepsX; i++) {
    for (let j = 0; j < stepsY; j++) {
      const x1 = xMin + i * dx;
      const y1 = yMin + j * dy;
      const x2 = xMin + (i + 1) * dx;
      const y2 = yMin + (j + 1) * dy;

      vertices.push(x1, y1, z0, x2, y1, z0, x1, y2, z0);
      vertices.push(x2, y1, z0, x2, y2, z0, x1, y2, z0);

      for (let k = 0; k < 6; k++) {
        color.setRGB(0.2, 0.2, 0.2);
        colors.push(color.r, color.g, color.b);
      }
    }
  }

  // ===== T·∫°o mesh =====
  geometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(vertices, 3)
  );
  geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.7,
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.name = "integralSurface";

  const old = worldGroup.getObjectByName("integralSurface");
  if (old) worldGroup.remove(old);
  worldGroup.add(mesh);

  // ===== C·∫≠p nh·∫≠t camera =====
  if (camera && controls) {
    const centerX = (xMin + xMax) / 2;
    const centerY = (yMin + yMax) / 2;
    let zSum = 0;
    for (let k = 2; k < vertices.length; k += 3) {
      zSum += vertices[k];
    }
    const centerZ = zSum / (vertices.length / 3);
    controls.target.set(centerX, centerY, centerZ);
    camera.position.set(centerX, centerY - (xMax - xMin) * 1.5, centerZ + 5);
    controls.update();
  }
}

// ----- Fourier -----
const fourierParams = {
  func: "Math.sin(x)", // h√†m g·ªëc f(x)
  terms: 10, // s·ªë s·ªë h·∫°ng Fourier
  xmin: 0,
  xmax: 2 * Math.PI,
  nPoints: 200, // s·ªë ƒëi·ªÉm v·∫Ω ƒë·ªì th·ªã
  showOriginal: true, // hi·ªÉn th·ªã h√†m g·ªëc
  showApprox: true, // hi·ªÉn th·ªã x·∫•p x·ªâ Fourier
  result: "", // k·∫øt qu·∫£ text (chu·ªói Fourier)

  compute: () => computeFourier(),
};
const guiFourier = guiHelper.addTab("üî∂ Fourier", 350, {
  icon: "üî∂",
  label: "Chu·ªói Fourier",
});

// Input h√†m
guiFourier.add(fourierParams, "func").name("f(x)");

// S·ªë h·∫°ng Fourier
guiFourier.add(fourierParams, "terms", 1, 50, 1).name("S·ªë h·∫°ng N");

// Kho·∫£ng x
guiFourier.add(fourierParams, "xmin", -10, 10, 0.1).name("X min");
guiFourier.add(fourierParams, "xmax", -10, 10, 0.1).name("X max");

// S·ªë ƒëi·ªÉm v·∫Ω
guiFourier.add(fourierParams, "nPoints", 50, 1000, 1).name("S·ªë ƒëi·ªÉm");

// Checkbox hi·ªÉn th·ªã
guiFourier.add(fourierParams, "showOriginal").name("Hi·ªÉn th·ªã h√†m g·ªëc");
guiFourier.add(fourierParams, "showApprox").name("Hi·ªÉn th·ªã x·∫•p x·ªâ Fourier");

// N√∫t t√≠nh to√°n
guiFourier.add(fourierParams, "compute").name("‚ñ∂Ô∏è T√≠nh Fourier");

// K·∫øt qu·∫£
const resultCtrlFourier = guiFourier
  .add(fourierParams, "result")
  .name("Chu·ªói Fourier")
  .listen();
function computeFourier() {
  const formula = fourierParams.func;
  const N = parseInt(fourierParams.terms);
  const xMin = parseFloat(fourierParams.xmin);
  const xMax = parseFloat(fourierParams.xmax);
  const nPoints = parseInt(fourierParams.nPoints);

  const dx = (xMax - xMin) / (nPoints - 1);
  const xs = [];
  const fOrig = [];
  const fApprox = [];

  const expr = math.compile(formula);

  for (let i = 0; i < nPoints; i++) {
    const x = xMin + i * dx;
    xs.push(x);
    try {
      fOrig.push(expr.evaluate({ x }));
    } catch {
      fOrig.push(0);
    }
  }

  const L = (xMax - xMin) / 2;
  const a0 =
    (1 / L) * xs.reduce((acc, x) => acc + expr.evaluate({ x }), 0) * dx;
  const a = [],
    b = [];
  for (let n = 1; n <= N; n++) {
    let an = 0,
      bn = 0;
    for (let i = 0; i < nPoints; i++) {
      const x = xs[i];
      const fx = expr.evaluate({ x });
      an += fx * Math.cos((n * Math.PI * (x - xMin)) / L);
      bn += fx * Math.sin((n * Math.PI * (x - xMin)) / L);
    }
    a.push((an * dx) / L);
    b.push((bn * dx) / L);
  }

  for (let i = 0; i < nPoints; i++) {
    const x = xs[i];
    let sum = a0 / 2;
    for (let n = 1; n <= N; n++)
      sum +=
        a[n - 1] * Math.cos((n * Math.PI * (x - xMin)) / L) +
        b[n - 1] * Math.sin((n * Math.PI * (x - xMin)) / L);
    fApprox.push(sum);
  }

  fourierParams.result = `f(x) ‚âà a0/2 + Œ£(1‚Üí${N}) [a_n cos(nœÄx/L) + b_n sin(nœÄx/L)]`;

  // V·∫Ω 2D chart
  drawFourierChart(xs, fOrig, fApprox);

  // V·∫Ω 3D surface
  visualizeFourier3D(xs, fApprox);
}

const canvasFourier = document.createElement("canvas");
canvasFourier.id = "fourierCanvas";
canvasFourier.width = 600;
canvasFourier.height = 300;
guiFourier.domElement.appendChild(canvasFourier);

function drawFourierChart(xs, fOrig, fApprox) {
  if (window.fourierChart) window.fourierChart.destroy();

  const datasets = [];
  if (fourierParams.showOriginal) {
    datasets.push({
      label: "H√†m g·ªëc",
      data: xs.map((x, i) => ({ x, y: fOrig[i] })),
      borderColor: "blue",
      fill: false,
      tension: 0.1,
    });
  }
  if (fourierParams.showApprox) {
    datasets.push({
      label: "X·∫•p x·ªâ Fourier",
      data: xs.map((x, i) => ({ x, y: fApprox[i] })),
      borderColor: "red",
      fill: false,
      tension: 0.1,
    });
  }

  const ctx = document.getElementById("fourierCanvas").getContext("2d");
  window.fourierChart = new Chart(ctx, {
    type: "line",
    data: { datasets },
    options: {
      responsive: true,
      plugins: { legend: { display: true } },
      scales: {
        x: { type: "linear", title: { display: true, text: "x" } },
        y: { title: { display: true, text: "f(x)" } },
      },
    },
  });
}
function visualizeFourier3D(xs, fApprox) {
  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const colors = [];
  const color = new THREE.Color();

  const y0 = -0.5; // b·ªÅ r·ªông mesh theo Y
  const y1 = 0.5;

  for (let i = 0; i < xs.length - 1; i++) {
    const x1 = xs[i],
      x2 = xs[i + 1];
    const z1 = fApprox[i],
      z2 = fApprox[i + 1];

    // T·∫°o 2 tam gi√°c (quad) gi·ªØa 2 ƒëi·ªÉm li√™n ti·∫øp
    vertices.push(x1, y0, z1, x2, y0, z2, x1, y1, z1);
    vertices.push(x2, y0, z2, x2, y1, z2, x1, y1, z1);

    // m√†u gradient theo Z
    for (let k = 0; k < 6; k++) {
      const t = (z1 + z2) / 2; // trung b√¨nh 2 ƒëi·ªÉm
      color.setHSL(0.6 - 0.6 * (t / 10), 1.0, 0.5);
      colors.push(color.r, color.g, color.b);
    }
  }

  geometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(vertices, 3)
  );
  geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.8,
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.name = "fourierSurface";

  const old = worldGroup.getObjectByName("fourierSurface");
  if (old) worldGroup.remove(old);
  worldGroup.add(mesh);

  // c·∫≠p nh·∫≠t camera/controls
  if (camera && controls) {
    const centerX = (xs[0] + xs[xs.length - 1]) / 2;
    let zSum = 0;
    for (let k = 2; k < vertices.length; k += 3) zSum += vertices[k];
    const centerZ = zSum / (vertices.length / 3);
    controls.target.set(centerX, 0, centerZ);
    camera.position.set(centerX, -(xs[xs.length - 1] - xs[0]), centerZ + 5);
    controls.update();
  }
}
// ----- Fourier 2D -----
const fourier2DParams = {
  func: "Math.sin(x)*Math.cos(2*y)", // h√†m 2 bi·∫øn f(x,y)
  termsX: 5, // s·ªë h·∫°ng Fourier theo X
  termsY: 5, // s·ªë h·∫°ng Fourier theo Y
  xmin: 0,
  xmax: 2 * Math.PI,
  ymin: 0,
  ymax: 2 * Math.PI,
  nPoints: 50, // s·ªë ƒëi·ªÉm tr√™n m·ªói tr·ª•c
  showOriginal: true,
  showApprox: true,
  result: "",
  compute: () => computeFourier2D(),
};

const guiFourier2D = guiHelper.addTab("üî∑ Fourier 2D", 350, {
  icon: "üî∑",
  label: "Chu·ªói Fourier 2D",
});
guiFourier2D.add(fourier2DParams, "func").name("f(x,y)");
guiFourier2D.add(fourier2DParams, "termsX", 1, 20, 1).name("S·ªë h·∫°ng X");
guiFourier2D.add(fourier2DParams, "termsY", 1, 20, 1).name("S·ªë h·∫°ng Y");
guiFourier2D.add(fourier2DParams, "xmin", -10, 10, 0.1).name("X min");
guiFourier2D.add(fourier2DParams, "xmax", -10, 10, 0.1).name("X max");
guiFourier2D.add(fourier2DParams, "ymin", -10, 10, 0.1).name("Y min");
guiFourier2D.add(fourier2DParams, "ymax", -10, 10, 0.1).name("Y max");
guiFourier2D.add(fourier2DParams, "nPoints", 10, 200, 1).name("S·ªë ƒëi·ªÉm");
guiFourier2D.add(fourier2DParams, "showOriginal").name("Hi·ªÉn th·ªã g·ªëc");
guiFourier2D.add(fourier2DParams, "showApprox").name("Hi·ªÉn th·ªã x·∫•p x·ªâ");
guiFourier2D.add(fourier2DParams, "compute").name("‚ñ∂Ô∏è T√≠nh Fourier 2D");
guiFourier2D.add(fourier2DParams, "result").name("Chu·ªói Fourier 2D").listen();

function computeFourier2D() {
  const formula = fourier2DParams.func;
  const Nx = parseInt(fourier2DParams.termsX);
  const Ny = parseInt(fourier2DParams.termsY);
  const nPoints = parseInt(fourier2DParams.nPoints);
  const xMin = parseFloat(fourier2DParams.xmin);
  const xMax = parseFloat(fourier2DParams.xmax);
  const yMin = parseFloat(fourier2DParams.ymin);
  const yMax = parseFloat(fourier2DParams.ymax);

  const dx = (xMax - xMin) / (nPoints - 1);
  const dy = (yMax - yMin) / (nPoints - 1);

  const xs = [],
    ys = [],
    fOrig = [],
    fApprox = [];
  const expr = math.compile(formula);

  for (let i = 0; i < nPoints; i++) xs.push(xMin + i * dx);
  for (let j = 0; j < nPoints; j++) ys.push(yMin + j * dy);

  // T·∫°o l∆∞·ªõi 2D
  for (let i = 0; i < nPoints; i++) {
    fOrig[i] = [];
    fApprox[i] = [];
    for (let j = 0; j < nPoints; j++) {
      const x = xs[i],
        y = ys[j];
      fOrig[i][j] = expr.evaluate({ x, y });
      fApprox[i][j] = 0; // kh·ªüi t·∫°o x·∫•p x·ªâ
    }
  }

  // Fourier 2D x·∫•p x·ªâ b·∫±ng Nx * Ny s·ªë h·∫°ng
  const Lx = (xMax - xMin) / 2,
    Ly = (yMax - yMin) / 2;
  for (let n = 0; n < Nx; n++) {
    for (let m = 0; m < Ny; m++) {
      // T√≠nh h·ªá s·ªë anm = 4/Lx/Ly ‚à´‚à´ f(x,y) cos(nœÄx/Lx) cos(mœÄy/Ly) dxdy (gi·∫£ s·ª≠ ch·∫µn)
      let sum = 0;
      for (let i = 0; i < nPoints; i++) {
        for (let j = 0; j < nPoints; j++) {
          sum +=
            fOrig[i][j] *
            Math.cos((n * Math.PI * (xs[i] - xMin)) / Lx) *
            Math.cos((m * Math.PI * (ys[j] - yMin)) / Ly);
        }
      }
      const anm = (4 / (Lx * Ly)) * sum * dx * dy; // b·ªè chia nPoints*nPoints
      for (let i = 0; i < nPoints; i++) {
        for (let j = 0; j < nPoints; j++) {
          fApprox[i][j] +=
            anm *
            Math.cos((n * Math.PI * (xs[i] - xMin)) / Lx) *
            Math.cos((m * Math.PI * (ys[j] - yMin)) / Ly);
        }
      }
    }
  }

  fourier2DParams.result = `f(x,y) ‚âà Œ£(n=0‚Üí${Nx}) Œ£(m=0‚Üí${Ny}) a_nm cos(nœÄx/Lx) cos(mœÄy/Ly)`;

  drawFourier2DSurface(xs, ys, fOrig, fApprox);
}

// V·∫Ω surface 3D
function drawFourier2DSurface(xs, ys, fOrig, fApprox) {
  const geometry = new THREE.BufferGeometry();
  const vertices = [],
    colors = [];
  const color = new THREE.Color();
  const n = xs.length;

  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1; j++) {
      const x1 = xs[i],
        x2 = xs[i + 1],
        y1 = ys[j],
        y2 = ys[j + 1];
      const z11 = fApprox[i][j],
        z12 = fApprox[i][j + 1],
        z21 = fApprox[i + 1][j],
        z22 = fApprox[i + 1][j + 1];

      // 2 tam gi√°c
      vertices.push(x1, y1, z11, x2, y1, z21, x1, y2, z12);
      vertices.push(x2, y1, z21, x2, y2, z22, x1, y2, z12);

      for (let k = 0; k < 6; k++) {
        const t = (z11 + z12 + z21 + z22) / 4;
        color.setHSL(0.6 - 0.6 * (t / 10), 1, 0.5);
        colors.push(color.r, color.g, color.b);
      }
    }
  }

  geometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(vertices, 3)
  );
  geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.8,
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.name = "fourier2DSurface";

  const old = worldGroup.getObjectByName("fourier2DSurface");
  if (old) worldGroup.remove(old);
  worldGroup.add(mesh);

  if (camera && controls) {
    const centerX = (xs[0] + xs[xs.length - 1]) / 2;
    const centerY = (ys[0] + ys[ys.length - 1]) / 2;
    let zSum = 0;
    for (let k = 2; k < vertices.length; k += 3) zSum += vertices[k];
    const centerZ = zSum / (vertices.length / 3);
    controls.target.set(centerX, centerY, centerZ);
    camera.position.set(
      centerX - (xs[xs.length - 1] - xs[0]),
      centerY - (ys[ys.length - 1] - ys[0]),
      centerZ + 5
    );
    controls.update();
  }
}

// ----- ƒê·ªì th·ªã 2D -----
const graph2DParams = {
  formula: "y = sin(x)", // c√¥ng th·ª©c m·∫∑c ƒë·ªãnh
  domain: {
    xMin: -10,
    xMax: 10,
    step: 0.1,
  },
  plot: () => plotGraph2D(),
  help: () => {
    alert(
      `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab ƒê·ªì th·ªã 2D:

‚úèÔ∏è C√¥ng th·ª©c:
- Nh·∫≠p c√¥ng th·ª©c d·∫°ng "y = f(x)".
- V√≠ d·ª•: y = sin(x), y = cos(x), y = x^2, y = exp(-x^2).

üìê X Min, X Max:
- Gi·ªõi h·∫°n mi·ªÅn gi√° tr·ªã tr·ª•c X.

üî¢ B∆∞·ªõc Œîx:
- ƒê·ªô chia nh·ªè, c√†ng nh·ªè th√¨ ƒë·ªì th·ªã c√†ng m∆∞·ª£t.

üìà V·∫Ω ƒê·ªì Th·ªã:
- Nh·∫•n ƒë·ªÉ c·∫≠p nh·∫≠t ƒë·ªì th·ªã.

üñºÔ∏è K·∫øt qu·∫£:
- ƒê·ªì th·ªã hi·ªÉn th·ªã tr·ª±c ti·∫øp.
- C√≥ th·ªÉ thu ph√≥ng, ƒë·ªïi c√¥ng th·ª©c b·∫•t k·ª≥ l√∫c n√†o.
`
    );
  },
};

// T·∫°o tab trong GUI
const guiGraph2D = guiHelper.addTab("ƒê·ªì th·ªã 2D", 350, {
  icon: "üìà",
  label: "ƒê·ªì th·ªã 2D",
});

guiGraph2D.add(graph2DParams, "formula").name("C√¥ng th·ª©c");

// T·∫°o folder con cho mi·ªÅn gi√° tr·ªã
const domainFolder = guiGraph2D.addFolder("Mi·ªÅn gi√° tr·ªã X");
domainFolder.add(graph2DParams.domain, "xMin", -50, 0, 1).name("X Min");
domainFolder.add(graph2DParams.domain, "xMax", 0, 50, 1).name("X Max");
domainFolder.add(graph2DParams.domain, "step", 0.01, 1, 0.01).name("B∆∞·ªõc Œîx");

guiGraph2D.add(graph2DParams, "plot").name("üìà V·∫Ω ƒê·ªì Th·ªã");
graph2DParams.plot3D = () => plotGraph2D3D();
guiGraph2D.add(graph2DParams, "plot3D").name("üü¢ V·∫Ω ra 3D");
function addAsymptotes3D(verticalAsymptotes = [], obliqueAsymptotes = []) {
  const group = new THREE.Group();

  verticalAsymptotes.forEach((x) => {
    const points = [
      new THREE.Vector3(x, -1000, 0),
      new THREE.Vector3(x, 1000, 0),
    ];
    const mat = new THREE.LineDashedMaterial({
      color: 0xff9900,
      dashSize: 1,
      gapSize: 1,
      linewidth: 2,
    });
    const geom = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geom, mat);
    line.computeLineDistances(); // b·∫Øt bu·ªôc cho dashed
    group.add(line);

    // Th√™m nh√£n x
    const label = makeTextSprite(`x=${x.toFixed(2)}`, {
      fontsize: 20,
      borderColor: { r: 255, g: 153, b: 0, a: 1 },
    });
    label.position.set(x, 0, 0);
    group.add(label);
  });

  obliqueAsymptotes.forEach((o) => {
    const { a, b } = o;
    const xMin = graph2DParams.domain.xMin;
    const xMax = graph2DParams.domain.xMax;
    const points = [
      new THREE.Vector3(xMin, a * xMin + b, 0),
      new THREE.Vector3(xMax, a * xMax + b, 0),
    ];
    const mat = new THREE.LineDashedMaterial({
      color: 0x9900ff,
      dashSize: 1,
      gapSize: 2,
      linewidth: 2,
    });
    const geom = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geom, mat);
    line.computeLineDistances();
    group.add(line);

    // Nh√£n xi√™n
    const label = makeTextSprite(`y=${a.toFixed(2)}x+${b.toFixed(2)}`, {
      fontsize: 18,
      borderColor: { r: 153, g: 0, b: 255, a: 1 },
    });
    label.position.set(xMax, a * xMax + b, 0);
    group.add(label);
  });

  return group;
}
function addCriticalPoints3D(points) {
  const group = new THREE.Group();
  const sphereGeom = new THREE.SphereGeometry(0.15, 16, 16);
  const sphereMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  points.forEach((p) => {
    const sphere = new THREE.Mesh(sphereGeom, sphereMat);
    sphere.position.set(p.x, p.y, 0);
    group.add(sphere);

    // Th√™m nh√£n
    const label = makeTextSprite(`(${p.x.toFixed(2)},${p.y.toFixed(2)})`, {
      fontsize: 16,
      borderColor: { r: 255, g: 0, b: 0, a: 1 },
    });
    label.position.set(p.x, p.y + 0.3, 0);
    group.add(label);
  });
  return group;
}
function makeTextSprite(message, parameters = {}) {
  const fontface = parameters.fontface || "Arial";
  const fontsize = parameters.fontsize || 18;
  const borderThickness = parameters.borderThickness || 2;
  const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1 };
  const textColor = parameters.textColor || { r: 255, g: 255, b: 255, a: 1 };

  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.font = fontsize + "px " + fontface;

  // ƒëo k√≠ch th∆∞·ªõc text
  const metrics = context.measureText(message);
  const textWidth = metrics.width;

  context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
  context.fillText(message, borderThickness, fontsize + borderThickness);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
  const sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(textWidth / 30, fontsize / 30, 1); // t·ªâ l·ªá v·ª´a ph·∫£i
  return sprite;
}

let last2DGraph3D = null;

function plotGraph2D3D() {
  if (!worldGroup) return;

  // Xo√° ƒë·ªì th·ªã c≈©
  if (last2DGraph3D) {
    worldGroup.remove(last2DGraph3D);
    // Duy·ªát t·ª´ng object con ƒë·ªÉ dispose geometry/material n·∫øu c√≥
    last2DGraph3D.traverse((obj) => {
      if (obj.isMesh || obj.isLine) {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
      }
    });
    last2DGraph3D = null;
  }

  const input = graph2DParams.formula.trim();
  const exprStr = input.replace(/^y\s*=\s*/, "");
  const expr = math.compile(exprStr);

  const points = [];
  const { xMin, xMax, step } = graph2DParams.domain;
  const yValues = [];
  for (let x = xMin; x <= xMax + 1e-12; x += step) {
    let y;
    try {
      y = expr.evaluate({ x });
      if (!Number.isFinite(y) || Math.abs(y) > HUGE_THRESHOLD) {
        y = null; // coi l√† "kh√¥ng x√°c ƒë·ªãnh"
      }
    } catch {
      y = null;
    }

    if (y !== null) points.push(new THREE.Vector3(x, y, 0));
    yValues.push(y);
  }

  // T·∫°o Line3D
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0x33ff99 });
  const curve3D = new THREE.Line(geometry, material);

  // Ph√¢n t√≠ch ƒë·ªì th·ªã
  const analysis = analyzeGraph2D(
    exprStr,
    expr,
    points.map((p) => p.x),
    yValues
  );

  // Nh√≥m c√°c layer
  const group = new THREE.Group();
  group.add(curve3D);
  group.add(
    addAsymptotes3D(analysis.verticalAsymptotes, analysis.obliqueAsymptotes)
  );
  group.add(addCriticalPoints3D(analysis.criticalPoints));

  worldGroup.add(group);
  last2DGraph3D = group;

  if (points.length > 0) moveCameraTo(points);
}

guiGraph2D.add(graph2DParams, "help").name("‚ùì Tr·ª£ gi√∫p");

// ‚úÖ T·∫°o canvas
const canvasWrapper = document.createElement("div");
canvasWrapper.style.width = "100%";
canvasWrapper.style.height = "260px";
canvasWrapper.style.padding = "10px";
const canvasGraph2D = document.createElement("canvas");
canvasGraph2D.id = "graph2D";
canvasWrapper.appendChild(canvasGraph2D);
guiGraph2D.domElement.appendChild(canvasWrapper);

// ‚úÖ Th√™m khung hi·ªÉn th·ªã k·∫øt qu·∫£
const analysisBox = document.createElement("div");
analysisBox.style.width = "100%";
analysisBox.style.minHeight = "140px";
analysisBox.style.overflowY = "auto";
analysisBox.style.background = "#1a1a1a";
analysisBox.style.color = "#eee";
analysisBox.style.fontSize = "13px";
analysisBox.style.padding = "10px";
analysisBox.style.marginTop = "10px";
analysisBox.style.border = "1px solid #333";
analysisBox.style.borderRadius = "8px";
analysisBox.style.lineHeight = "1.5";
analysisBox.innerHTML =
  "<div style='color:#888'>üìä Ch∆∞a c√≥ k·∫øt qu·∫£ kh·∫£o s√°t.</div>";
guiGraph2D.domElement.appendChild(analysisBox);

// ==== Tham s·ªë n·ªôi b·ªô (c√≥ th·ªÉ t√πy ch·ªânh) ====
const HUGE_THRESHOLD = 1e8; // n·∫øu |y| > ng∆∞·ª°ng n√†y coi nh∆∞ "v√¥ h·∫°n"
const JUMP_MULTIPLIER = 1e3; // n·∫øu delta l·ªõn h∆°n maxAbs * JUMP_MULTIPLIER => coi l√† nh·∫£y l·ªõn
const REFINE_ITERS = 35; // l·∫ßn l·∫∑p t·ªëi ƒëa khi refine v·ªã tr√≠ ti·ªám c·∫≠n
const REFINE_TOL = 1e-7; // ƒë·ªô ch√≠nh x√°c refine

// ===== H√†m v·∫Ω ƒë·ªì th·ªã (thay th·∫ø) =====
function plotGraph2D() {
  const input = graph2DParams.formula.trim();
  if (!/^y\s*=/.test(input)) {
    alert("C√¥ng th·ª©c ph·∫£i c√≥ d·∫°ng: y = f(x)");
    return;
  }
  const exprStr = input.replace(/^y\s*=\s*/, "");
  let expr;
  try {
    expr = math.compile(exprStr);
  } catch (e) {
    alert("Sai c√¥ng th·ª©c: " + e.message);
    return;
  }

  const xValues = [];
  const yValues = [];
  for (
    let x = graph2DParams.domain.xMin;
    x <= graph2DParams.domain.xMax + 1e-12;
    x += graph2DParams.domain.step
  ) {
    xValues.push(+x.toFixed(12)); // tr√°nh l·ªói s·ªë th·ª±c
    try {
      const y = expr.evaluate({ x });
      // coi nh∆∞ "kh√¥ng h·ªØu h·∫°n" khi s·ªë b·ªã Infinity, NaN, ho·∫∑c qu√° l·ªõn
      if (!Number.isFinite(y) || Math.abs(y) > HUGE_THRESHOLD) {
        yValues.push(null);
      } else {
        yValues.push(y);
      }
    } catch {
      // l·ªói khi evaluate -> coi nh∆∞ ti·ªám c·∫≠n (null)
      yValues.push(null);
    }
  }

  const analysis = analyzeGraph2D(exprStr, expr, xValues, yValues);

  // T·∫°o annotations: tr·ª•c, c·ª±c tr·ªã, ti·ªám c·∫≠n
  const annotations = {
    axisX: {
      type: "line",
      yMin: 0,
      yMax: 0,
      borderColor: "#666",
      borderWidth: 1.2,
    },
    axisY: {
      type: "line",
      xMin: 0,
      xMax: 0,
      borderColor: "#666",
      borderWidth: 1.2,
    },
    // c·ª±c tr·ªã
    ...analysis.criticalPoints.reduce((acc, p, i) => {
      acc[`critPoint${i}`] = {
        type: "point",
        xValue: p.x,
        yValue: p.y,
        backgroundColor: "red",
        radius: 5,
      };
      acc[`critVLine${i}`] = {
        type: "line",
        xMin: p.x,
        xMax: p.x,
        yMin: 0,
        yMax: p.y,
        borderColor: "red",
        borderDash: [6, 6],
        borderWidth: 1,
      };
      acc[`critHLine${i}`] = {
        type: "line",
        yMin: p.y,
        yMax: p.y,
        xMin: 0,
        xMax: p.x,
        borderColor: "red",
        borderDash: [6, 6],
        borderWidth: 1,
      };
      return acc;
    }, {}),
    // ti·ªám c·∫≠n ƒë·ª©ng
    ...analysis.verticalAsymptotes.reduce((acc, x, i) => {
      acc[`asym${i}`] = {
        type: "line",
        xMin: x,
        xMax: x,
        borderColor: "orange",
        borderWidth: 2,
        borderDash: [6, 6],
        label: {
          display: true,
          content: `x=${x.toFixed(3)}`,
          position: "start", // c√≥ th·ªÉ th·ª≠ "end" ho·∫∑c "center"
          color: "orange",
          backgroundColor: "rgba(0,0,0,0.5)",
        },
      };
      return acc;
    }, {}),

    // ti·ªám c·∫≠n xi√™n
    ...analysis.obliqueAsymptotes.reduce((acc, obj, i) => {
      const { a, b, side } = obj;
      const xStart = graph2DParams.domain.xMin;
      const xEnd = graph2DParams.domain.xMax;
      acc[`oblique${i}`] = {
        type: "line",
        xMin: xStart,
        xMax: xEnd,
        yMin: a * xStart + b,
        yMax: a * xEnd + b,
        borderColor: "purple",
        borderWidth: 2,
        borderDash: [8, 6],
        label: {
          display: true,
          content: `y=${a.toFixed(3)}x+${b.toFixed(3)} (${side})`,
          position: "end",
          color: "purple",
          backgroundColor: "rgba(0,0,0,0.5)",
        },
      };
      return acc;
    }, {}),
  };

  // H·ªßy ƒë·ªì th·ªã c≈© n·∫øu c√≥
  if (window.chart2D) window.chart2D.destroy();
  const ctx = canvasGraph2D.getContext("2d");
  window.chart2D = new Chart(ctx, {
    type: "line",
    data: {
      labels: xValues,
      datasets: [
        {
          label: input,
          data: yValues,
          borderColor: "rgb(75, 192, 192)",
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
          spanGaps: false, // KH√îNG n·ªëi qua null (ƒë·∫£m b·∫£o chia ƒëo·∫°n t·∫°i ti·ªám c·∫≠n)
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { type: "linear", title: { display: true, text: "x" } },
        y: { title: { display: true, text: "y" } },
      },
      plugins: {
        annotation: { annotations },
        zoom: {
          pan: { enabled: true, mode: "xy" },
          zoom: {
            wheel: { enabled: true },
            pinch: { enabled: true },
            mode: "xy",
          },
        },
      },
    },
  });

  // C·∫≠p nh·∫≠t box k·∫øt qu·∫£ (giao di·ªán d·∫°ng b·∫£ng)
  let msg = `
<h4 style="margin:0 0 8px;color:#0ff">üìä K·∫øt qu·∫£ kh·∫£o s√°t</h4>
<table style="width:100%;border-collapse:collapse;font-size:14px">
  <tr>
    <td style="border:1px solid #0ff;padding:4px">‚úèÔ∏è <b>ƒê·∫°o h√†m f'(x)</b></td>
    <td style="border:1px solid #0ff;padding:4px;color:#0f0"><code>${
      analysis.derivative
    }</code></td>
  </tr>
  <tr>
    <td style="border:1px solid #0ff;padding:4px">üîº <b>GTLN (‚âà)</b></td>
    <td style="border:1px solid #0ff;padding:4px;color:#ff0">${
      analysis.yMax
    }</td>
  </tr>
  <tr>
    <td style="border:1px solid #0ff;padding:4px">üîΩ <b>GTNN (‚âà)</b></td>
    <td style="border:1px solid #0ff;padding:4px;color:#ff0">${
      analysis.yMin
    }</td>
  </tr>
  <tr>
    <td style="border:1px solid #0ff;padding:4px">üéØ <b>C·ª±c tr·ªã (‚âà)</b></td>
    <td style="border:1px solid #0ff;padding:4px;color:#f88">
      ${
        analysis.criticalPoints.length > 0
          ? analysis.criticalPoints
              .map((p) => `(${p.x.toFixed(4)}, ${p.y.toFixed(4)})`)
              .join(", ")
          : "Kh√¥ng c√≥"
      }
    </td>
  </tr>
  ${
    analysis.verticalAsymptotes.length > 0
      ? `
        <tr>
          <td style="border:1px solid #0ff;padding:4px">üìê <b>Ti·ªám c·∫≠n ƒë·ª©ng</b></td>
          <td style="border:1px solid #0ff;padding:4px;color:#0af">
            ${analysis.verticalAsymptotes
              .map((x) => `x = ${x.toFixed(6)}`)
              .join(", ")}
          </td>
        </tr>`
      : ""
  }
  ${
    analysis.obliqueAsymptotes.length > 0
      ? `
        <tr>
          <td style="border:1px solid #0ff;padding:4px">üìê <b>Ti·ªám c·∫≠n xi√™n</b></td>
          <td style="border:1px solid #0ff;padding:4px;color:#a6f">
            ${analysis.obliqueAsymptotes
              .map(
                (obj) =>
                  `y = ${obj.a.toFixed(3)}x + ${obj.b.toFixed(3)} (${obj.side})`
              )
              .join("<br>")}
          </td>
        </tr>`
      : ""
  }
</table>
`;
  analysisBox.innerHTML = msg;
}

// ===== Ph√¢n t√≠ch ƒë·ªì th·ªã (c·∫≠p nh·∫≠t) =====
function analyzeGraph2D(exprStr, expr, xValues, yValues) {
  // Derivative
  let derivative;
  try {
    derivative = math.derivative(exprStr, "x");
  } catch {
    derivative = null;
  }

  // T√≠nh f'(x) tr√™n l∆∞·ªõi (n·∫øu c√≥)
  const dValues = derivative
    ? xValues.map((x) => {
        try {
          const v = derivative.evaluate({ x });
          return Number.isFinite(v) ? v : null;
        } catch {
          return null;
        }
      })
    : xValues.map((_) => null);

  // T√¨m c·ª±c tr·ªã
  const criticalPoints = [];
  for (let i = 1; i < dValues.length; i++) {
    const d0 = dValues[i - 1],
      d1 = dValues[i];
    if (d0 === null || d1 === null) continue;
    if (d0 * d1 <= 0) {
      const x0 = (xValues[i - 1] + xValues[i]) / 2;
      try {
        const y0 = expr.evaluate({ x: x0 });
        if (Number.isFinite(y0)) criticalPoints.push({ x: x0, y: y0 });
      } catch {}
    }
  }

  // GTLN, GTNN
  const finiteY = yValues.filter((v) => v !== null && Number.isFinite(v));
  const yMin = finiteY.length ? Math.min(...finiteY) : null;
  const yMax = finiteY.length ? Math.max(...finiteY) : null;

  // Ph√°t hi·ªán ti·ªám c·∫≠n ƒë·ª©ng
  const verticalAsymptotes = [];
  for (let i = 1; i < yValues.length; i++) {
    const y0 = yValues[i - 1],
      y1 = yValues[i];
    const x0 = xValues[i - 1],
      x1 = xValues[i];
    if ((y0 === null && y1 !== null) || (y0 !== null && y1 === null)) {
      const approx = refineAsymptoteIfPossible(expr, x0, x1);
      verticalAsymptotes.push(approx);
    }
  }
  const uniqAsym = uniqueApprox(verticalAsymptotes, 1e-6);

  // üëâ Ti·ªám c·∫≠n xi√™n
  function obliqueAsymptote(side = "right") {
    try {
      const sampleXs =
        side === "right"
          ? xValues.slice(-20) // 20 ƒëi·ªÉm cu·ªëi
          : xValues.slice(0, 20); // 20 ƒëi·ªÉm ƒë·∫ßu
      const sampleYs = sampleXs.map((x) => expr.evaluate({ x }));
      if (sampleYs.some((y) => !Number.isFinite(y))) return null;
      // Fit tuy·∫øn t√≠nh y ‚âà ax+b
      const n = sampleXs.length;
      const sumX = sampleXs.reduce((a, b) => a + b, 0);
      const sumY = sampleYs.reduce((a, b) => a + b, 0);
      const sumXY = sampleXs.reduce((a, b, i) => a + b * sampleYs[i], 0);
      const sumX2 = sampleXs.reduce((a, b) => a + b * b, 0);
      const a = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const b = (sumY - a * sumX) / n;
      // ki·ªÉm tra: n·∫øu a ‚âà 0 coi nh∆∞ ti·ªám c·∫≠n ngang
      if (Math.abs(a) < 1e-6) return null;
      return { a, b, side };
    } catch {
      return null;
    }
  }

  const oblique = [];
  const leftAsym = obliqueAsymptote("left");
  if (leftAsym) oblique.push(leftAsym);
  const rightAsym = obliqueAsymptote("right");
  if (rightAsym) oblique.push(rightAsym);

  return {
    derivative: derivative ? derivative.toString() : "‚Äî",
    criticalPoints,
    yMin,
    yMax,
    verticalAsymptotes: uniqAsym,
    obliqueAsymptotes: oblique,
  };
}

// ===== Helper: refine v·ªã tr√≠ ti·ªám c·∫≠n b·∫±ng chia ƒë√¥i (n·∫øu c√≥ th·ªÉ) =====
function refineAsymptoteIfPossible(expr, a, b) {
  // ƒë·∫£m b·∫£o a < b
  if (a > b) {
    const t = a;
    a = b;
    b = t;
  }
  let left = a,
    right = b;

  // cap v√†o v√πng ƒë·ªì th·ªã hi·ªán t·∫°i n·∫øu qu√° r·ªông
  const span = Math.max(1e-12, right - left);

  // n·∫øu kho·∫£ng qu√° nh·ªè th√¨ tr·∫£ v·ªÅ midpoint
  if (Math.abs(right - left) < REFINE_TOL) return (left + right) / 2;

  // x√°c ƒë·ªãnh tr·∫°ng th√°i ƒë·∫ßu: finite hay not
  function evalSafe(x) {
    try {
      const v = expr.evaluate({ x });
      return Number.isFinite(v) && Math.abs(v) <= HUGE_THRESHOLD
        ? { finite: true, v }
        : { finite: false, v: null };
    } catch {
      return { finite: false, v: null };
    }
  }

  // N·∫øu c·∫£ 2 ƒë·∫ßu ƒë·ªÅu finite th√¨ v·∫´n th·ª≠ refine n·∫øu jump l·ªõn
  let leftState = evalSafe(left),
    rightState = evalSafe(right);

  // l·∫∑p chia ƒë√¥i, t√¨m ƒëi·ªÉm chuy·ªÉn finite -> not finite
  for (let it = 0; it < REFINE_ITERS; it++) {
    const mid = (left + right) / 2;
    const midState = evalSafe(mid);
    // N·∫øu mid kh√¥ng finite => ti·ªám c·∫≠n g·∫ßn mid, thu h·∫πp v·ªÅ ph√≠a mid
    if (!midState.finite) {
      // n·∫øu left finite th√¨ move right to mid, ng∆∞·ª£c l·∫°i move left to mid
      if (leftState.finite) {
        right = mid;
        rightState = midState;
      } else {
        left = mid;
        leftState = midState;
      }
    } else {
      // mid finite -> c·∫ßn t√¨m ph√≠a c√≤n l·∫°i kh√¥ng finite
      // n·∫øu left kh√¥ng finite th√¨ move right to mid; n·∫øu right kh√¥ng finite move left to mid
      if (!leftState.finite) {
        left = mid;
        leftState = midState;
      } else if (!rightState.finite) {
        right = mid;
        rightState = midState;
      } else {
        // c·∫£ 2 ph√≠a ƒë·ªÅu finite (tr∆∞·ªùng h·ª£p jump nh∆∞ng c·∫£ hai finite): thu h·∫πp theo gradient (ch·ªçn ph√≠a c√≥ |y| l·ªõn h∆°n)
        const leftY = leftState.v,
          rightY = rightState.v;
        if (Math.abs(leftY) > Math.abs(rightY)) {
          right = mid;
          rightState = midState;
        } else {
          left = mid;
          leftState = midState;
        }
      }
    }
    if (Math.abs(right - left) < Math.max(REFINE_TOL, span * 1e-6)) break;
  }
  return (left + right) / 2;
}

// ===== Helper: lo·∫°i b·ªè ph·∫ßn t·ª≠ g·∫ßn nhau (approx unique) =====
function uniqueApprox(arr, tol = 1e-8) {
  if (!arr || arr.length === 0) return [];
  const sorted = arr.slice().sort((a, b) => a - b);
  const out = [sorted[0]];
  for (let i = 1; i < sorted.length; i++) {
    if (Math.abs(sorted[i] - out[out.length - 1]) > tol) out.push(sorted[i]);
  }
  return out;
}

// ----- M·∫∑t ph·∫≥ng & ƒê∆∞·ªùng th·∫≥ng -----
const geometryParams = {
  planes: [], // danh s√°ch ph∆∞∆°ng tr√¨nh d·∫°ng text
  planeEquations: [], // danh s√°ch h·ªá s·ªë {a,b,c,d}

  // h·ªá s·ªë nh·∫≠p t·ª´ GUI
  a: 1,
  b: 0,
  c: 0,
  d: 0,

  addPlane: () => {
    const { a, b, c, d } = geometryParams;
    const eq = `${a}x + ${b}y + ${c}z + ${d} = 0`;

    geometryParams.planes.push(eq);
    geometryParams.planeEquations.push({ a, b, c, d });

    updatePlaneList();

    // v·∫Ω m·∫∑t ph·∫≥ng
    drawPlaneFromParams(a, b, c, d);

    if (typeof historyParams !== "undefined") {
      historyParams.addEntry(`‚ûï Th√™m m·∫∑t ph·∫≥ng: ${eq}`);
    }
  },

  plane1: null,
  plane2: null,

  findIntersection: () => {
    const i1 = geometryParams.planes.indexOf(geometryParams.plane1);
    const i2 = geometryParams.planes.indexOf(geometryParams.plane2);

    if (i1 < 0 || i2 < 0 || i1 === i2) {
      alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn hai m·∫∑t ph·∫≥ng kh√°c nhau");
      return;
    }

    const p1 = geometryParams.planeEquations[i1];
    const p2 = geometryParams.planeEquations[i2];

    intersectPlanes(p1, p2);

    if (typeof historyParams !== "undefined") {
      historyParams.addEntry(
        `üìå Giao tuy·∫øn: ${geometryParams.plane1} ‚à© ${geometryParams.plane2}`
      );
    }
  },

  v1: [1, 0, 0],
  v2: [0, 1, 0],

  checkRelation: () => {
    const [x1, y1, z1] = geometryParams.v1;
    const [x2, y2, z2] = geometryParams.v2;
    const dot = x1 * x2 + y1 * y2 + z1 * z2;
    const cross = [y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2];
    let result = "‚ö™ T·ªïng qu√°t";
    if (dot === 0) result = "‚üÇ Vu√¥ng g√≥c";
    else if (cross.every((v) => v === 0)) result = "‚à• Song song";

    document.getElementById("checkResult").innerText = "K·∫øt qu·∫£: " + result;

    if (typeof historyParams !== "undefined") {
      historyParams.addEntry(`üîé Quan h·ªá vector: ${result}`);
    }
  },
};

// --- T·∫°o GUI ---
const guiGeometry = guiHelper.addTab("M·∫∑t ph·∫≥ng & ƒê∆∞·ªùng th·∫≥ng", 350, {
  icon: "üìê",
  label: "M·∫∑t ph·∫≥ng & ƒê∆∞·ªùng th·∫≥ng",
});

// nh·∫≠p h·ªá s·ªë m·∫∑t ph·∫≥ng
guiGeometry.add(geometryParams, "a", -10, 10, 0.1).name("H·ªá s·ªë a");
guiGeometry.add(geometryParams, "b", -10, 10, 0.1).name("H·ªá s·ªë b");
guiGeometry.add(geometryParams, "c", -10, 10, 0.1).name("H·ªá s·ªë c");
guiGeometry.add(geometryParams, "d", -10, 10, 0.1).name("H·ªá s·ªë d");

// n√∫t th√™m m·∫∑t ph·∫≥ng
guiGeometry.add(geometryParams, "addPlane").name("‚ûï Th√™m m·∫∑t ph·∫≥ng");

// ch·ªçn 2 m·∫∑t ph·∫≥ng
guiGeometry
  .add(geometryParams, "plane1", geometryParams.planes)
  .name("M·∫∑t ph·∫≥ng 1");
guiGeometry
  .add(geometryParams, "plane2", geometryParams.planes)
  .name("M·∫∑t ph·∫≥ng 2");

// t√¨m giao tuy·∫øn
guiGeometry.add(geometryParams, "findIntersection").name("üìå Giao tuy·∫øn");

// --- Vector checker ---
const fVec = guiGeometry.addFolder("üéØ Vector Checker");
fVec.add(geometryParams.v1, 0, -10, 10, 1).name("v1.x");
fVec.add(geometryParams.v1, 1, -10, 10, 1).name("v1.y");
fVec.add(geometryParams.v1, 2, -10, 10, 1).name("v1.z");
fVec.add(geometryParams.v2, 0, -10, 10, 1).name("v2.x");
fVec.add(geometryParams.v2, 1, -10, 10, 1).name("v2.y");
fVec.add(geometryParams.v2, 2, -10, 10, 1).name("v2.z");
fVec.add(geometryParams, "checkRelation").name("Ki·ªÉm tra quan h·ªá");
// ----- Th√™m n√∫t Tr·ª£ gi√∫p -----
geometryParams.help = () => {
  alert(
    `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab M·∫∑t ph·∫≥ng & ƒê∆∞·ªùng th·∫≥ng:

‚ûï Th√™m m·∫∑t ph·∫≥ng:
- Nh·∫≠p c√°c h·ªá s·ªë a, b, c, d ƒë·ªÉ ƒë·ªãnh nghƒ©a ph∆∞∆°ng tr√¨nh m·∫∑t ph·∫≥ng d·∫°ng:
  ax + by + cz + d = 0
- Sau ƒë√≥ b·∫•m "‚ûï Th√™m m·∫∑t ph·∫≥ng" ƒë·ªÉ th√™m v√†o danh s√°ch v√† hi·ªÉn th·ªã trong kh√¥ng gian 3D.

üìå Giao tuy·∫øn:
- Ch·ªçn 2 m·∫∑t ph·∫≥ng t·ª´ danh s√°ch "M·∫∑t ph·∫≥ng 1" v√† "M·∫∑t ph·∫≥ng 2".
- B·∫•m "üìå Giao tuy·∫øn" ƒë·ªÉ hi·ªÉn th·ªã ƒë∆∞·ªùng th·∫≥ng giao tuy·∫øn c·ªßa ch√∫ng (n·∫øu t·ªìn t·∫°i).

üéØ Vector Checker:
- Nh·∫≠p t·ªça ƒë·ªô cho hai vector v1 v√† v2.
- B·∫•m "Ki·ªÉm tra quan h·ªá" ƒë·ªÉ xem ch√∫ng c√≥ quan h·ªá g√¨:
  ‚üÇ Vu√¥ng g√≥c, ‚à• Song song, hay ‚ö™ T·ªïng qu√°t.

üëâ B·∫°n c√≥ th·ªÉ th√™m nhi·ªÅu m·∫∑t ph·∫≥ng, ki·ªÉm tra giao tuy·∫øn, v√† so s√°nh vector ƒë·ªÉ tr·ª±c quan h√≥a c√°c ƒë·ªëi t∆∞·ª£ng h√¨nh h·ªçc 3D.
`
  );
};

// G·∫Øn n√∫t v√†o GUI
guiGeometry.add(geometryParams, "help").name("‚ùì Tr·ª£ gi√∫p");

// --- C·∫≠p nh·∫≠t danh s√°ch m·∫∑t ph·∫≥ng ---
function updatePlaneList() {
  const planeSelect1 = guiGeometry.__controllers.find(
    (c) => c.property === "plane1"
  );
  const planeSelect2 = guiGeometry.__controllers.find(
    (c) => c.property === "plane2"
  );
  if (planeSelect1 && planeSelect2) {
    planeSelect1.options(geometryParams.planes);
    planeSelect2.options(geometryParams.planes);
  }
}

// --- H√†m v·∫Ω m·∫∑t ph·∫≥ng ---
function drawPlaneFromParams(a, b, c, d) {
  const geometry = new THREE.PlaneGeometry(100, 100);
  const normal = new THREE.Vector3(a, b, c).normalize();
  const center = normal.clone().multiplyScalar(-d / normal.lengthSq());

  const material = new THREE.MeshStandardMaterial({
    color: Math.random() * 0xffffff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.4,
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(center);
  mesh.lookAt(center.clone().add(normal));
  worldGroup.add(mesh);
}

// --- H√†m t√≠nh giao tuy·∫øn 2 m·∫∑t ph·∫≥ng ---
function intersectPlanes(p1, p2) {
  const n1 = new THREE.Vector3(p1.a, p1.b, p1.c);
  const n2 = new THREE.Vector3(p2.a, p2.b, p2.c);
  const dir = new THREE.Vector3().crossVectors(n1, n2);

  if (dir.length() < 1e-6) {
    alert("‚ö†Ô∏è Hai m·∫∑t ph·∫≥ng song song ho·∫∑c tr√πng nhau (kh√¥ng c√≥ giao tuy·∫øn)");
    return;
  }

  const A = new THREE.Matrix3();
  A.set(p1.a, p1.b, p1.c, p2.a, p2.b, p2.c, dir.x, dir.y, dir.z);

  const D = new THREE.Vector3(-p1.d, -p2.d, 0);
  const Ainv = A.clone().invert();

  if (!Ainv) {
    alert("‚ö†Ô∏è Kh√¥ng t√¨m ƒë∆∞·ª£c ƒëi·ªÉm giao");
    return;
  }

  const point = D.applyMatrix3(Ainv);

  const points = [];
  for (let t = -50; t <= 50; t += 1) {
    const pt = point.clone().add(dir.clone().normalize().multiplyScalar(t));
    points.push(pt);
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
  const line = new THREE.Line(geometry, material);
  worldGroup.add(line);
}

// ----- ƒê·∫°o h√†m -----
const derivativeParams = {
  formula: "z = x^2 + y^2",
  mode: "surface",
  resolution: 50,

  // ph·∫°m vi m·∫∑c ƒë·ªãnh
  xMin: -5,
  xMax: 5,
  yMin: -5,
  yMax: 5,
  derivativeText: "K·∫øt qu·∫£ ƒë·∫°o h√†m s·∫Ω hi·ªán ·ªü ƒë√¢y",
  plotSurfa: () =>
    plotSurface({
      formula: derivativeParams.formula,
      mode: derivativeParams.mode,
      resolution: derivativeParams.resolution,
      xMin: derivativeParams.xMin,
      xMax: derivativeParams.xMax,
      yMin: derivativeParams.yMin,
      yMax: derivativeParams.yMax,
    }),

  compute: () => computeDerivatives(),
  plotDx: () => plotDerivative("dx"),
  plotDy: () => plotDerivative("dy"),
  plotDx2: () => plotDerivative("dx2"),
  plotDy2: () => plotDerivative("dy2"),
  plotDxDy: () => plotDerivative("dxdy"),
};

let derivatives = {};

const guiDerivative = guiHelper.addTab("ƒê·∫°o h√†m", 350, {
  icon: "ùëë/dx",
  label: "ƒê·∫°o h√†m",
});
guiDerivative.add(derivativeParams, "formula").name("C√¥ng th·ª©c");
guiDerivative
  .add(derivativeParams, "mode", ["surface", "line"])
  .name("Ch·∫ø ƒë·ªô hi·ªÉn th·ªã");
guiDerivative
  .add(derivativeParams, "resolution", 10, 200, 1)
  .name("ƒê·ªô ph√¢n gi·∫£i");

// üëá th√™m group nh·∫≠p ph·∫°m vi
const fRange = guiDerivative.addFolder("üìê Ph·∫°m vi");
fRange.add(derivativeParams, "xMin", -50, 0, 0.1).name("x Min");
fRange.add(derivativeParams, "xMax", 0, 50, 0.1).name("x Max");
fRange.add(derivativeParams, "yMin", -50, 0, 0.1).name("y Min");
fRange.add(derivativeParams, "yMax", 0, 50, 0.1).name("y Max");

guiDerivative.add(derivativeParams, "plotSurfa").name("üßÆ V·∫Ω ƒë·ªì th·ªã");
// ‚úÖ T·∫°o box hi·ªÉn th·ªã k·∫øt qu·∫£ ƒë·∫°o h√†m, ·∫©n m·∫∑c ƒë·ªãnh
const derivativeWrapper = document.createElement("div");
derivativeWrapper.style.width = "100%";
derivativeWrapper.style.minHeight = "150px";
derivativeWrapper.style.padding = "10px";
derivativeWrapper.style.marginTop = "8px";
derivativeWrapper.style.background = "#111";
derivativeWrapper.style.color = "#0f0";
derivativeWrapper.style.fontFamily = "monospace";
derivativeWrapper.style.fontSize = "12px";
derivativeWrapper.style.borderRadius = "6px";
derivativeWrapper.style.display = "none"; // üëà ·∫©n m·∫∑c ƒë·ªãnh

const derivativeBox = document.createElement("pre");
derivativeBox.style.whiteSpace = "pre-wrap";
derivativeBox.style.wordBreak = "break-word";
derivativeBox.textContent = derivativeParams.derivativeText;

derivativeWrapper.appendChild(derivativeBox);
guiDerivative.domElement.appendChild(derivativeWrapper);

// ‚úÖ N√∫t t√≠nh ƒë·∫°o h√†m ‚Üí hi·ªán box + c·∫≠p nh·∫≠t n·ªôi dung
guiDerivative
  .add(derivativeParams, "compute")
  .name("üßÆ T√≠nh ƒë·∫°o h√†m")
  .onChange(() => {
    derivativeWrapper.style.display = "block"; // hi·ªán box
    computeDerivatives();
    derivativeBox.textContent = derivativeParams.derivativeText; // update text
  });

// Group hi·ªÉn th·ªã c√°c n√∫t v·∫Ω ƒë·∫°o h√†m
const fDeriv = guiDerivative.addFolder("‚úèÔ∏è V·∫Ω c√°c ƒë·∫°o h√†m");
fDeriv.add(derivativeParams, "plotDx").name("‚àÇz/‚àÇx");
fDeriv.add(derivativeParams, "plotDy").name("‚àÇz/‚àÇy");
fDeriv.add(derivativeParams, "plotDx2").name("‚àÇ¬≤z/‚àÇx¬≤");
fDeriv.add(derivativeParams, "plotDy2").name("‚àÇ¬≤z/‚àÇy¬≤");
fDeriv.add(derivativeParams, "plotDxDy").name("‚àÇ¬≤z/‚àÇx‚àÇy");
// ----- N√∫t Tr·ª£ gi√∫p -----
derivativeParams.help = () => {
  alert(
    `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab ƒê·∫°o h√†m:

‚úèÔ∏è C√¥ng th·ª©c:
- Nh·∫≠p c√¥ng th·ª©c d∆∞·ªõi d·∫°ng "z = f(x,y)".
- V√≠ d·ª•: z = x^2 + y^2 ho·∫∑c z = sin(x) * cos(y).

üñºÔ∏è Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:
- "surface": V·∫Ω b·ªÅ m·∫∑t 3D.
- "line": V·∫Ω ƒë∆∞·ªùng cong (1 bi·∫øn).

üî¢ ƒê·ªô ph√¢n gi·∫£i:
- Quy·∫øt ƒë·ªãnh s·ªë l∆∞·ª£ng ƒëi·ªÉm v·∫Ω. C√†ng cao th√¨ c√†ng m∆∞·ª£t nh∆∞ng t·ªën t√†i nguy√™n.

üìê Ph·∫°m vi:
- xMin, xMax, yMin, yMax: Kho·∫£ng gi√° tr·ªã v·∫Ω.
- step: b∆∞·ªõc l∆∞·ªõi (d√πng trong grid).

üßÆ V·∫Ω ƒë·ªì th·ªã:
- V·∫Ω ƒë·ªì th·ªã t·ª´ c√¥ng th·ª©c g·ªëc ƒë√£ nh·∫≠p.

üßÆ T√≠nh ƒë·∫°o h√†m:
- T·ª± ƒë·ªông t√≠nh ‚àÇz/‚àÇx, ‚àÇz/‚àÇy, ‚àÇ¬≤z/‚àÇx¬≤, ‚àÇ¬≤z/‚àÇy¬≤, ‚àÇ¬≤z/‚àÇx‚àÇy.
- K·∫øt qu·∫£ hi·ªán trong h·ªôp b√™n d∆∞·ªõi.

‚úèÔ∏è V·∫Ω c√°c ƒë·∫°o h√†m:
- ‚àÇz/‚àÇx: V·∫Ω ƒë·∫°o h√†m theo x.
- ‚àÇz/‚àÇy: V·∫Ω ƒë·∫°o h√†m theo y.
- ‚àÇ¬≤z/‚àÇx¬≤, ‚àÇ¬≤z/‚àÇy¬≤: V·∫Ω ƒë·∫°o h√†m b·∫≠c 2.
- ‚àÇ¬≤z/‚àÇx‚àÇy: V·∫Ω ƒë·∫°o h√†m h·ªón h·ª£p.

üëâ Quy tr√¨nh g·ª£i √Ω:
1. Nh·∫≠p c√¥ng th·ª©c z = f(x,y).
2. Nh·∫•n "üßÆ T√≠nh ƒë·∫°o h√†m".
3. Ch·ªçn c√°c n√∫t ‚àÇ ƒë·ªÉ v·∫Ω ƒë·∫°o h√†m t∆∞∆°ng ·ª©ng.
`
  );
};

// Th√™m n√∫t v√†o GUI
guiDerivative.add(derivativeParams, "help").name("‚ùì Tr·ª£ gi√∫p");

function computeDerivatives() {
  const expr = derivativeParams.formula.replace(/^z\s*=\s*/, "");
  try {
    const dz_dx = math.derivative(expr, "x").toString();
    const dz_dy = math.derivative(expr, "y").toString();
    const d2z_dx2 = math.derivative(dz_dx, "x").toString();
    const d2z_dy2 = math.derivative(dz_dy, "y").toString();
    const d2z_dxdy = math.derivative(dz_dx, "y").toString();
    const differential = `dz = (${dz_dx}) dx + (${dz_dy}) dy`;

    derivatives = {
      dx: dz_dx,
      dy: dz_dy,
      dx2: d2z_dx2,
      dy2: d2z_dy2,
      dxdy: d2z_dxdy,
    };

    derivativeParams.derivativeText = `
‚àÇz/‚àÇx = ${dz_dx}
‚àÇz/‚àÇy = ${dz_dy}
‚àÇ¬≤z/‚àÇx¬≤ = ${d2z_dx2}
‚àÇ¬≤z/‚àÇy¬≤ = ${d2z_dy2}
‚àÇ¬≤z/‚àÇx‚àÇy = ${d2z_dxdy}

${differential}
`.trim();
  } catch (err) {
    derivativeParams.derivativeText =
      "‚ùå L·ªói c√¥ng th·ª©c ho·∫∑c kh√¥ng th·ªÉ t√≠nh ƒë·∫°o h√†m.";
  }
}

function plotDerivative(key) {
  const formula = derivatives[key];
  if (!formula) {
    alert("‚ùó Vui l√≤ng nh·∫•n 'T√≠nh ƒê·∫°o H√†m' tr∆∞·ªõc.");
    return;
  }

  plotSurface({
    formula: "z = " + formula, // üëà truy·ªÅn ƒë·∫°o h√†m v√†o lu√¥n
    mode: derivativeParams.mode,
    resolution: derivativeParams.resolution,
    xMin: derivativeParams.xMin,
    xMax: derivativeParams.xMax,
    yMin: derivativeParams.yMin,
    yMax: derivativeParams.yMax,
  });
}

// ----- ƒê·ªì th·ªã c·ª±c -----
const polarParams = {
  // cho polar
  formula: "theta",
  sampleFormula: "",
  drawPolar: () => plotPolar(),

  // cho 3D
  xFormula: "cos(t)",
  yFormula: "sin(t)",
  zFormula: "t",
  sample3D: "",
  drawCustom: () => plotCustom3D(),

  tMin: 0,
  tMax: 10,
  step: 0.1,
};

// C√°c c√¥ng th·ª©c m·∫´u r = f(Œ∏)
const polarSamples = {
  "r = Œ∏": "theta",
  "r = 3Œ∏": "3 * theta",
  "r = ‚àöŒ∏": "sqrt(theta)",
  "r = Œ∏ * sin(Œ∏)": "theta * sin(theta)",
  "r = 10 * sin(3Œ∏)": "10 * sin(3 * theta)",
  "r = 5 + 2 * cos(4Œ∏)": "5 + 2 * cos(4 * theta)",
  "r = |4 * sin(2Œ∏)|": "abs(4 * sin(2 * theta))",
  "r = ‚àö|cos(2Œ∏)|": "sqrt(abs(cos(2 * theta)))",
  "Cardioid ‚ù§Ô∏è": "1 - sin(theta)",
  "Cardioid üíô": "1 + cos(theta)",
  "Hoa 5 c√°nh üå∏": "5 * sin(5 * theta)",
  "Hoa 7 c√°nh üåº": "7 * cos(7 * theta)",
  "Euler Special":
    "exp(cos(theta)) - 2 * cos(4 * theta) + pow(sin(theta/12), 5)",
};

// C√°c c√¥ng th·ª©c m·∫´u 3D
const polarSamples3D = {
  Helix: "x = cos(t); y = sin(t); z = t",
  "Parabol 3D": "x = t; y = t^2; z = t^3",
  "Sine + Cosine Wave": "x = t; y = sin(t); z = cos(t)",
  "Spiral Xo·∫Øn": "x = 10 * sin(t); y = 10 * cos(t); z = 0.5 * t",
  "Lissajous 3D": "x = sin(2*t); y = cos(3*t); z = sin(t)",
  "Archimedean Spiral": "x = t * cos(t); y = t * sin(t); z = t",
  "H√¨nh tr·ª©ng 3D": "x = sin(t) * cos(t); y = cos(t); z = sin(t)",
  "B√≥ hoa xo·∫Øn": "x = sin(t) * sqrt(abs(t)); y = cos(t) * sqrt(abs(t)); z = t",
};

// ---- GUI ----
const guiPolar = guiHelper.addTab("ƒê·ªì th·ªã c·ª±c", 350, {
  icon: "üåÄ",
  label: "ƒê·ªì th·ªã c·ª±c",
});

// C√¥ng th·ª©c r = f(Œ∏)
// T·∫°o controller ri√™ng ƒë·ªÉ c√≥ th·ªÉ update l·∫°i giao di·ªán
const formulaCtrl = guiPolar
  .add(polarParams, "formula")
  .name("C√¥ng th·ª©c r=f(Œ∏)");

guiPolar
  .add(polarParams, "sampleFormula", Object.keys(polarSamples))
  .name("üìå Ch·ªçn m·∫´u")
  .onChange((v) => {
    polarParams.formula = polarSamples[v];
    formulaCtrl.updateDisplay(); // ‚úÖ c·∫≠p nh·∫≠t l·∫°i GUI input
  });

guiPolar.add(polarParams, "drawPolar").name("üìà V·∫Ω ƒë·ªì th·ªã c·ª±c");

// C√¥ng th·ª©c 3D
const f3D = guiPolar.addFolder("üåÄ ƒê·ªì th·ªã tham s·ªë 3D");

const xCtrl = f3D.add(polarParams, "xFormula").name("x(t) = ");
const yCtrl = f3D.add(polarParams, "yFormula").name("y(t) = ");
const zCtrl = f3D.add(polarParams, "zFormula").name("z(t) = ");

f3D
  .add(polarParams, "sample3D", Object.keys(polarSamples3D))
  .name("üìå M·∫´u 3D")
  .onChange((v) => {
    const formula = polarSamples3D[v];
    const parts = formula.split(";");
    polarParams.xFormula = parts[0].split("=")[1].trim();
    polarParams.yFormula = parts[1].split("=")[1].trim();
    polarParams.zFormula = parts[2].split("=")[1].trim();

    // ‚úÖ update l·∫°i giao di·ªán
    xCtrl.updateDisplay();
    yCtrl.updateDisplay();
    zCtrl.updateDisplay();
  });

f3D.add(polarParams, "tMin", -50, 0, 1).name("t Min");
f3D.add(polarParams, "tMax", 1, 100, 1).name("t Max");
f3D.add(polarParams, "step", 0.01, 1, 0.01).name("B∆∞·ªõc Œît");
f3D.add(polarParams, "drawCustom").name("üé® V·∫Ω ƒë·ªì th·ªã 3D");
// ----- Th√™m n√∫t Tr·ª£ gi√∫p -----
polarParams.help = () => {
  alert(
    `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab ƒê·ªì th·ªã c·ª±c:

üìå ƒê·ªì th·ªã c·ª±c r = f(Œ∏):
- Nh·∫≠p c√¥ng th·ª©c r(Œ∏) v√†o √¥ "C√¥ng th·ª©c r=f(Œ∏)".
- C√≥ th·ªÉ ch·ªçn c√¥ng th·ª©c m·∫´u ·ªü "üìå Ch·ªçn m·∫´u".
- Nh·∫•n "üìà V·∫Ω ƒë·ªì th·ªã c·ª±c" ƒë·ªÉ hi·ªÉn th·ªã.

üåÄ ƒê·ªì th·ªã tham s·ªë 3D:
- Nh·∫≠p c√¥ng th·ª©c x(t), y(t), z(t) v√†o c√°c √¥ t∆∞∆°ng ·ª©ng.
- C√≥ th·ªÉ ch·ªçn c√¥ng th·ª©c m·∫´u ·ªü "üìå M·∫´u 3D" ƒë·ªÉ ƒëi·ªÅn nhanh.
- ƒêi·ªÅu ch·ªânh mi·ªÅn gi√° tr·ªã c·ªßa t b·∫±ng "t Min", "t Max" v√† b∆∞·ªõc "Œît".
- Nh·∫•n "üé® V·∫Ω ƒë·ªì th·ªã 3D" ƒë·ªÉ hi·ªÉn th·ªã.

‚öôÔ∏è L∆∞u √Ω:
- H·ªó tr·ª£ c√°c h√†m to√°n h·ªçc: sin, cos, tan, sqrt, abs, exp, pow...
- C√≥ th·ªÉ d√πng bi·∫øn Œ∏ (theta) cho ƒë·ªì th·ªã c·ª±c, ho·∫∑c bi·∫øn t cho ƒë·ªì th·ªã tham s·ªë 3D.
- N·∫øu c√¥ng th·ª©c kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu ƒëi·ªÉm, h·ªá th·ªëng s·∫Ω b√°o l·ªói.

üëâ B·∫°n c√≥ th·ªÉ k·∫øt h·ª£p nhi·ªÅu ƒë·ªì th·ªã ƒë·ªÉ quan s√°t v√† so s√°nh tr·ª±c quan.
`
  );
};

// G·∫Øn v√†o GUI
guiPolar.add(polarParams, "help").name("‚ùì Tr·ª£ gi√∫p");

// --- V·∫Ω ƒë·ªì th·ªã c·ª±c r = f(Œ∏) ---
let lastPolarGraph = null;

function plotPolar() {
  // Xo√° ƒë·ªì th·ªã c≈©
  if (lastPolarGraph) {
    worldGroup.remove(lastPolarGraph);
    lastPolarGraph.geometry.dispose();
    lastPolarGraph.material.dispose();
    lastPolarGraph = null;
  }

  let expr;
  try {
    expr = math.compile(polarParams.formula);
  } catch (e) {
    alert("C√¥ng th·ª©c kh√¥ng h·ª£p l·ªá: " + e.message);
    return;
  }

  const points = [];
  for (let i = 0; i <= 1000; i++) {
    const theta = (i / 1000) * Math.PI * 2;
    let r = 0;
    try {
      r = expr.evaluate({ theta });
    } catch (e) {}
    const x = r * Math.cos(theta);
    const y = r * Math.sin(theta);
    points.push(new THREE.Vector3(x, 0, y));
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0xff9933 });
  const polarCurve = new THREE.Line(geometry, material);

  worldGroup.add(polarCurve);
  lastPolarGraph = polarCurve;

  // Trong plotCustom3D()
  if (points.length > 0) {
    moveCameraTo(points);
  }
}

// --- V·∫Ω ƒë·ªì th·ªã tham s·ªë 3D ---
let customCurve = null;

function plotCustom3D() {
  let fx, fy, fz;
  try {
    fx = math.compile(polarParams.xFormula);
    fy = math.compile(polarParams.yFormula);
    fz = math.compile(polarParams.zFormula);
  } catch (e) {
    alert("L·ªói bi√™n d·ªãch c√¥ng th·ª©c: " + e.message);
    return;
  }

  if (customCurve) {
    worldGroup.remove(customCurve);
    customCurve.geometry.dispose();
    customCurve.material.dispose();
    customCurve = null;
  }

  const points = [];
  for (let t = polarParams.tMin; t <= polarParams.tMax; t += polarParams.step) {
    const ctx = { t, theta: t, u: t, v: t };
    try {
      const x = fx.evaluate(ctx);
      const y = fy.evaluate(ctx);
      const z = fz.evaluate(ctx);
      if (isFinite(x) && isFinite(y) && isFinite(z)) {
        points.push(new THREE.Vector3(x, y, z));
      }
    } catch {}
  }

  if (points.length < 2) {
    alert("Kh√¥ng ƒë·ªß ƒëi·ªÉm ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng cong 3D.");
    return;
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({ color: 0xff44aa });
  customCurve = new THREE.Line(geometry, material);
  worldGroup.add(customCurve);

  if (points.length > 0) {
    moveCameraTo(points);
  }
}

// ===== Tab GUI v·∫Ω minh h·ªça b·∫±ng click chu·ªôt =====
// ===== Th√™m ƒëi·ªÉm =====
const drawParams = {
  points: [],
  lines: [],
  selectedPoints: [],
  selectedLines: [],

  addPoint: (x = null, y = null, z = null) => {
    x = x ?? (Math.random() - 0.5) * 50;
    y = y ?? (Math.random() - 0.5) * 50;
    z = z ?? (Math.random() - 0.5) * 50;

    const geometry = new THREE.SphereGeometry(0.5, 16, 16);
    const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.set(x, y, z);
    worldGroup.add(sphere);

    const label = String.fromCharCode(65 + drawParams.points.length); // A, B, C...
    const labelSprite = createLabelSprite(label, "#ff0000");
    labelSprite.position.copy(
      sphere.position.clone().add(new THREE.Vector3(0, 3, 0))
    );

    const pointObj = { x, y, z, mesh: sphere, label, labelSprite };
    drawParams.points.push(pointObj);

    // GUI ƒëi·ªÉm
    const f = guiDraw.addFolder(`ƒêi·ªÉm ${label}`);
    f.add(pointObj, "x", -100, 100, 0.1)
      .name("X")
      .onChange((val) => {
        pointObj.mesh.position.x = val;
        pointObj.labelSprite.position.copy(
          pointObj.mesh.position.clone().add(new THREE.Vector3(0, 3, 0))
        );
        updateLinesConnected(pointObj);
      });
    f.add(pointObj, "y", -100, 100, 0.1)
      .name("Y")
      .onChange((val) => {
        pointObj.mesh.position.y = val;
        pointObj.labelSprite.position.copy(
          pointObj.mesh.position.clone().add(new THREE.Vector3(0, 3, 0))
        );
        updateLinesConnected(pointObj);
      });
    f.add(pointObj, "z", -100, 100, 0.1)
      .name("Z")
      .onChange((val) => {
        pointObj.mesh.position.z = val;
        pointObj.labelSprite.position.copy(
          pointObj.mesh.position.clone().add(new THREE.Vector3(0, 3, 0))
        );
        updateLinesConnected(pointObj);
      });

    f.open();
  },

  connectSelected: () => {
    if (drawParams.selectedPoints.length < 2) return;
    const p1 = drawParams.selectedPoints[0];
    const p2 = drawParams.selectedPoints[1];

    const geometry = new THREE.BufferGeometry().setFromPoints([
      p1.mesh.position.clone(),
      p2.mesh.position.clone(),
    ]);
    const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const lineMesh = new THREE.Line(geometry, material);
    worldGroup.add(lineMesh);

    const label = `${p1.label}${p2.label}`;
    const initialLength = p1.mesh.position.distanceTo(p2.mesh.position);
    const lengthSprite = createLabelSprite(initialLength.toFixed(2), "#00aa00");
    lengthSprite.position.copy(
      new THREE.Vector3()
        .addVectors(p1.mesh.position, p2.mesh.position)
        .multiplyScalar(0.5)
    );

    const lineObj = {
      line: lineMesh,
      p1,
      p2,
      _length: initialLength,
      label,
      lengthSprite,
      angleSprite: null,
    };
    drawParams.lines.push(lineObj);
    updateEdgeListGUI();
    // GUI ƒë∆∞·ªùng
    const fLine = guiDraw.addFolder(`ƒê∆∞·ªùng ${label}`);
    fLine
      .add(lineObj, "_length", 0, 200, 0.1)
      .name("Chi·ªÅu d√†i")
      .listen()
      .onChange((val) => {
        const dir = new THREE.Vector3()
          .subVectors(lineObj.p2.mesh.position, lineObj.p1.mesh.position)
          .normalize();
        lineObj.p2.mesh.position.copy(
          lineObj.p1.mesh.position.clone().add(dir.multiplyScalar(val))
        );
        updateLineGeometry(lineObj);
        updateAngles();
      });

    lineObj.angleGUI = fLine
      .add({ angle: 0 }, "angle")
      .name("G√≥c (¬∞)")
      .listen();
    fLine.open();

    drawParams.selectedPoints.forEach((p) =>
      p.mesh.material.color.set(0xff0000)
    );
    drawParams.selectedPoints = [];
  },

  clearAll: () => {
    drawParams.points.forEach((p) => {
      worldGroup.remove(p.mesh);
      worldGroup.remove(p.labelSprite);
    });
    drawParams.lines.forEach((l) => {
      worldGroup.remove(l.line);
      if (l.lengthSprite) worldGroup.remove(l.lengthSprite);
      if (l.angleSprite) worldGroup.remove(l.angleSprite);
    });
    drawParams.points = [];
    drawParams.lines = [];
    drawParams.selectedPoints = [];
    drawParams.selectedLines = [];
  },

  help: () => {
    alert(`üìñ H∆∞·ªõng d·∫´n:
1. "‚ûï Th√™m ƒëi·ªÉm": th√™m ƒëi·ªÉm ng·∫´u nhi√™n.
2. Click 2 ƒëi·ªÉm ƒë·ªÉ n·ªëi th√†nh ƒë∆∞·ªùng.
3. GUI ƒëi·ªÉm: c·∫≠p nh·∫≠t v·ªã tr√≠.
4. GUI ƒë∆∞·ªùng: ch·ªânh chi·ªÅu d√†i, xem g√≥c n·∫øu ch·ªçn 2 ƒë∆∞·ªùng chung 1 ƒëi·ªÉm.
5. Click ƒë∆∞·ªùng: ch·ªçn (m√†u v√†ng).
6. "üóëÔ∏è X√≥a t·∫•t c·∫£": x√≥a to√†n b·ªô.`);
  },
};

// ===== GUI =====
const guiDraw = guiHelper.addTab("V·∫Ω minh h·ªça", 350, {
  icon: "‚úèÔ∏è",
  label: "V·∫Ω minh h·ªça",
});
guiDraw.add(drawParams, "addPoint").name("‚ûï Th√™m ƒëi·ªÉm");
guiDraw.add(drawParams, "clearAll").name("üóëÔ∏è X√≥a t·∫•t c·∫£");
// ===== Th√™m tr·∫°ng th√°i hi·ªÉn th·ªã d·∫°ng checkbox =====
drawParams.showValues = true; // m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã

// ===== Th√™m checkbox trong GUI =====
guiDraw
  .add(drawParams, "showValues")
  .name("Hi·ªÉn th·ªã gi√° tr·ªã")
  .onChange((val) => {
    // C·∫≠p nh·∫≠t nh√£n ƒë·ªô d√†i v√† g√≥c
    drawParams.lines.forEach((l) => {
      if (l.lengthSprite) l.lengthSprite.visible = val;
      if (l.angleSprite) l.angleSprite.visible = val;
    });
  });
const edgeTab = guiHelper.addTab("C·∫°nh", 250, {
  icon: "üõ†Ô∏è",
  label: "C·∫°nh & Trung ƒëi·ªÉm",
});
function createPerpendicularPoint(point, lineObj) {
  const p = point.mesh.position;
  const a = lineObj.p1.mesh.position;
  const b = lineObj.p2.mesh.position;

  const ab = new THREE.Vector3().subVectors(b, a);
  const ap = new THREE.Vector3().subVectors(p, a);

  // Chi·∫øu AP l√™n AB
  const t = ap.dot(ab) / ab.lengthSq();
  const proj = a.clone().add(ab.multiplyScalar(t));

  // T·∫°o ƒëi·ªÉm vu√¥ng g√≥c
  drawParams.addPoint(proj.x, proj.y, proj.z);

  // V·∫Ω ƒë∆∞·ªùng vu√¥ng g√≥c t·ª´ point ƒë·∫øn ƒëi·ªÉm vu√¥ng g√≥c
  const geometry = new THREE.BufferGeometry().setFromPoints([
    p.clone(),
    proj.clone(),
  ]);
  const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
  const line = new THREE.Line(geometry, material);
  worldGroup.add(line);
}

function updateEdgeListGUI() {
  // X√≥a folder c≈© n·∫øu c√≥
  if (edgeTab.__folders) {
    Object.values(edgeTab.__folders).forEach((f) => edgeTab.removeFolder(f));
  }

  drawParams.lines.forEach((lineObj) => {
    const f = edgeTab.addFolder(`ƒê∆∞·ªùng ${lineObj.label}`);

    // N√∫t t·∫°o trung ƒëi·ªÉm
    f.add(
      {
        createMidpoint: () => {
          // 1. L·∫•y v·ªã tr√≠
          const p1Pos = normalizePoint(lineObj.p1);
          const p2Pos = normalizePoint(lineObj.p2);
        
          // 2. T√≠nh trung ƒëi·ªÉm
          const midPos = new THREE.Vector3()
            .addVectors(p1Pos, p2Pos)
            .multiplyScalar(0.5);
        
          // 3. ƒê·∫∑t t√™n trung ƒëi·ªÉm (n·∫øu p1/p2 ch∆∞a c√≥ name th√¨ ƒë·∫∑t t·∫°m)
          const p1Name = lineObj.p1?.name || "P1";
          const p2Name = lineObj.p2?.name || "P2";
          const midName = `M_${p1Name}${p2Name}`;
        
          // 4. T·∫°o ƒëi·ªÉm trung ƒëi·ªÉm (h√†m addPoint n√™n nh·∫≠n name)
          const midPoint = drawParams.addPoint(midPos.x, midPos.y, midPos.z, midName);
        
          // 5. X√≥a c·∫°nh c≈©
          worldGroup.remove(lineObj.line);
          drawParams.lines = drawParams.lines.filter(l => l !== lineObj);
        
          // 6. H√†m t·∫°o line m·ªõi
          const makeLine = (p1, p2, label, color = 0x00ff00) => {
            const pos1 = normalizePoint(p1);
            const pos2 = normalizePoint(p2);
        
            const geometry = new THREE.BufferGeometry().setFromPoints([pos1, pos2]);
            const material = new THREE.LineBasicMaterial({ color });
            const lineMesh = new THREE.Line(geometry, material);
        
            worldGroup.add(lineMesh);
        
            const newLine = {
              line: lineMesh,
              p1,
              p2,
              _length: pos1.distanceTo(pos2),
              label,
              lengthSprite: null,
              angleSprite: null,
              angleArc: null,
            };
        
            drawParams.lines.push(newLine);
            updateLineLength(newLine);
            return newLine;
          };
        
          // 7. T·∫°o 2 c·∫°nh m·ªõi
          const line1 = makeLine(lineObj.p1, midPoint, `${p1Name}${midPoint.name}`);
          const line2 = makeLine(midPoint, lineObj.p2, `${midPoint.name}${p2Name}`);
        
          // 8. Ghi log
          historyParams.addEntry(`‚úÇÔ∏è Chia c·∫°nh ${lineObj.label} th√†nh ${line1.label}, ${line2.label}`);
        
          // 9. Refresh GUI
          updateEdgeListGUI();
        },
      },
      "createMidpoint"
    ).name("T·∫°o trung ƒëi·ªÉm");

    f.open();
  });
}
function normalizePoint(p) {
  if (!p) return new THREE.Vector3(0, 0, 0); // fallback n·∫øu undefined
  if (p.mesh) return p.mesh.position.clone(); // n·∫øu l√† point object
  if (p instanceof THREE.Vector3) return p.clone(); // n·∫øu l√† Vector3
  if (p.x !== undefined && p.y !== undefined && p.z !== undefined) {
    return new THREE.Vector3(p.x, p.y, p.z); // n·∫øu l√† object {x,y,z}
  }
  return new THREE.Vector3(0, 0, 0);
}


guiDraw.add(drawParams, "help").name("‚ùì Tr·ª£ gi√∫p");

// ===== Raycaster =====
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// ===== H√†m t·∫°o nh√£n nh·ªè h∆°n =====
function createLabelSprite(text, color = "#000000") {
  // ƒêo ƒë·ªô d√†i text ƒë·ªÉ t√≠nh canvas
  const fontSize = 14;
  const padding = 20;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  ctx.font = `${fontSize}px Arial`;
  const metrics = ctx.measureText(text);
  const textWidth = metrics.width;
  const textHeight = fontSize;

  canvas.width = textWidth + padding;
  canvas.height = textHeight + padding;

  // V·∫Ω text
  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = color;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;

  const spriteMaterial = new THREE.SpriteMaterial({
    map: texture,
    depthTest: false,
  });
  const sprite = new THREE.Sprite(spriteMaterial);

  // Scale: chia cho 10 ƒë·ªÉ nh√£n v·ª´a trong worldGroup
  const scaleFactor = 0.1;
  sprite.scale.set(canvas.width * scaleFactor, canvas.height * scaleFactor, 1);

  worldGroup.add(sprite);
  return sprite;
}

// ===== H√†m v·∫Ω cung g√≥c =====
function createAngleArc(shared, other1, other2, radius = 5, segments = 16) {
  const v1 = new THREE.Vector3()
    .subVectors(other1.mesh.position, shared.mesh.position)
    .normalize();
  const v2 = new THREE.Vector3()
    .subVectors(other2.mesh.position, shared.mesh.position)
    .normalize();
  const angle = v1.angleTo(v2);

  const axis = new THREE.Vector3().crossVectors(v1, v2).normalize();
  const arcPoints = [];
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * angle;
    const q = new THREE.Quaternion().setFromAxisAngle(axis, t);
    const point = v1
      .clone()
      .applyQuaternion(q)
      .multiplyScalar(radius)
      .add(shared.mesh.position);
    arcPoints.push(point);
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
  const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
  const arc = new THREE.Line(geometry, material);
  worldGroup.add(arc);
  return arc;
}

// ===== C·∫≠p nh·∫≠t ƒë·ªô d√†i ƒë∆∞·ªùng =====
function updateLineLength(lineObj) {
  const mid = new THREE.Vector3()
    .addVectors(lineObj.p1.mesh.position, lineObj.p2.mesh.position)
    .multiplyScalar(0.5);
  const text = `${lineObj.label} = ${lineObj._length.toFixed(2)}`;
  if (lineObj.lengthSprite) worldGroup.remove(lineObj.lengthSprite);
  lineObj.lengthSprite = createLabelSprite(text, "#00aa00", 64, 2);
  lineObj.lengthSprite.position.copy(mid);
}

// ===== C·∫≠p nh·∫≠t g√≥c v√† v·∫Ω cung =====
function updateAngles() {
  drawParams.selectedLines.forEach((l) => {
    if (l.angleSprite) worldGroup.remove(l.angleSprite);
    if (l.angleArc) worldGroup.remove(l.angleArc);
  });

  if (drawParams.selectedLines.length === 2) {
    const l1 = drawParams.selectedLines[0];
    const l2 = drawParams.selectedLines[1];
    const pts1 = [l1.p1, l1.p2];
    const pts2 = [l2.p1, l2.p2];
    const shared = pts1.find((p) => pts2.includes(p));
    if (!shared) return;

    const other1 = l1.p1 === shared ? l1.p2 : l1.p1;
    const other2 = l2.p1 === shared ? l2.p2 : l2.p1;

    const v1 = new THREE.Vector3()
      .subVectors(other1.mesh.position, shared.mesh.position)
      .normalize();
    const v2 = new THREE.Vector3()
      .subVectors(other2.mesh.position, shared.mesh.position)
      .normalize();
    const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));

    // Nh√£n g√≥c
    const angleLabel = `${other1.label}${shared.label}${
      other2.label
    } = ${angleDeg.toFixed(1)}¬∞`;
    const midPos = shared.mesh.position
      .clone()
      .add(
        new THREE.Vector3()
          .addVectors(other1.mesh.position, other2.mesh.position)
          .multiplyScalar(0.25)
      );
    l1.angleSprite = createLabelSprite(angleLabel, "#0000ff", 64, 2);
    l1.angleSprite.position.copy(midPos);
    l2.angleSprite = l1.angleSprite;

    // V·∫Ω cung bi·ªÉu di·ªÖn g√≥c
    l1.angleArc = createAngleArc(shared, other1, other2, 5, 16);
    l2.angleArc = l1.angleArc;

    l1.angleGUI.name(`G√≥c ${other1.label}${shared.label}${other2.label} (¬∞)`);
    l1.angleGUI.setValue(angleDeg.toFixed(2));
    l2.angleGUI.setValue(angleDeg.toFixed(2));
  }
}

// ===== C·∫≠p nh·∫≠t v·ªã tr√≠ nh√£n khi di chuy·ªÉn ƒëi·ªÉm =====
function updateLinesConnected(point) {
  drawParams.lines.forEach((lineObj) => {
    if (lineObj.p1 === point || lineObj.p2 === point) {
      updateLineGeometry(lineObj);
      lineObj._length = lineObj.p1.mesh.position.distanceTo(
        lineObj.p2.mesh.position
      );
      updateLineLength(lineObj);
    }
  });
  updateAngles();
}

// ===== C·∫≠p nh·∫≠t geometry ƒë∆∞·ªùng =====
function updateLineGeometry(lineObj) {
  lineObj.line.geometry.setFromPoints([
    lineObj.p1.mesh.position.clone(),
    lineObj.p2.mesh.position.clone(),
  ]);
}

function getPointerPosition(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  let clientX, clientY;

  if (event.touches && event.touches.length > 0) {
    clientX = event.touches[0].clientX;
    clientY = event.touches[0].clientY;
  } else if (event.changedTouches && event.changedTouches.length > 0) {
    clientX = event.changedTouches[0].clientX;
    clientY = event.changedTouches[0].clientY;
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }

  return {
    x: ((clientX - rect.left) / rect.width) * 2 - 1,
    y: -((clientY - rect.top) / rect.height) * 2 + 1
  };
}

function onSelect(event) {
  // NgƒÉn tr√¨nh duy·ªát zoom/scroll khi ch·∫°m
  event.preventDefault();

  const pos = getPointerPosition(event);
  mouse.x = pos.x;
  mouse.y = pos.y;

  raycaster.setFromCamera(mouse, camera);

  // ---- Ch·ªçn vector (ArrowHelper) ----
  const allArrowMeshes = vectorsHistory.flatMap(v => v.meshes);
  const intersectsArrow = raycaster.intersectObjects(allArrowMeshes);

  if (intersectsArrow.length > 0) {
    const mesh = intersectsArrow[0].object;
    const vObj = vectorsHistory.find(v => v.meshes.includes(mesh));

    if (!selectedVectors.includes(vObj)) {
      selectedVectors.push(vObj);
      vObj.arrow.setColor(new THREE.Color(0xffff00));
    } else {
      selectedVectors = selectedVectors.filter(v => v !== vObj);
      vObj.arrow.setColor(new THREE.Color(0x00ff00));
    }
    return;
  }

  // ---- Ch·ªçn ƒëi·ªÉm ----
  const intersectsPoint = raycaster.intersectObjects(drawParams.points.map(p => p.mesh));
  if (intersectsPoint.length > 0) {
    const mesh = intersectsPoint[0].object;
    const p = drawParams.points.find(p => p.mesh === mesh);
    if (!drawParams.selectedPoints.includes(p)) {
      drawParams.selectedPoints.push(p);
      mesh.material.color.set(0x0000ff);
    } else {
      drawParams.selectedPoints = drawParams.selectedPoints.filter(pt => pt !== p);
      mesh.material.color.set(0xff3333);
    }
    if (drawParams.selectedPoints.length === 2) drawParams.connectSelected();
    return;
  }

  // ---- Ch·ªçn ƒë∆∞·ªùng ----
  const intersectsLine = raycaster.intersectObjects(drawParams.lines.map(l => l.line));
  if (intersectsLine.length > 0) {
    const mesh = intersectsLine[0].object;
    const lineObj = drawParams.lines.find(l => l.line === mesh);
    if (!drawParams.selectedLines.includes(lineObj)) {
      drawParams.selectedLines.push(lineObj);
      mesh.material.color.set(0xffff00);
    } else {
      drawParams.selectedLines = drawParams.selectedLines.filter(l => l !== lineObj);
      mesh.material.color.set(0x00ff00);
    }
    updateAngles();
    return;
  }

// ---- Ch·ªçn c·∫°nh b·∫•t k·ª≥ trong Shape ----
const intersectsEdge = raycaster.intersectObjects(shapeEdges);
if (intersectsEdge.length > 0) {
  const edgeLine = intersectsEdge[0].object;
  if (edgeLine.userData.type === "shapeEdge") {
    selectedEdge = edgeLine;
    shapeEdges.forEach(e => e.material.color.set(0x000000));
    edgeLine.material.color.set(0xff0000);

    historyParams.addEntry(`üîπ ƒê√£ ch·ªçn c·∫°nh t·ª´ ${edgeLine.userData.edge.a.toArray()} ‚Üí ${edgeLine.userData.edge.b.toArray()}`);
    return;
  }
}

// ---- N·∫øu click ra ngo√†i: b·ªè ch·ªçn h·∫øt ----
selectedVectors.forEach(v => v.arrow.setColor(new THREE.Color(0x00ff00)));
selectedVectors = [];

drawParams.selectedPoints.forEach(p => p.mesh.material.color.set(0xff3333));
drawParams.selectedPoints = [];

drawParams.selectedLines.forEach(l => l.line.material.color.set(0x00ff00));
drawParams.selectedLines = [];

// B·ªè ch·ªçn c·∫°nh h√¨nh
if (selectedEdge) {
  shapeEdges.forEach(e => e.material.color.set(0x000000)); // reset t·∫•t c·∫£ c·∫°nh v·ªÅ m√†u m·∫∑c ƒë·ªãnh
  selectedEdge = null;
}

updateAngles();

}

// ===== G·∫Øn event cho c·∫£ chu·ªôt & c·∫£m ·ª©ng =====
renderer.domElement.addEventListener("click", onSelect);
renderer.domElement.addEventListener("touchend", onSelect, { passive: false });

// ================== SHAPE MODULE ==================
let selectedEdge = null; 
let shapeMesh;
let shapeEdges = [];
let shapeMeshFaces = []; // L∆∞u c√°c m·∫∑t ri√™ng l·∫ª c·ªßa kh·ªëi ƒë·ªÉ explode/implode

// C√°c tham s·ªë chung
const shapeParams = {
  type: "pyramid",  // Lo·∫°i h√¨nh kh·ªëi
  n: 4,             // s·ªë c·∫°nh ƒë√°y (pyramid, prism)
  radius: 2,        // b√°n k√≠nh (pyramid, prism, cone, sphere)
  height: 3,        // chi·ªÅu cao (pyramid, prism, cone, cylinder)
  tiltX: 0,         // nghi√™ng theo tr·ª•c X
  tiltY: 0,         // nghi√™ng theo tr·ª•c Y
  splitRatio: "1:1", // m·∫∑c ƒë·ªãnh
splitEdgeRatio: () => {
  if (!selectedEdge) {
    alert("‚ö†Ô∏è H√£y ch·ªçn m·ªôt c·∫°nh tr∆∞·ªõc!");
    return;
  }
  const { a, b } = selectedEdge.userData.edge;

  const [p1, p2] = shapeParams.splitRatio.split(":").map(Number);
  const total = p1 + p2;
  const t = p1 / total;

  const pos = new THREE.Vector3().lerpVectors(a, b, t);

  const geom = new THREE.SphereGeometry(0.1, 16, 16);
  const mat = new THREE.MeshStandardMaterial({ color: 0xff00ff });
  const sphere = new THREE.Mesh(geom, mat);
  sphere.position.copy(pos);
  worldGroup.add(sphere);

  createLabel(`${p1}:${p2}`, pos, "#ff00ff");
  historyParams.addEntry(`‚úÇÔ∏è Chia c·∫°nh theo t·ªâ l·ªá ${p1}:${p2}`);
},

  explode: false,
  draw: () => drawShape(),
};

// GUI
const guiShape = guiHelper.addTab("Shapes", 250, { icon: "üìê", label: "Kh·ªëi 3D" });

guiShape.add(shapeParams, "type", [
  "pyramid","prism","cube",
  "cylinder","cone","sphere","torus",
  "frustum","octahedron","dodecahedron","icosahedron"
]).name("Lo·∫°i h√¨nh");

guiShape.add(shapeParams, "n", 3, 30, 1).name("S·ªë c·∫°nh ƒë√°y");
guiShape.add(shapeParams, "radius", 1, 50, 0.1).name("B√°n k√≠nh");
guiShape.add(shapeParams, "height", 1, 50, 0.1).name("Chi·ªÅu cao");
guiShape.add(shapeParams, "tiltX", -50, 50, 0.1).name("Nghi√™ng X");
guiShape.add(shapeParams, "tiltY", -50, 50, 0.1).name("Nghi√™ng Y");
guiShape.add(shapeParams, "draw").name("üèóÔ∏è V·∫Ω h√¨nh");
guiShape.add(shapeParams, "explode").name("üí• Explode View").onChange(val => {
  if(shapeMeshFaces.length > 0) applyExplode(val ? 1 : 0);
});
guiShape.add(shapeParams, "splitRatio").name("T·ªâ l·ªá (a:b)");
guiShape.add(shapeParams, "splitEdgeRatio").name("‚úÇÔ∏è Chia theo t·ªâ l·ªá");

// H√†m t·ªïng
function drawShape() {
  const { type } = shapeParams;

  if (shapeMesh) worldGroup.remove(shapeMesh);
  shapeEdges.forEach(e => worldGroup.remove(e));
  shapeEdges = [];
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];
  shapeLabels.forEach(l => axisGroup.remove(l));
  shapeLabels = [];
  switch(type){
    case "pyramid": drawPyramid(); break;
    case "prism": drawPrism(); break;
    case "cube": drawCube(); break;
    case "cylinder": drawCylinder(); break;
    case "cone": drawCone(); break;
    case "sphere": drawSphere(); break;
    case "torus": drawTorus(); break;
    case "frustum": drawFrustum(); break;
    case "octahedron": drawOctahedron(); break;
    case "dodecahedron": drawDodecahedron(); break;
    case "icosahedron": drawIcosahedron(); break;
  }

  // Zoom camera (gi·ªØ nguy√™n ph·∫ßn b·∫°n vi·∫øt)
  if (shapeMesh) {
    const box = new THREE.Box3().setFromObject(shapeMesh);
    const center = new THREE.Vector3();
    box.getCenter(center);
    const size = new THREE.Vector3();
    box.getSize(size);

    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = camera.fov * (Math.PI/180);
    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov/2)) * 1.2;

    camera.position.set(center.x, center.y, center.z + cameraZ);
    camera.lookAt(center);

    if (controls) {
      controls.target.copy(center);
      controls.update();
    }
  }
}


// ---- Cylinder ----
function drawCylinder() {
  const { radius, height } = shapeParams;
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];

  const geom = new THREE.CylinderGeometry(radius, radius, height, 32, 1, false);
  const mat = new THREE.MeshStandardMaterial({ color: 0x99ff99, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  shapeMesh = new THREE.Mesh(geom, mat);
  worldGroup.add(shapeMesh);

  historyParams.addEntry("üü¢ Cylinder");

  if (shapeParams.explode) applyExplode(shapeParams.explode);
}

// ---- Cone ----
function drawCone() {
  const { radius, height } = shapeParams;
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];

  const geom = new THREE.ConeGeometry(radius, height, 32);
  const mat = new THREE.MeshStandardMaterial({ color: 0xff9999, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  shapeMesh = new THREE.Mesh(geom, mat);
  worldGroup.add(shapeMesh);

  historyParams.addEntry("üî∫ Cone");

  if (shapeParams.explode) applyExplode(shapeParams.explode);
}

// ---- Sphere ----
function drawSphere() {
  const { radius } = shapeParams;
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];

  const geom = new THREE.SphereGeometry(radius, 32, 16);
  const mat = new THREE.MeshStandardMaterial({ color: 0xffff66, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  shapeMesh = new THREE.Mesh(geom, mat);
  worldGroup.add(shapeMesh);

  historyParams.addEntry("üü° Sphere");

  if (shapeParams.explode) applyExplode(shapeParams.explode);
}

// ---- Torus ----
function drawTorus() {
  const { radius } = shapeParams;
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];

  const geom = new THREE.TorusGeometry(radius, radius/3, 16, 100);
  const mat = new THREE.MeshStandardMaterial({ color: 0xcc99ff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  shapeMesh = new THREE.Mesh(geom, mat);
  worldGroup.add(shapeMesh);

  historyParams.addEntry("üü£ Torus");

  if (shapeParams.explode) applyExplode(shapeParams.explode);
}

// ---- Frustum (ch√≥p c·ª•t) ----
function drawFrustum() {
  const { radius, height } = shapeParams;
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];

  const geom = new THREE.CylinderGeometry(radius, radius/2, height, 32, 1, false);
  const mat = new THREE.MeshStandardMaterial({ color: 0xff9966, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  shapeMesh = new THREE.Mesh(geom, mat);
  worldGroup.add(shapeMesh);

  historyParams.addEntry("üü† Frustum");

  if (shapeParams.explode) applyExplode(shapeParams.explode);
}

// ---- Octahedron ----
// ---- Octahedron (n-gon base) ----
function drawOctahedron() {
  const { n, radius, height, tiltX, tiltY } = shapeParams;

  // X√≥a kh·ªëi c≈© n·∫øu c√≥
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  if (shapeMesh) {
    worldGroup.remove(shapeMesh);
    shapeMesh = null;
  }
  shapeMeshFaces = [];

  const basePoints = [];
  const baseLabels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // nh√£n cho ƒëa gi√°c

  // --- T·∫°o ƒëa gi√°c ƒë·ªÅu n c·∫°nh ---
  for (let i = 0; i < n; i++) {
    const angle = (i / n) * Math.PI * 2;
    const p = new THREE.Vector3(
      radius * Math.cos(angle),
      radius * Math.sin(angle),
      0
    );
    basePoints.push(p);
    createLabel(baseLabels[i % baseLabels.length], p, "#ff0000");
  }

  // --- T·∫°o 2 ƒë·ªânh S v√† S' ---
  const top = new THREE.Vector3(tiltX, tiltY, height / 2);
  const bottom = new THREE.Vector3(-tiltX, -tiltY, -height / 2);
  createLabel("S", top, "#ff0000");
  createLabel("S'", bottom, "#ff0000");

  // Gom t·∫•t c·∫£ m·∫∑t v√†o group
  const group = new THREE.Group();

  // --- M·∫∑t tr√™n n·ªëi S v·ªõi ƒëa gi√°c ---
  for (let i = 0; i < n; i++) {
    const p1 = basePoints[i];
    const p2 = basePoints[(i + 1) % n];

    const geom = new THREE.BufferGeometry();
    geom.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(
        [...top.toArray(), ...p1.toArray(), ...p2.toArray()],
        3
      )
    );
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({
      color: 0x66ffff,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const mesh = new THREE.Mesh(geom, mat);

    // T√≠nh t√¢m m·∫∑t
    const center = new THREE.Vector3().addVectors(top, p1).add(p2).divideScalar(3);
    mesh.userData.center = center;

    group.add(mesh);
    shapeMeshFaces.push(mesh);
  }

  // --- M·∫∑t d∆∞·ªõi n·ªëi S' v·ªõi ƒëa gi√°c ---
  for (let i = 0; i < n; i++) {
    const p1 = basePoints[i];
    const p2 = basePoints[(i + 1) % n];

    const geom = new THREE.BufferGeometry();
    geom.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(
        [...bottom.toArray(), ...p2.toArray(), ...p1.toArray()], // ƒë·∫£o ng∆∞·ª£c
        3
      )
    );
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({
      color: 0x66ffff,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const mesh = new THREE.Mesh(geom, mat);

    // T√≠nh t√¢m m·∫∑t
    const center = new THREE.Vector3().addVectors(bottom, p1).add(p2).divideScalar(3);
    mesh.userData.center = center;

    group.add(mesh);
    shapeMeshFaces.push(mesh);
  }

  worldGroup.add(group);
  shapeMesh = group; // üëà g√°n ƒë·ªÉ drawShape() zoom ƒë∆∞·ª£c

  // --- C·∫°nh ---
  const allEdges = [];
  for (let i = 0; i < n; i++) {
    const p1 = basePoints[i];
    const p2 = basePoints[(i + 1) % n];
    allEdges.push([p1, p2]);      // c·∫°nh ƒëa gi√°c
    allEdges.push([top, p1]);     // c·∫°nh tr√™n
    allEdges.push([bottom, p1]);  // c·∫°nh d∆∞·ªõi
  }
  addEdges(allEdges);

  historyParams.addEntry(`üî∑ Octahedron ${n}-c·∫°nh v·ªõi tilt v√† height`);

  // N·∫øu ƒë√£ b·∫≠t explode, √°p d·ª•ng lu√¥n
  if (shapeParams.explode) applyExplode(shapeParams.explode);
}



// ---- Dodecahedron ----
function drawDodecahedron() {
  const { radius } = shapeParams;
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];

  const geom = new THREE.DodecahedronGeometry(radius);
  const mat = new THREE.MeshStandardMaterial({ color: 0xffccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  shapeMesh = new THREE.Mesh(geom, mat);
  worldGroup.add(shapeMesh);

  historyParams.addEntry("üí† Dodecahedron");

  if (shapeParams.explode) applyExplode(shapeParams.explode);
}

// ---- Icosahedron ----
function drawIcosahedron() {
  const { radius } = shapeParams;
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  shapeMeshFaces = [];

  const geom = new THREE.IcosahedronGeometry(radius);
  const mat = new THREE.MeshStandardMaterial({ color: 0x99ffcc, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  shapeMesh = new THREE.Mesh(geom, mat);
  worldGroup.add(shapeMesh);

  historyParams.addEntry("üî∫ Icosahedron");

  if (shapeParams.explode) applyExplode(shapeParams.explode);
}

// ---- Pyramid ----
// ---- Pyramid ----
function drawPyramid() {
  const { n, radius, height, tiltX, tiltY } = shapeParams;
  const basePoints = [];
  const baseLabels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // nh√£n ƒë√°y

  // X√≥a m·∫∑t c≈© n·∫øu c√≥
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  if (shapeMesh) {
    worldGroup.remove(shapeMesh);
    shapeMesh = null;
  }
  shapeMeshFaces = [];

  // T·∫°o ƒëi·ªÉm ƒë√°y
  for (let i = 0; i < n; i++) {
    const angle = (i / n) * Math.PI * 2;
    const p = new THREE.Vector3(radius * Math.cos(angle), radius * Math.sin(angle), 0);
    basePoints.push(p);
    createLabel(baseLabels[i], p, "#ff0000"); // nh√£n ƒë√°y
  }

  const apex = new THREE.Vector3(tiltX, tiltY, height);
  createLabel("S", apex, "#ff0000"); // ƒë·ªânh

  // --- T·∫°o t·ª´ng m·∫∑t b√™n ---
  for (let i = 0; i < n; i++) {
    const p1 = basePoints[i];
    const p2 = basePoints[(i + 1) % n];
    const geom = new THREE.BufferGeometry();
    geom.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(
        [...apex.toArray(), ...p1.toArray(), ...p2.toArray()],
        3
      )
    );
    geom.computeVertexNormals();
    const mat = new THREE.MeshStandardMaterial({
      color: 0xffcc00,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.userData.center = new THREE.Vector3()
      .addVectors(apex, p1)
      .add(p2)
      .divideScalar(3);
    worldGroup.add(mesh);
    shapeMeshFaces.push(mesh);
  }

  // --- T·∫°o m·∫∑t ƒë√°y ---
  for (let i = 1; i < n - 1; i++) {
    const geom = new THREE.BufferGeometry();
    geom.setAttribute(
      "position",
      new THREE.Float32BufferAttribute(
        [
          ...basePoints[0].toArray(),
          ...basePoints[i].toArray(),
          ...basePoints[i + 1].toArray()
        ],
        3
      )
    );
    geom.computeVertexNormals();
    const mat = new THREE.MeshStandardMaterial({
      color: 0xffcc00,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    const mesh = new THREE.Mesh(geom, mat);
    const center = new THREE.Vector3()
      .add(basePoints[0])
      .add(basePoints[i])
      .add(basePoints[i + 1])
      .divideScalar(3);
    mesh.userData.center = center;
    worldGroup.add(mesh);
    shapeMeshFaces.push(mesh);
  }

  // C·∫°nh
  const allEdges = [];
  basePoints.forEach((p, i) => {
    const next = basePoints[(i + 1) % n];
    allEdges.push([p, next]); // ƒë√°y
    allEdges.push([apex, p]); // c·∫°nh b√™n
  });
  addEdges(allEdges);

  historyParams.addEntry(`üî∫ Pyramid ${n} c·∫°nh ƒë√°y v·ªõi nghi√™ng`);

  // Gom t·∫•t c·∫£ m·∫∑t v√†o m·ªôt group ƒë·ªÉ g√°n cho shapeMesh
  const group = new THREE.Group();
  shapeMeshFaces.forEach(f => group.add(f));
  worldGroup.add(group);
  shapeMesh = group;

  // N·∫øu ƒë√£ b·∫≠t explode, √°p d·ª•ng lu√¥n
  if (shapeParams.explode) applyExplode(shapeParams.explode);
}




// ---- Prism ----
function drawPrism() {
  const { n, radius, height, tiltX, tiltY } = shapeParams;
  const baseBottom = [], baseTop = [];

  // X√≥a m·∫∑t c≈© n·∫øu c√≥
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  if (shapeMesh) {
    worldGroup.remove(shapeMesh);
    shapeMesh = null;
  }
  shapeMeshFaces = [];

  // T·∫°o nh√£n
  const bottomLabels = [];
  const topLabels = [];
  for (let i = 0; i < n; i++) {
    bottomLabels.push(String.fromCharCode(65+i));      // A,B,C...
    topLabels.push(String.fromCharCode(65+i) + "'");   // A',B',C'...
  }

  for (let i = 0; i < n; i++) {
    const angle = (i/n)*Math.PI*2;
    const bottom = new THREE.Vector3(radius*Math.cos(angle), radius*Math.sin(angle), 0);
    const top = new THREE.Vector3(radius*Math.cos(angle)+tiltX, radius*Math.sin(angle)+tiltY, height);
    baseBottom.push(bottom);
    baseTop.push(top);

    createLabel(bottomLabels[i], bottom, "#ff0000");
    createLabel(topLabels[i], top, "#ff0000");
  }

  // --- T·∫°o m·∫∑t ri√™ng ---
  const faces = [];

  // M·∫∑t b√™n
  for (let i = 0; i < n; i++) {
    const p1 = baseBottom[i];
    const p2 = baseBottom[(i+1)%n];
    const p3 = baseTop[(i+1)%n];
    const p4 = baseTop[i];
    faces.push([p1,p2,p3,p4]);
  }

  // M·∫∑t ƒë√°y
  for (let i = 1; i < n-1; i++) {
    faces.push([baseBottom[0], baseBottom[i], baseBottom[i+1]]);
  }

  // M·∫∑t tr√™n
  for (let i = 1; i < n-1; i++) {
    faces.push([baseTop[0], baseTop[i+1], baseTop[i]]);
  }

  faces.forEach(fVerts => {
    const geom = new THREE.BufferGeometry();
    const vArray = [];

    if(fVerts.length === 4){
      vArray.push(...fVerts[0].toArray(), ...fVerts[1].toArray(), ...fVerts[2].toArray());
      vArray.push(...fVerts[0].toArray(), ...fVerts[2].toArray(), ...fVerts[3].toArray());
    } else {
      vArray.push(...fVerts[0].toArray(), ...fVerts[1].toArray(), ...fVerts[2].toArray());
    }

    geom.setAttribute("position", new THREE.Float32BufferAttribute(vArray,3));
    geom.computeVertexNormals();
    const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00, transparent:true, opacity:0.5, side:THREE.DoubleSide });
    const mesh = new THREE.Mesh(geom, mat);

    // T√≠nh t√¢m m·∫∑t cho explode
    const center = new THREE.Vector3();
    fVerts.forEach(v => center.add(v));
    center.divideScalar(fVerts.length);
    mesh.userData.center = center;

    worldGroup.add(mesh);
    shapeMeshFaces.push(mesh);
  });

  // C·∫°nh
  const edges = [];
  for(let i=0;i<n;i++){
    edges.push([baseTop[i], baseTop[(i+1)%n]]);
    edges.push([baseBottom[i], baseBottom[(i+1)%n]]);
    edges.push([baseTop[i], baseBottom[i]]);
  }
  addEdges(edges);

  historyParams.addEntry(`üî∂ LƒÉng tr·ª• ${n} c·∫°nh ƒë√°y v·ªõi nghi√™ng v√† nh√£n h√¨nh h·ªçc`);

  // Gom t·∫•t c·∫£ m·∫∑t v√†o m·ªôt group ƒë·ªÉ g√°n cho shapeMesh
  const group = new THREE.Group();
  shapeMeshFaces.forEach(f => group.add(f));
  worldGroup.add(group);
  shapeMesh = group;

  // N·∫øu explode ƒëang b·∫≠t, √°p d·ª•ng ngay
  if(shapeParams.explode) applyExplode(shapeParams.explode);
}


// ---- Cube ----
function drawCube() {
  const { radius, tiltX, tiltY } = shapeParams;
  const half = radius;
  const bottomZ = 0;
  const topZ = radius * 2;

  // X√≥a m·∫∑t c≈© n·∫øu c√≥
  shapeMeshFaces.forEach(f => worldGroup.remove(f));
  if (shapeMesh) {
    worldGroup.remove(shapeMesh);
    shapeMesh = null;
  }
  shapeMeshFaces = [];

  // Nh√£n: ƒë√°y A', B', C', D'; ƒë·ªânh A, B, C, D
  const topLabels = ["A","B","C","D"];
  const bottomLabels = ["A'","B'","C'","D'"];

  const vertices = [
    // ƒë√°y
    new THREE.Vector3(-half, -half, bottomZ),
    new THREE.Vector3( half, -half, bottomZ),
    new THREE.Vector3( half,  half, bottomZ),
    new THREE.Vector3(-half,  half, bottomZ),
    // ƒë·ªânh (nghi√™ng theo tilt)
    new THREE.Vector3(-half + tiltX, -half + tiltY, topZ),
    new THREE.Vector3( half + tiltX, -half + tiltY, topZ),
    new THREE.Vector3( half + tiltX,  half + tiltY, topZ),
    new THREE.Vector3(-half + tiltX,  half + tiltY, topZ)
  ];

  // Th√™m nh√£n
  for (let i = 0; i < 4; i++) createLabel(bottomLabels[i], vertices[i], "#ff0000");
  for (let i = 4; i < 8; i++) createLabel(topLabels[i-4], vertices[i], "#ff0000");

  // --- T·∫°o t·ª´ng m·∫∑t ---
  const faceIndices = [
    [0,1,2,3], // ƒë√°y
    [4,5,6,7], // ƒë·ªânh
    [0,1,5,4], // c·∫°nh b√™n
    [1,2,6,5],
    [2,3,7,6],
    [3,0,4,7]
  ];

  const group = new THREE.Group();

  faceIndices.forEach(indices => {
    const geom = new THREE.BufferGeometry();
    const vArray = [
      ...vertices[indices[0]].toArray(),
      ...vertices[indices[1]].toArray(),
      ...vertices[indices[2]].toArray(),
      ...vertices[indices[0]].toArray(),
      ...vertices[indices[2]].toArray(),
      ...vertices[indices[3]].toArray()
    ];
    geom.setAttribute("position", new THREE.Float32BufferAttribute(vArray, 3));
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({
      color: 0x66ccff,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });

    const mesh = new THREE.Mesh(geom, mat);

    // T√≠nh t√¢m m·∫∑t ƒë·ªÉ explode
    const center = new THREE.Vector3();
    indices.forEach(i => center.add(vertices[i]));
    center.divideScalar(4);
    mesh.userData.center = center;

    group.add(mesh);
    shapeMeshFaces.push(mesh);
  });

  // C·∫°nh
  const edges = [
    [vertices[0], vertices[1]], [vertices[1], vertices[2]], [vertices[2], vertices[3]], [vertices[3], vertices[0]],
    [vertices[4], vertices[5]], [vertices[5], vertices[6]], [vertices[6], vertices[7]], [vertices[7], vertices[4]],
    [vertices[0], vertices[4]], [vertices[1], vertices[5]], [vertices[2], vertices[6]], [vertices[3], vertices[7]]
  ];
  addEdges(edges);

  worldGroup.add(group);
  shapeMesh = group; // g√°n cho shapeMesh ƒë·ªÉ drawShape() zoom chu·∫©n

  historyParams.addEntry(`üü¶ Cube v·ªõi nghi√™ng X:${tiltX} Y:${tiltY} v√† nh√£n h√¨nh h·ªçc`);

  // N·∫øu explode ƒëang b·∫≠t, √°p d·ª•ng ngay
  if (shapeParams.explode) applyExplode(shapeParams.explode);
}



// ---- H√†m ti·ªán √≠ch th√™m c·∫°nh ----
function addEdges(edgeArray){
  edgeArray.forEach(([a,b])=>{
    const lineGeom = new THREE.BufferGeometry().setFromPoints([a,b]);
    const line = new THREE.Line(lineGeom,new THREE.LineBasicMaterial({color:0xffffff}));
    worldGroup.add(line);
    shapeEdges.push(line);
    line.userData.edge = {a,b};
    line.userData.type = "shapeEdge";
  });
}

function applyExplode(value) {
  const explodeDistance = 1.5; // kho·∫£ng c√°ch t√°ch m·∫∑t
  shapeMeshFaces.forEach(mesh => {
    if (value === 1) {
      const dir = mesh.userData.center.clone().sub(new THREE.Vector3(0,0,0)).normalize();
      mesh.position.copy(dir.multiplyScalar(explodeDistance));
    } else {
      mesh.position.set(0,0,0); // tr·ªü v·ªÅ
    }
  });
}




// ================== VECTOR MODULE ==================

// Tham s·ªë vector v√† GUI
const vectorParams = {
  x1: 0,
  y1: 0,
  z1: 0,
  x2: 1,
  y2: 1,
  z2: 1,

  scalarValue: 2, // üëà h·ªá s·ªë nh√¢n m·∫∑c ƒë·ªãnh
  proj: () => projectionVector(),
  draw: () => drawVectorFromInput(),
  length: () => getVectorLength(),
  unit: () => getUnitVector(),
  add: () => addSelectedVectors(),
  sub: () => subSelectedVectors(),
  dot: () => dotSelectedVectors(),
  cross: () => crossSelectedVectors(),
  angle: () => angleBetweenFromHistory(),
  scalar: () => scalarMultiplyFromHistory(), // üëà th√™m ch·ª©c nƒÉng m·ªõi
  triple: () => tripleProductFromHistory(), // üëà m·ªõi
  doubleCross: () => doubleCrossProductFromHistory(), // üëà th√™m m·ªõi
  plane: () => createPlaneFromTwoVectors(),
  line: () => createLineFromPointAndVector(),
  para: () =>  drawParallelogram(),
  tri: () => drawTriangleBetweenVectors(),
  cone: () => drawProjectionCone(),
  showCoords: () => {
    const { x1, y1, z1, x2, y2, z2 } = vectorParams;
    const vx = x2 - x1;
    const vy = y2 - y1;
    const vz = z2 - z1;
  
    alert(`üìå Vector t·ªça ƒë·ªô = (${vx.toFixed(3)}, ${vy.toFixed(3)}, ${vz.toFixed(3)})`);
  },
  
  help: () => {
    alert(
      `üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng tab Vector:

‚úèÔ∏è V·∫Ω Vector:
- Nh·∫≠p t·ªça ƒë·ªô ƒëi·ªÉm ƒë·∫ßu (X1, Y1, Z1).
- Nh·∫≠p t·ªça ƒë·ªô ƒëi·ªÉm cu·ªëi (X2, Y2, Z2).
- Nh·∫•n "‚úèÔ∏è V·∫Ω Vector" ƒë·ªÉ t·∫°o m≈©i t√™n trong kh√¥ng gian 3D.

üìè Ch·ª©c nƒÉng m·ªü r·ªông:
- ƒê·ªô d√†i, vector ƒë∆°n v·ªã.
- T·ªïng, hi·ªáu, t√≠ch v√¥ h∆∞·ªõng, t√≠ch c√≥ h∆∞·ªõng.
- G√≥c gi·ªØa 2 vector (ch·ªçn t·ª´ l·ªãch s·ª≠).

üóíÔ∏è L·ªãch s·ª≠:
- M·ªói vector ƒë√£ v·∫Ω s·∫Ω ƒë∆∞·ª£c l∆∞u l·∫°i ƒë·ªÉ t√≠nh to√°n ti·∫øp.
`
    );
  },
};

// T·∫°o GUI tab
const guiVector = guiHelper.addTab("Vector", 300, {
  icon: "üß≠",
  label: "Vector",
});

guiVector.add(vectorParams, "x1", -10, 10, 0.1).name("X1");
guiVector.add(vectorParams, "y1", -10, 10, 0.1).name("Y1");
guiVector.add(vectorParams, "z1", -10, 10, 0.1).name("Z1");
guiVector.add(vectorParams, "x2", -10, 10, 0.1).name("X2");
guiVector.add(vectorParams, "y2", -10, 10, 0.1).name("Y2");
guiVector.add(vectorParams, "z2", -10, 10, 0.1).name("Z2");

// Nh√≥m V·∫Ω & Th√¥ng tin c∆° b·∫£n
const basicFolder = guiVector.addFolder("üéØ C∆° b·∫£n");
basicFolder.add(vectorParams, "draw").name("‚úèÔ∏è V·∫Ω Vector");
basicFolder.add(vectorParams, "length").name("üìè ƒê·ªô d√†i");
basicFolder.add(vectorParams, "unit").name("‚ÜîÔ∏è Vector ƒë∆°n v·ªã");
basicFolder.add(vectorParams, "showCoords").name("üìå Hi·ªÉn th·ªã t·ªça ƒë·ªô");
basicFolder.add({
  createFromEdge: () => {
    // --- Tr∆∞·ªùng h·ª£p ch·ªçn c·∫°nh c·ªßa Shape ---
    if (selectedEdge) {
      const { a, b } = selectedEdge.userData.edge;
      const dir = new THREE.Vector3().subVectors(b, a);
      const len = dir.length();

      const arrow = new THREE.ArrowHelper(
        dir.clone().normalize(),
        a.clone(),
        len,
        0x00ff00,
        1,
        0.5
      );
      arrow.userData.vectorData = { from: a.clone(), dir, to: b.clone() };
      worldGroup.add(arrow);

      const vObj = {
        from: a.clone(),
        to: b.clone(),
        dir,
        arrow,
        meshes: [arrow.cone, arrow.line],
      };
      vectorsHistory.push(vObj);
      refreshVectorList();

      historyParams.addEntry(`üìê T·∫°o vector t·ª´ c·∫°nh [${a.x.toFixed(1)},${a.y.toFixed(1)},${a.z.toFixed(1)}] ‚Üí [${b.x.toFixed(1)},${b.y.toFixed(1)},${b.z.toFixed(1)}]`);

      vObj.arrow.setColor(new THREE.Color(0xffff00));
      selectedVectors = [vObj];
      return;
    }

    // --- Tr∆∞·ªùng h·ª£p ch·ªçn ƒë∆∞·ªùng (line) ---
if (drawParams.selectedLines.length > 0) {
  const lineObj = drawParams.selectedLines[0]; // l·∫•y ƒë∆∞·ªùng ƒë·∫ßu ti√™n
  const a = lineObj.p1.mesh.position.clone();
  const b = lineObj.p2.mesh.position.clone();

  const dir = new THREE.Vector3().subVectors(b, a);
  const len = dir.length();

  const arrow = new THREE.ArrowHelper(
    dir.clone().normalize(),
    a.clone(),
    len,
    0x00ff00,
    1,
    0.5
  );
  arrow.userData.vectorData = { from: a.clone(), dir, to: b.clone() };
  worldGroup.add(arrow);

  const vObj = {
    from: a.clone(),
    to: b.clone(),
    dir,
    arrow,
    meshes: [arrow.cone, arrow.line],
  };
  vectorsHistory.push(vObj);
  refreshVectorList();

  historyParams.addEntry(
    `üìê T·∫°o vector t·ª´ ƒë∆∞·ªùng ${lineObj.label}: [${a.x.toFixed(
      1
    )},${a.y.toFixed(1)},${a.z.toFixed(1)}] ‚Üí [${b.x.toFixed(
      1
    )},${b.y.toFixed(1)},${b.z.toFixed(1)}]`
  );

  vObj.arrow.setColor(new THREE.Color(0xffff00));
  selectedVectors = [vObj];
  return;
}


    alert("‚ö†Ô∏è Ch∆∞a ch·ªçn c·∫°nh hay ƒë∆∞·ªùng n√†o!");
  }
}, "createFromEdge").name("T·∫°o vector t·ª´ c·∫°nh/ƒë∆∞·ªùng");
basicFolder.add({
  reverseVector: () => {
    if (selectedVectors.length === 0) {
      alert("‚ö†Ô∏è Ch∆∞a ch·ªçn vector n√†o!");
      return;
    }

    const vObj = selectedVectors[0]; // l·∫•y vector ƒë·∫ßu ti√™n ƒë∆∞·ª£c ch·ªçn
    const oldFrom = vObj.from.clone();
    const oldTo = vObj.to.clone();

    // ƒê·∫£o chi·ªÅu: from ‚Üî to
    const newFrom = oldTo;
    const newTo = oldFrom;
    const newDir = new THREE.Vector3().subVectors(newTo, newFrom);
    const len = newDir.length();

    // X√≥a arrow c≈©
    worldGroup.remove(vObj.arrow);

    // T·∫°o arrow m·ªõi ƒë·∫£o chi·ªÅu
    const arrow = new THREE.ArrowHelper(
      newDir.clone().normalize(),
      newFrom.clone(),
      len,
      0xff0000, // m√†u kh√°c ƒë·ªÉ d·ªÖ nh·∫≠n bi·∫øt
      1,
      0.5
    );
    arrow.userData.vectorData = { from: newFrom.clone(), dir: newDir, to: newTo.clone() };
    worldGroup.add(arrow);

    // C·∫≠p nh·∫≠t l·∫°i vObj
    vObj.from = newFrom.clone();
    vObj.to = newTo.clone();
    vObj.dir = newDir;
    vObj.arrow = arrow;
    vObj.meshes = [arrow.cone, arrow.line];

    historyParams.addEntry(
      `‚ÜîÔ∏è ƒê·∫£o chi·ªÅu vector: [${oldFrom.x.toFixed(1)},${oldFrom.y.toFixed(1)},${oldFrom.z.toFixed(1)}] ‚Üí [${oldTo.x.toFixed(1)},${oldTo.y.toFixed(1)},${oldTo.z.toFixed(1)}] th√†nh [${newFrom.x.toFixed(1)},${newFrom.y.toFixed(1)},${newFrom.z.toFixed(1)}] ‚Üí [${newTo.x.toFixed(1)},${newTo.y.toFixed(1)},${newTo.z.toFixed(1)}]`
    );

    // Gi·ªØ highlight
    vObj.arrow.setColor(new THREE.Color(0xffff00));
  }
}, "reverseVector").name("‚ÜîÔ∏è ƒê·∫£o chi·ªÅu vector");


// --- Nh√≥m Ph√©p to√°n v·ªõi tooltip ---
const calcFolder = guiHelper.addFolderWithTooltip(
  guiVector,
  "‚ö° Ph√©p to√°n",
  "", // icon ch√≠nh c·ªßa folder n·∫øu mu·ªën
  "C√°c ph√©p to√°n vector: c·ªông, tr·ª´, t√≠ch v√¥ h∆∞·ªõng, v.v."
);

// --- C√°c gi√° tr·ªã s·ªë ---
guiHelper.addWithIcon(calcFolder, vectorParams, "scalarValue", "üî¢", {
  label: "H·ªá s·ªë nh√¢n",
  columns: 3
});

// --- C√°c checkbox / n√∫t h√†nh ƒë·ªông ---
guiHelper.addWithIcon(calcFolder, vectorParams, "scalar", "üìà", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "proj", "üìç", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "add", "‚ûï", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "sub", "‚ûñ", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "dot", "‚ú¥Ô∏è", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "cross", "‚úñÔ∏è", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "angle", "üìê", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "triple", "üì¶", { columns: 3 });
guiHelper.addWithIcon(calcFolder, vectorParams, "doubleCross", "üåÄ", { columns: 3 });

// --- C√°c h√†nh ƒë·ªông d·∫°ng n√∫t ---
guiHelper.addWithIcon(calcFolder, { rel: checkVectorRelations }, "rel", "üîé", { columns: 3, label: "Quan h·ªá 2 vector" });
guiHelper.addWithIcon(calcFolder, { dist: distanceBetweenVectors }, "dist", "üìè", { columns: 3, label: "Kho·∫£ng c√°ch 2 vector" });

// Nh√≥m H√¨nh h·ªçc cao h∆°n
const geomFolder = guiVector.addFolder("üìê H√¨nh h·ªçc cao h∆°n");
geomFolder.add(vectorParams, "plane").name("üìÑ M·∫∑t ph·∫≥ng (t·ª´ 2 vector)");
geomFolder.add(vectorParams, "line").name("üìè ƒê∆∞·ªùng th·∫≥ng (ƒëi·ªÉm + vector)");
geomFolder.add(vectorParams, "para").name("üü¶ H√¨nh b√¨nh h√†nh (C·ªông 2 vector)");
geomFolder.add(vectorParams, "tri").name("üî∫ Tam gi√°c + G√≥c");
geomFolder.add(vectorParams, "cone").name("üõë H√¨nh n√≥n chi·∫øu vector");

// ===== GUI Danh s√°ch Vector =====
const listFolder = guiVector.addFolder("üìú Danh s√°ch Vector");

// Object l∆∞u control ƒë·ªÉ d·ªÖ x√≥a/refresh
const vectorListControls = {};

function refreshVectorList() {
  // X√≥a control c≈©
  for (let key in vectorListControls) {
    listFolder.remove(vectorListControls[key]);
    delete vectorListControls[key];
  }

  // T·∫°o control m·ªõi cho t·ª´ng vector
  vectorsHistory.forEach((vObj, idx) => {
    const name = `v${idx+1}: (${vObj.from.x.toFixed(1)},${vObj.from.y.toFixed(1)},${vObj.from.z.toFixed(1)}) ‚Üí (${vObj.to.x.toFixed(1)},${vObj.to.y.toFixed(1)},${vObj.to.z.toFixed(1)})`;

    vectorListControls[idx] = listFolder.add(
      {
        focus: () => focusOnVector(vObj),
        remove: () => removeVector(vObj)
      },
      "focus"
    ).name(name);

    // th√™m n√∫t x√≥a ri√™ng
    vectorListControls[`del${idx}`] = listFolder.add(
      {
        del: () => removeVector(vObj)
      },
      "del"
    ).name(`‚ùå X√≥a v${idx+1}`);
  });
}

// ===== Zoom camera t·ªõi vector =====
function focusOnVector(vObj) {
  const center = vObj.from.clone().add(vObj.to).multiplyScalar(0.5);
  const size = vObj.from.distanceTo(vObj.to);

  // di chuy·ªÉn camera ƒë·∫øn g·∫ßn vector
  const dir = camera.position.clone().sub(center).normalize();
  camera.position.copy(center.clone().add(dir.multiplyScalar(size * 3)));
  camera.lookAt(center);
}

// ===== X√≥a vector kh·ªèi worldGroup v√† l·ªãch s·ª≠ =====
function removeVector(vObj) {
  worldGroup.remove(vObj.arrow);
  if (vObj.dashedLine) worldGroup.remove(vObj.dashedLine);

  // X√≥a ƒëi·ªÉm ·ªü 2 ƒë·∫ßu
  [vObj.from, vObj.to].forEach(pos => {
    const p = drawParams.points.find(p => p.pos.equals(pos));
    if (p) {
      worldGroup.remove(p.mesh);
      worldGroup.remove(p.label);
      drawParams.points = drawParams.points.filter(pp => pp !== p);
    }
  });

  vectorsHistory = vectorsHistory.filter(v => v !== vObj);
  refreshVectorList();
}


// Nh√≥m Tr·ª£ gi√∫p
const helpFolder = guiVector.addFolder("‚ÑπÔ∏è Kh√°c");
helpFolder.add(vectorParams, "help").name("‚ùì Tr·ª£ gi√∫p");

// ================== LOGIC ==================

let vectorsHistory = []; // l∆∞u danh s√°ch vector ƒë√£ v·∫Ω
let points3D = []; // l∆∞u ƒëi·ªÉm 3D ƒë√£ add
let selectedVectors = []; // danh s√°ch vector ƒë√£ ch·ªçn

// V·∫Ω vector t·ª´ input
function drawVectorFromInput() {
  const { x1, y1, z1, x2, y2, z2 } = vectorParams;

  if ([x1, y1, z1, x2, y2, z2].some((v) => isNaN(v))) {
    alert("‚ö†Ô∏è Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß v√† h·ª£p l·ªá c√°c t·ªça ƒë·ªô.");
    return;
  }

  const from = new THREE.Vector3(x1, y1, z1);
  const to = new THREE.Vector3(x2, y2, z2);
  const dir = new THREE.Vector3().subVectors(to, from);
  const len = dir.length();

  const arrow = new THREE.ArrowHelper(
    dir.clone().normalize(),
    from,
    len,
    0x00ff00,
    1,
    0.5
  );
  arrow.userData.vectorData = { from, dir, to };
  worldGroup.add(arrow);

  vectorsHistory.push({
    from,
    to,
    dir,
    arrow,
    meshes: [arrow.cone, arrow.line], // üëà th√™m danh s√°ch con ƒë·ªÉ raycast
  });

  historyParams.addEntry(`Vector t·ª´ (${x1},${y1},${z1}) ‚Üí (${x2},${y2},${z2})`);

  
  const pointFrom = addPoint(from);  // tr·∫£ v·ªÅ { mesh, label }
  const pointTo   = addPoint(to);
  refreshVectorList(); // c·∫≠p nh·∫≠t danh s√°ch

}

// V·∫Ω ƒëi·ªÉm v√† nh√£n r√µ, ƒë·∫πp d·ª±a tr√™n createLabelSprite
function addPoint(pos, name) {
  // T·∫°o ƒëi·ªÉm
  const geometry = new THREE.SphereGeometry(0.1, 16, 16);
  const material = new THREE.MeshBasicMaterial({ color: 0xff3333 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(pos);
  worldGroup.add(mesh);

  // Nh√£n
  const labelText = name || `(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`;

  // T·∫°o canvas nh√£n gi·ªëng createLabelSprite nh∆∞ng scale l·ªõn h∆°n
  const fontSize = 6;     // ch·ªØ to
  const padding = 20;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  ctx.font = `${fontSize}px Arial`;
  const metrics = ctx.measureText(labelText);
  const textWidth = metrics.width;
  const textHeight = fontSize;

  canvas.width = textWidth + padding;
  canvas.height = textHeight + padding;

  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = "#ffffff";           // ch·ªØ ƒëen
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillText(labelText, canvas.width/2, canvas.height/2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;

  const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false });
  const label = new THREE.Sprite(spriteMaterial);
  
  // Scale nh√£n l·ªõn h∆°n ƒë·ªÉ d·ªÖ ƒë·ªçc
  const scaleFactor = 0.15;
  label.scale.set(canvas.width*scaleFactor, canvas.height*scaleFactor, 1);

  // ƒê·∫∑t nh√£n l·ªách ra kh·ªèi ƒëi·ªÉm
  label.position.copy(pos.clone().add(new THREE.Vector3(0.3,0.3,0.3)));
  worldGroup.add(label);

  drawParams.points.push({ mesh, label, pos, name: labelText });
  return { mesh, label, pos };
}




// ===== H√†m d·ª±ng vector ·∫£o n√©t ƒë·ª©t (d·ªãch v2 v·ªÅ chung g·ªëc v·ªõi v1) =====
function makeDashedClone(vObj1, vObj2, color = 0xff0000) {
  const origin = vObj1.from.clone();
  const v2 = vObj2.dir.clone();
  const dashedEnd = origin.clone().add(v2);

  const dashedGeometry = new THREE.BufferGeometry().setFromPoints([
    origin,
    dashedEnd,
  ]);
  const dashedMaterial = new THREE.LineDashedMaterial({
    color,
    dashSize: 0.2,
    gapSize: 0.1,
  });
  const dashedLine = new THREE.Line(dashedGeometry, dashedMaterial);
  dashedLine.computeLineDistances();
  worldGroup.add(dashedLine);

  return { origin, dashedDir: v2.clone(), dashedLine };
}

// ===== Chi·∫øu vector u l√™n vector v =====
function projectionVector() {
  if (selectedVectors.length < 2) {
    return alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn 2 vector (u v√† v).");
  }

  // L·∫•y 2 vector ƒë√£ ƒë∆∞a v·ªÅ c√πng g·ªëc
  const two = getTwoVectorsUnified();
  if (!two) return;

  const { v1, v2, base } = two;

  // T√≠nh projection
  const scalar = v1.dot(v2) / v2.lengthSq();
  const proj = v2.clone().multiplyScalar(scalar);

  // V·∫Ω vector chi·∫øu
  drawResultVector(base, proj, 0x00ffff, "üìç Projection (u l√™n v)");

  alert(
    `üìç Chi·∫øu v1 l√™n v2 = (${proj.x.toFixed(3)}, ${proj.y.toFixed(
      3
    )}, ${proj.z.toFixed(3)})`
  );
}
// ===== Triple scalar product (th·ªÉ t√≠ch kh·ªëi h·ªôp) =====
function tripleProductFromHistory() {
  if (selectedVectors.length < 3) {
    return alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn 3 vector (click v√†o m≈©i t√™n).");
  }

  const v1 = selectedVectors[0].dir.clone();
  const v2 = selectedVectors[1].dir.clone();
  const v3 = selectedVectors[2].dir.clone();

  // triple product
  const cross = new THREE.Vector3().crossVectors(v2, v3);
  const scalarTriple = v1.dot(cross);
  const volume = Math.abs(scalarTriple);

  alert(`üì¶ Th·ªÉ t√≠ch kh·ªëi h·ªôp = ${volume.toFixed(3)}`);

  // ---- Hi·ªÉn th·ªã h√¨nh h·ªôp song song ----
  const origin = new THREE.Vector3(0, 0, 0);

  // 8 ƒë·ªânh c·ªßa h√¨nh h·ªôp
  const vertices = [
    origin, 
    v1, 
    v2, 
    v3, 
    v1.clone().add(v2), 
    v1.clone().add(v3), 
    v2.clone().add(v3), 
    v1.clone().add(v2).add(v3)
  ];

  // C√°c m·∫∑t (theo ch·ªâ s·ªë ƒë·ªânh)
  const faces = [
    [0,1,4,2], // ƒë√°y
    [0,1,5,3], 
    [0,2,6,3],
    [7,4,1,5],
    [7,6,2,4],
    [7,5,3,6]  // n·∫Øp
  ];

  // X√≥a kh·ªëi c≈© n·∫øu c√≥
  if (window.parallelepipedMesh) {
    worldGroup.remove(window.parallelepipedMesh);
  }

  // Geometry t·ª´ ƒë·ªânh v√† m·∫∑t
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const indices = [];

  // push vertices
  vertices.forEach(v => {
    positions.push(v.x, v.y, v.z);
  });

  // push faces (2 tam gi√°c / m·∫∑t)
  faces.forEach(face => {
    indices.push(face[0], face[1], face[2]);
    indices.push(face[2], face[3], face[0]);
  });

  geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  // T·∫°o mesh trong su·ªët ƒë·ªÉ d·ªÖ h√¨nh dung
  const material = new THREE.MeshStandardMaterial({
    color: 0x00ffcc,
    transparent: true,
    opacity: 0.4,
    side: THREE.DoubleSide
  });

  const mesh = new THREE.Mesh(geometry, material);
  worldGroup.add(mesh);

  window.parallelepipedMesh = mesh;
}
function doubleCrossProductFromHistory() {
  if (selectedVectors.length < 3) {
    return alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn 3 vector (a, b, c).");
  }

  const a = selectedVectors[0].dir.clone();
  const b = selectedVectors[1].dir.clone();
  const c = selectedVectors[2].dir.clone();

  // (a√ób)√óc
  const ab = new THREE.Vector3().crossVectors(a, b);
  const result = new THREE.Vector3().crossVectors(ab, c);

  // V·∫Ω k·∫øt qu·∫£ t·ª´ g·ªëc (0,0,0)
  drawResultVector(new THREE.Vector3(0,0,0), result, 0x8800ff, "üåÄ (a√ób)√óc");

  alert(
    `üåÄ (a√ób)√óc = (${result.x.toFixed(3)}, ${result.y.toFixed(3)}, ${result.z.toFixed(3)})`
  );
}

function drawParallelogram() {
  const two = getTwoVectorsUnified();
  if (!two) return;
  const { v1, v2, base } = two;

  // 4 ƒë·ªânh h√¨nh b√¨nh h√†nh
  const A = base.clone();
  const B = base.clone().add(v1);
  const C = base.clone().add(v2);
  const D = base.clone().add(v1).add(v2);

  const vertices = [A, B, D, C]; // theo th·ª© t·ª±
  const geom = new THREE.BufferGeometry().setFromPoints(vertices.concat([A]));
  const mat = new THREE.LineBasicMaterial({ color: 0x00ffcc });
  const line = new THREE.LineLoop(geom, mat);

  worldGroup.add(line);

  // V·∫Ω m·∫∑t m·ªù
  const shapeGeom = new THREE.BufferGeometry();
  const positions = [
    A.x, A.y, A.z,
    B.x, B.y, B.z,
    D.x, D.y, D.z,
    C.x, C.y, C.z
  ];
  const indices = [0,1,2, 0,2,3];
  shapeGeom.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
  shapeGeom.setIndex(indices);
  shapeGeom.computeVertexNormals();

  const shapeMat = new THREE.MeshStandardMaterial({
    color: 0x00ffcc,
    transparent: true,
    opacity: 0.3,
    side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(shapeGeom, shapeMat);
  worldGroup.add(mesh);

  historyParams.addEntry("üü¶ V·∫Ω h√¨nh b√¨nh h√†nh t·ª´ 2 vector");
}
function drawTriangleBetweenVectors() {
  const two = getTwoVectorsUnified();
  if (!two) return;
  const { v1, v2, base } = two;

  const A = base.clone();
  const B = base.clone().add(v1);
  const C = base.clone().add(v2);

  const geom = new THREE.BufferGeometry().setFromPoints([A,B,C,A]);
  const mat = new THREE.LineBasicMaterial({ color: 0xff00ff });
  const line = new THREE.Line(geom, mat);
  worldGroup.add(line);

  // V·∫Ω m·∫∑t m·ªù tam gi√°c
  const triGeom = new THREE.BufferGeometry();
  const positions = [
    A.x,A.y,A.z,
    B.x,B.y,B.z,
    C.x,C.y,C.z
  ];
  triGeom.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
  triGeom.setIndex([0,1,2]);
  triGeom.computeVertexNormals();

  const triMat = new THREE.MeshStandardMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 0.3,
    side: THREE.DoubleSide
  });
  const triMesh = new THREE.Mesh(triGeom, triMat);
  worldGroup.add(triMesh);

  // V·∫Ω cung g√≥c
  createVectorAngleArcWithDashed(selectedVectors[0], selectedVectors[1], 1.5, 32);

  historyParams.addEntry("üî∫ V·∫Ω tam gi√°c v√† cung g√≥c gi·ªØa 2 vector");
}
function drawProjectionCone() {
  if (selectedVectors.length < 2) {
    return alert("‚ö†Ô∏è Ch·ªçn 2 vector: u (chi·∫øu) v√† v (tr·ª•c).");
  }

  const two = getTwoVectorsUnified();
  if (!two) return;
  const { v1, v2, base } = two;

  const u = v1.clone().normalize();
  const axis = v2.clone().normalize();
  const angle = u.angleTo(axis);

  // V·∫Ω h√¨nh n√≥n v·ªõi tr·ª•c = v2
  const height = v2.length();
  const radius = Math.tan(angle) * height;

  const coneGeom = new THREE.ConeGeometry(radius, height, 32, 1, true);
  const coneMat = new THREE.MeshStandardMaterial({
    color: 0xffff00,
    transparent: true,
    opacity: 0.25,
    side: THREE.DoubleSide
  });
  const cone = new THREE.Mesh(coneGeom, coneMat);

  // CƒÉn ch·ªânh theo tr·ª•c v2
  cone.position.copy(base.clone().add(axis.clone().multiplyScalar(height/2)));
  cone.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), axis.clone().normalize());

  worldGroup.add(cone);

  historyParams.addEntry(`üõë H√¨nh n√≥n chi·∫øu vector l√™n tr·ª•c, g√≥c = ${(THREE.MathUtils.radToDeg(angle)).toFixed(2)}¬∞`);
}

// ===== L·∫•y 2 vector ƒë√£ ƒë∆∞a v·ªÅ c√πng g·ªëc =====
function getTwoVectorsUnified() {
  if (selectedVectors.length < 2) {
    alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn 2 vector (click v√†o m≈©i t√™n).");
    return null;
  }

  const vObj1 = selectedVectors[0];
  const vObj2 = selectedVectors[1];

  // D·ª±ng vector ·∫£o n√©t ƒë·ª©t cho v2 v·ªÅ g·ªëc c·ªßa v1
  const { origin, dashedDir, dashedLine } = makeDashedClone(vObj1, vObj2);

  // L∆∞u tham chi·∫øu ƒë·ªÉ x√≥a khi c·∫ßn
  vObj1.dashedLine && worldGroup.remove(vObj1.dashedLine);
  vObj2.dashedLine && worldGroup.remove(vObj2.dashedLine);
  vObj2.dashedLine = dashedLine;

  return { v1: vObj1.dir.clone(), v2: dashedDir, base: origin };
}
// ===== V·∫Ω cung g√≥c gi·ªØa 2 vector (d√πng vector ·∫£o n√©t ƒë·ª©t) =====
function createVectorAngleArcWithDashed(
  vObj1,
  vObj2,
  radius = 2,
  segments = 32
) {
  // L·∫•y g·ªëc chung
  const origin = vObj1.from.clone();

  // Vector g·ªëc v√† vector ·∫£o ƒë√£ d·ªãch
  const v1 = vObj1.dir.clone().normalize();
  const v2 = vObj2.dir.clone().normalize();

  // T·∫°o quaternion ƒë·ªÉ quay t·ª´ v1 sang v2
  const angle = v1.angleTo(v2);
  const axis = new THREE.Vector3().crossVectors(v1, v2).normalize();

  // N·∫øu 2 vector song song ‚Üí kh√¥ng t·∫°o cung
  if (axis.length() < 1e-6) {
    return { arc: null };
  }

  // T·∫°o c√°c ƒëi·ªÉm cung tr√≤n
  const points = [];
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * angle;
    const q = new THREE.Quaternion().setFromAxisAngle(axis, t);
    const dir = v1.clone().applyQuaternion(q);
    points.push(origin.clone().add(dir.multiplyScalar(radius)));
  }

  // V·∫Ω cung n√©t li·ªÅn
  const arcGeometry = new THREE.BufferGeometry().setFromPoints(points);
  const arcMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
  const arc = new THREE.Line(arcGeometry, arcMaterial);
  worldGroup.add(arc);

  return { arc };
}

// ===== C√°c ph√©p to√°n =====
// ===== Ki·ªÉm tra quan h·ªá gi·ªØa 2 vector =====
function checkVectorRelations() {
  const two = getTwoVectorsUnified();
  if (!two) return;

  const { v1, v2, base } = two;
  const dot = v1.dot(v2);
  const cross = new THREE.Vector3().crossVectors(v1, v2);
  const isOrthogonal = Math.abs(dot) < 1e-6;
  const isParallel = cross.length() < 1e-6;
  let isSame = false;

  // Ki·ªÉm tra tr√πng nhau: song song + c√πng h∆∞·ªõng + c√πng g·ªëc
  if (isParallel) {
    const ratioX = v1.x !== 0 ? v2.x / v1.x : null;
    const ratioY = v1.y !== 0 ? v2.y / v1.y : null;
    const ratioZ = v1.z !== 0 ? v2.z / v1.z : null;

    // L·∫•y c√°c t·ªâ s·ªë h·ª£p l·ªá (kh√¥ng NaN, kh√¥ng Infinity)
    const ratios = [ratioX, ratioY, ratioZ].filter(
      (r) => r !== null && isFinite(r)
    );
    if (
      ratios.length > 0 &&
      ratios.every((r) => Math.abs(r - ratios[0]) < 1e-6)
    ) {
      // C√πng g·ªëc?
      const sameOrigin =
        selectedVectors[0].from.distanceTo(selectedVectors[1].from) < 1e-6;
      isSame = sameOrigin;
    }
  }

  let msg = "üìä Quan h·ªá gi·ªØa 2 vector:\n";
  msg += isOrthogonal ? "‚úÖ Vu√¥ng g√≥c\n" : "‚ùå Kh√¥ng vu√¥ng g√≥c\n";
  msg += isParallel ? "‚úÖ Song song\n" : "‚ùå Kh√¥ng song song\n";
  msg += isSame ? "‚úÖ Tr√πng nhau\n" : "‚ùå Kh√¥ng tr√πng nhau\n";

  alert(msg);
}

// ===== Kho·∫£ng c√°ch gi·ªØa 2 vector =====
function distanceBetweenVectors() {
  if (selectedVectors.length < 2) {
    return alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn 2 vector.");
  }

  const a1 = selectedVectors[0].from.clone();
  const a2 = selectedVectors[0].to.clone();
  const b1 = selectedVectors[1].from.clone();
  const b2 = selectedVectors[1].to.clone();

  const u = new THREE.Vector3().subVectors(a2, a1);
  const v = new THREE.Vector3().subVectors(b2, b1);
  const w0 = new THREE.Vector3().subVectors(a1, b1);

  const uxv = new THREE.Vector3().crossVectors(u, v);
  const denom = uxv.length();

  let dist;
  if (denom < 1e-6) {
    // 2 vector song song ‚Üí l·∫•y kho·∫£ng c√°ch t·ª´ ƒëi·ªÉm ƒë·∫øn ƒë∆∞·ªùng
    const w0xu = new THREE.Vector3().crossVectors(w0, u);
    dist = w0xu.length() / u.length();
  } else {
    dist = Math.abs(w0.dot(uxv)) / denom;
  }

  alert(`üìè Kho·∫£ng c√°ch gi·ªØa 2 vector = ${dist.toFixed(3)}`);
}

// ƒê·ªô d√†i vector cu·ªëi c√πng
function getVectorLength() {
  if (vectorsHistory.length === 0) return alert("‚ö†Ô∏è Ch∆∞a c√≥ vector n√†o.");
  const v = vectorsHistory.at(-1).dir;
  alert(`üìè ƒê·ªô d√†i = ${v.length().toFixed(3)}`);
}

// Vector ƒë∆°n v·ªã
function getUnitVector() {
  if (vectorsHistory.length === 0) return alert("‚ö†Ô∏è Ch∆∞a c√≥ vector n√†o.");
  const v = vectorsHistory.at(-1).dir.clone().normalize();
  alert(
    `‚ÜîÔ∏è Vector ƒë∆°n v·ªã = (${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(
      3
    )})`
  );
}

// C·ªông vector
function addSelectedVectors() {
  if (selectedVectors.length < 2) {
    return alert("‚ö†Ô∏è Ch·ªçn √≠t nh·∫•t 2 vector ƒë·ªÉ t√≠nh t·ªïng.");
  }

  const base = selectedVectors[0].from.clone();
  let sum = new THREE.Vector3(0, 0, 0);

  selectedVectors.forEach(v => sum.add(v.dir));

  drawResultVector(base, sum, 0x0000ff, "‚ûï T·ªïng nhi·ªÅu vector");
  alert(`T·ªïng vector = (${sum.x.toFixed(3)}, ${sum.y.toFixed(3)}, ${sum.z.toFixed(3)})`);
}


// Tr·ª´ vector
function subSelectedVectors() {
  if (selectedVectors.length < 2) {
    return alert("‚ö†Ô∏è Ch·ªçn √≠t nh·∫•t 2 vector ƒë·ªÉ t√≠nh hi·ªáu.");
  }

  const base = selectedVectors[0].from.clone();
  let result = selectedVectors[0].dir.clone();

  for (let i = 1; i < selectedVectors.length; i++) {
    result.sub(selectedVectors[i].dir);
  }

  drawResultVector(base, result, 0xff00ff, "‚ûñ Hi·ªáu nhi·ªÅu vector");
  alert(`Hi·ªáu vector = (${result.x.toFixed(3)}, ${result.y.toFixed(3)}, ${result.z.toFixed(3)})`);
}


// Dot
function dotSelectedVectors() {
  if (selectedVectors.length < 2) return alert("‚ö†Ô∏è Ch·ªçn √≠t nh·∫•t 2 vector.");

  let result = selectedVectors[0].dir.dot(selectedVectors[1].dir);
  if (selectedVectors.length > 2) {
    for (let i = 2; i < selectedVectors.length; i++) {
      result *= selectedVectors[i].dir.length(); // ho·∫∑c tu·ª≥ ch·ªçn: ti·∫øp t·ª•c dot v·ªõi chi·ªÅu d√†i
    }
  }

  alert(`‚ú¥Ô∏è T√≠ch v√¥ h∆∞·ªõng nhi·ªÅu vector (approx) = ${result.toFixed(3)}`);
}


// Cross
function crossSelectedVectors() {
  if (selectedVectors.length < 2) return alert("‚ö†Ô∏è Ch·ªçn √≠t nh·∫•t 2 vector.");

  let result = selectedVectors[0].dir.clone();
  for (let i = 1; i < selectedVectors.length; i++) {
    result = new THREE.Vector3().crossVectors(result, selectedVectors[i].dir);
  }

  drawResultVector(new THREE.Vector3(0,0,0), result, 0xff8800, "‚úñÔ∏è T√≠ch c√≥ h∆∞·ªõng nhi·ªÅu vector");
  alert(`‚úñÔ∏è Cross product nhi·ªÅu vector = (${result.x.toFixed(3)}, ${result.y.toFixed(3)}, ${result.z.toFixed(3)})`);
}


// ===== G√≥c gi·ªØa 2 vector =====
function angleBetweenFromHistory() {
  const two = getTwoVectorsUnified();
  if (!two) return;

  const { v1, v2, base } = two;
  const cosTheta = v1.dot(v2) / (v1.length() * v2.length());
  const angleRad = Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));
  const angleDeg = THREE.MathUtils.radToDeg(angleRad);

  alert(`üìê G√≥c = ${angleDeg.toFixed(2)}¬∞`);

  // V·∫Ω cung
  if (selectedVectors.length === 2) {
    if (selectedVectors[0].angleArc) worldGroup.remove(selectedVectors[0].angleArc);
    if (selectedVectors[1].angleArc) worldGroup.remove(selectedVectors[1].angleArc);

    const { arc } = createVectorAngleArcWithDashed(
      selectedVectors[0],
      selectedVectors[1],
      2,
      32
    );

    selectedVectors[0].angleArc = arc;
    selectedVectors[1].angleArc = arc;
  }
}
// ===== Nh√¢n vector v·ªõi s·ªë =====
function scalarMultiplyFromHistory() {
  if (selectedVectors.length < 1) {
    return alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn 1 vector.");
  }

  const vObj = selectedVectors[0];
  const factor = vectorParams.scalarValue;

  const result = vObj.dir.clone().multiplyScalar(factor);
  drawResultVector(
    vObj.from.clone(),
    result,
    0x00ffff,
    `üìà ${factor} √ó Vector`
  );
}
function createPlaneFromTwoVectors() {
  if (selectedVectors.length < 2) {
    return alert("‚ö†Ô∏è Vui l√≤ng ch·ªçn 2 vector.");
  }

  const { v1, v2, base } = getTwoVectorsUnified();
  if (!v1 || !v2) return;

  const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
  if (normal.length() < 1e-6) {
    return alert("‚ö†Ô∏è Hai vector song song, kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c m·∫∑t ph·∫≥ng.");
  }

  // V·∫Ω m·∫∑t ph·∫≥ng
  const planeSize = 10;
  const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
  const planeMat = new THREE.MeshBasicMaterial({
    color: 0x8888ff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.4
  });
  const planeMesh = new THREE.Mesh(planeGeom, planeMat);

  // Xoay m·∫∑t ph·∫≥ng theo ph√°p tuy·∫øn
  const quat = new THREE.Quaternion().setFromUnitVectors(
    new THREE.Vector3(0, 0, 1), normal
  );
  planeMesh.setRotationFromQuaternion(quat);
  planeMesh.position.copy(base);

  worldGroup.add(planeMesh);

  historyParams.addEntry(
    `üìÑ M·∫∑t ph·∫≥ng ph√°p tuy·∫øn = (${normal.x.toFixed(2)}, ${normal.y.toFixed(2)}, ${normal.z.toFixed(2)})`
  );
}
function createLineFromPointAndVector() {
  if (selectedVectors.length < 1 || points3D.length < 1) {
    return alert("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 1 vector v√† 1 ƒëi·ªÉm.");
  }

  const vObj = selectedVectors[0];
  const dir = vObj.dir.clone().normalize();

  const p = points3D.at(-1).pos.clone(); // l·∫•y ƒëi·ªÉm cu·ªëi v·ª´a th√™m

  const length = 20;
  const lineGeom = new THREE.BufferGeometry().setFromPoints([
    p.clone().sub(dir.clone().multiplyScalar(length/2)),
    p.clone().add(dir.clone().multiplyScalar(length/2))
  ]);
  const lineMat = new THREE.LineBasicMaterial({ color: 0xff0000 });
  const line = new THREE.Line(lineGeom, lineMat);
  worldGroup.add(line);

  historyParams.addEntry(
    `üìè ƒê∆∞·ªùng th·∫≥ng ƒëi qua (${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}) theo vector (${dir.x.toFixed(2)}, ${dir.y.toFixed(2)}, ${dir.z.toFixed(2)})`
  );
}

// ===== V·∫Ω vector k·∫øt qu·∫£ =====
function drawResultVector(origin, dir, color, name) {
  const arrow = new THREE.ArrowHelper(
    dir.clone().normalize(),
    origin,
    dir.length(),
    color,
    1,
    0.5
  );
  worldGroup.add(arrow);
  historyParams.addEntry(
    `${name}: (${dir.x.toFixed(2)}, ${dir.y.toFixed(2)}, ${dir.z.toFixed(2)})`
  );
}

// T·∫°o container trong GUI
const handControlParams = {
  enabled: false,
  sensitivity: 1.0,
  cameraOn: false, // üëà tr·∫°ng th√°i b·∫≠t/t·∫Øt cam
};

const guiHand = guiHelper.addTab("C·ª≠ ch·ªâ tay", 300, {
  icon: "üñêÔ∏è",
  label: "C·ª≠ ch·ªâ tay",
});
guiHand.add(handControlParams, "enabled").name("‚úÖ K√≠ch ho·∫°t");
guiHand.add(handControlParams, "sensitivity", 0.1, 3, 0.1).name("üéöÔ∏è ƒê·ªô nh·∫°y");

// ========== T·∫°o khung giao di·ªán trong GUI ==========

// Container ri√™ng ƒë·ªÉ tr√°nh ƒë√® l√™n n√∫t close
const handContainer = document.createElement("div");
handContainer.style.display = "flex";
handContainer.style.flexDirection = "column";
handContainer.style.gap = "8px";
handContainer.style.marginTop = "28px"; // ch·ª´a kho·∫£ng tr√™n cho n√∫t close

// Tr·∫°ng th√°i camera
const statusEl = document.createElement("div");
statusEl.style.padding = "4px";
statusEl.style.fontSize = "14px";
statusEl.style.color = "#0f0";
statusEl.textContent = "‚åõ ƒêang ch·ªù b·∫≠t camera...";
handContainer.appendChild(statusEl);

// Video ·∫©n ƒë·ªÉ x·ª≠ l√Ω
const videoElement = document.createElement("video");
videoElement.autoplay = true;
videoElement.playsInline = true;
videoElement.muted = true;
videoElement.style.display = "none";
handContainer.appendChild(videoElement);

// Canvas hi·ªÉn th·ªã camera + x·ª≠ l√Ω
const canvasElement = document.createElement("canvas");
canvasElement.width = 640;
canvasElement.height = 480;
canvasElement.style.width = "100%";
canvasElement.style.border = "1px solid #333";
canvasElement.style.borderRadius = "8px";
const canvasCtx = canvasElement.getContext("2d");
handContainer.appendChild(canvasElement);

// N√∫t b·∫≠t/t·∫Øt camera
const camBtn = document.createElement("button");
camBtn.textContent = "üì∑ B·∫≠t Camera";
camBtn.style.padding = "6px 10px";
camBtn.style.borderRadius = "6px";
camBtn.style.border = "1px solid #555";
camBtn.style.background = "#222";
camBtn.style.color = "#0f0";
camBtn.style.cursor = "pointer";
camBtn.style.alignSelf = "flex-start";
handContainer.appendChild(camBtn);

// Th√™m container v√†o tab GUI
guiHand.domElement.appendChild(handContainer);

function setStatus(msg) {
  statusEl.textContent = msg;
}

// Kh·ªüi t·∫°o Mediapipe Hands
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.5,
});

hands.onResults((results) => {
  if (!handControlParams.enabled) return; // üö´ t·∫Øt n·∫øu ch∆∞a b·∫≠t

  canvasCtx.save();
  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
  canvasCtx.drawImage(
    results.image,
    0,
    0,
    canvasElement.width,
    canvasElement.height
  );

  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    setStatus(`üôå Ph√°t hi·ªán ${results.multiHandLandmarks.length} b√†n tay`);

    // V·∫Ω t·∫•t c·∫£ b√†n tay
    for (const landmarks of results.multiHandLandmarks) {
      drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
        color: "#00FF00",
        lineWidth: 1,
      });
      drawLandmarks(canvasCtx, landmarks, { color: "#FF0000", lineWidth: 1 });
    }

    const hand1 = results.multiHandLandmarks[0];

    // üëâ Xoay camera theo ng√≥n tr·ªè b√†n tay ƒë·∫ßu ti√™n
    const indexFinger = hand1[8];
    const rotateX = indexFinger.x - 0.5;
    const rotateY = indexFinger.y - 0.5;

    camera.position.applyAxisAngle(
      new THREE.Vector3(0, 1, 0),
      -rotateX * 0.1 * handControlParams.sensitivity
    );
    camera.position.applyAxisAngle(
      new THREE.Vector3(1, 0, 0),
      -rotateY * 0.1 * handControlParams.sensitivity
    );

    // üëâ Di chuy·ªÉn (pan) camera theo v·ªã tr√≠ c·ªï tay b√†n tay ƒë·∫ßu ti√™n
    const wrist = hand1[0];
    const moveX = (wrist.x - 0.5) * 2 * handControlParams.sensitivity;
    const moveY = (wrist.y - 0.5) * 2 * handControlParams.sensitivity;

    camera.position.x += moveX;
    camera.position.y -= moveY; // canvas Y ng∆∞·ª£c
    controls.target.x += moveX;
    controls.target.y -= moveY;

    // üëâ Zoom n·∫øu c√≥ ƒë·ªß 2 b√†n tay theo kho·∫£ng c√°ch gi·ªØa c·ªï tay
    if (results.multiHandLandmarks.length >= 2) {
      const hand2 = results.multiHandLandmarks[1];
      const wrist1 = hand1[0];
      const wrist2 = hand2[0];

      const dx = wrist1.x - wrist2.x;
      const dy = wrist1.y - wrist2.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      camera.position.multiplyScalar(
        1 + (0.5 - dist) * 0.05 * handControlParams.sensitivity
      );
    }

    camera.lookAt(controls.target);
    controls.update();
  } else {
    setStatus("üïµÔ∏è Kh√¥ng ph√°t hi·ªán b√†n tay n√†o");
  }

  canvasCtx.restore();
});

// Kh·ªüi t·∫°o Camera nh∆∞ng ch∆∞a start
const cameraHand = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({ image: videoElement });
  },
  width: 640,
  height: 480,
});

// Toggle camera khi nh·∫•n n√∫t
camBtn.addEventListener("click", () => {
  if (!handControlParams.cameraOn) {
    cameraHand
      .start()
      .then(() => {
        setStatus("üé• Camera ƒë√£ b·∫≠t. ƒêang nh·∫≠n di·ªán b√†n tay...");
        camBtn.textContent = "üì¥ T·∫Øt Camera";
        handControlParams.cameraOn = true;
      })
      .catch((err) => {
        setStatus("‚ùå Kh√¥ng m·ªü ƒë∆∞·ª£c camera: " + err.message);
      });
  } else {
    // D·ª´ng camera th·ªß c√¥ng
    if (videoElement.srcObject) {
      videoElement.srcObject.getTracks().forEach((track) => track.stop());
      videoElement.srcObject = null;
    }
    setStatus("‚èπÔ∏è Camera ƒë√£ t·∫Øt.");
    camBtn.textContent = "üì∑ B·∫≠t Camera";
    handControlParams.cameraOn = false;
  }
});

// ‚úÖ H√†m n·ªôi suy tuy·∫øn t√≠nh
const lerp = (a, b, t) => a + (b - a) * t;

// ‚úÖ T·∫°o ƒëi·ªÉm t·ª´ h√†m 1 bi·∫øn
function createParametricPoints(fn, [t0, t1], steps) {
  return Array.from({ length: steps + 1 }, (_, i) =>
    fn(lerp(t0, t1, i / steps))
  );
}

// ‚úÖ T·∫°o ƒëo·∫°n n·ªëi t·ª´ h√†m 2 bi·∫øn (u, v)
function createParametricSegments(fn, [u0, u1], [v0, v1], segments) {
  const points = [];

  for (let i = 1; i < segments; i++) {
    const u = lerp(u0, u1, i / segments);
    for (let j = 0; j < segments; j++) {
      const v1a = lerp(v0, v1, j / segments);
      const v1b = lerp(v0, v1, (j + 1) / segments);
      points.push(fn(u, v1a), fn(u, v1b)); // vƒ© tuy·∫øn
    }
  }

  for (let j = 0; j < segments; j++) {
    const v = lerp(v0, v1, j / segments);
    for (let i = 0; i < segments; i++) {
      const u1a = lerp(u0, u1, i / segments);
      const u1b = lerp(u0, u1, (i + 1) / segments);
      points.push(fn(u1a, v), fn(u1b, v)); // kinh tuy·∫øn
    }
  }

  return points;
}
// geometryFunctions.js

// üéØ M·∫∑t c·∫ßu 3D
function sphere3D(theta, phi, r = 5) {
  return new THREE.Vector3(
    r * Math.sin(theta) * Math.cos(phi),
    r * Math.sin(theta) * Math.sin(phi),
    r * Math.cos(theta)
  );
}

// ‚ù§Ô∏è Tr√°i tim 3D
function heart3D(t, s = 2.5) {
  return new THREE.Vector3(
    s * 16 * Math.pow(Math.sin(t), 3),
    s *
      (13 * Math.cos(t) -
        5 * Math.cos(2 * t) -
        2 * Math.cos(3 * t) -
        Math.cos(4 * t)),
    s * 4 * Math.sin(2 * t)
  );
}
// üî∑ H√¨nh xuy·∫øn (Torus)
function torus3D(u, v, R = 4, r = 1.5) {
  return new THREE.Vector3(
    (R + r * Math.cos(v)) * Math.cos(u),
    (R + r * Math.cos(v)) * Math.sin(u),
    r * Math.sin(v)
  );
}

// üî∑ S√≥ng Sin 3D
function wave3D(x, z, A = 1, f = 1) {
  return new THREE.Vector3(x, A * Math.sin(f * (x ** 2 + z ** 2)), z);
}

// üî∑ H√¨nh xo·∫Øn ·ªëc
function spiral3D(t, a = 0.1, b = 0.2) {
  return new THREE.Vector3(a * t * Math.cos(t), a * t * Math.sin(t), b * t);
}

// üî∑ M·∫∑t y√™n ng·ª±a (Hyperbolic Paraboloid)
function saddle3D(x, z) {
  return new THREE.Vector3(x, x * x - z * z, z);
}

// üî∑ Elipsoid
function ellipsoid3D(theta, phi, rx = 4, ry = 2, rz = 1.5) {
  return new THREE.Vector3(
    rx * Math.sin(theta) * Math.cos(phi),
    ry * Math.sin(theta) * Math.sin(phi),
    rz * Math.cos(theta)
  );
}
// üî∂ M·∫∑t Parabol 3D
function paraboloid3D(x, z, a = 0.5) {
  return new THREE.Vector3(x, a * (x * x + z * z), z);
}
// üî∂ M·∫∑t s√≥ng Sin-Cos 3D
function sincosWave3D(x, z, a = 1) {
  return new THREE.Vector3(x, a * Math.sin(x) * Math.cos(z), z);
}
// üî∂ Mobius Strip (D·∫£i Mobius)
function mobius3D(u, v, R = 2) {
  const halfV = v / 2;
  return new THREE.Vector3(
    Math.cos(u) * (R + halfV * Math.cos(u / 2)),
    Math.sin(u) * (R + halfV * Math.cos(u / 2)),
    halfV * Math.sin(u / 2)
  );
}
// üî∂ H√¨nh Ch√≥p Xoay (Cone)
function cone3D(theta, h, r = 1) {
  return new THREE.Vector3(
    r * (1 - h) * Math.cos(theta),
    h,
    r * (1 - h) * Math.sin(theta)
  );
}
// üî∂ Cycloid 3D
function cycloid3D(t, r = 1) {
  return new THREE.Vector3(r * (t - Math.sin(t)), 0, r * (1 - Math.cos(t)));
}

// üéØ T·∫°o c√°c ƒë·ªëi t∆∞·ª£ng h√¨nh h·ªçc
const heart = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(
    createParametricPoints(heart3D, [0, Math.PI * 2], 500)
  ),
  new THREE.LineBasicMaterial({ color: 0xff66cc })
);

const sphere = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(sphere3D, [0, Math.PI], [0, Math.PI * 2], 30)
  ),
  new THREE.LineBasicMaterial({ color: 0x66ccff })
);

const torus = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(torus3D, [0, Math.PI * 2], [0, Math.PI * 2], 50)
  ),
  new THREE.LineBasicMaterial({ color: 0xffcc00 })
);

const spiral = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(
    createParametricPoints(spiral3D, [0, 10 * Math.PI], 1000)
  ),
  new THREE.LineBasicMaterial({ color: 0x00ff99 })
);

const wave = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(wave3D, [-5, 5], [-5, 5], 50)
  ),
  new THREE.LineBasicMaterial({ color: 0x3366ff })
);

const saddle = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(saddle3D, [-3, 3], [-3, 3], 50)
  ),
  new THREE.LineBasicMaterial({ color: 0xff6666 })
);

const ellipsoid = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(ellipsoid3D, [0, Math.PI], [0, Math.PI * 2], 30)
  ),
  new THREE.LineBasicMaterial({ color: 0x00ccff })
);
// üî∂ M·∫∑t Parabol 3D
const paraboloid = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(paraboloid3D, [-3, 3], [-3, 3], 50)
  ),
  new THREE.LineBasicMaterial({ color: 0xcc00cc })
);

// üî∂ S√≥ng Sin-Cos 3D
const sincosWave = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(sincosWave3D, [-5, 5], [-5, 5], 50)
  ),
  new THREE.LineBasicMaterial({ color: 0x00cccc })
);

// üî∂ D·∫£i Mobius
const mobius = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(mobius3D, [0, Math.PI * 2], [-1, 1], 100)
  ),
  new THREE.LineBasicMaterial({ color: 0xff9966 })
);

// üî∂ H√¨nh Ch√≥p Xoay (Cone)
const cone = new THREE.LineSegments(
  new THREE.BufferGeometry().setFromPoints(
    createParametricSegments(cone3D, [0, Math.PI * 2], [0, 1], 50)
  ),
  new THREE.LineBasicMaterial({ color: 0x9999ff })
);

// üî∂ Cycloid 3D
const cycloid = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints(
    createParametricPoints(cycloid3D, [0, 4 * Math.PI], 300)
  ),
  new THREE.LineBasicMaterial({ color: 0xffcc99 })
);

// ‚úÖ Danh s√°ch ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ x·ª≠ l√Ω chung
const allObjects = {
  heart,
  sphere,
  torus,
  spiral,
  wave,
  saddle,
  ellipsoid,
  paraboloid,
  sincosWave,
  mobius,
  cone,
  cycloid,
};

Object.values(allObjects).forEach((obj) => {
  obj.visible = false;
  worldGroup.add(obj);
});

// Toggle visibility
function toggle(...objects) {
  objects.forEach((obj) => {
    if (obj) obj.visible = !obj.visible;
  });
}

// V·∫Ω ƒë·ªì th·ªã m·∫∑t
let surfaceMesh;
let formulaLabel; // th√™m d√≤ng n√†y

function plotSurface(options = {}) {
  // L·∫•y tham s·ªë t·ª´ options ho·∫∑c d√πng m·∫∑c ƒë·ªãnh
  const {
    formula = "z=x^2+y^2",
    mode = "surface",
    resolution = 50,
    lightMode = "soft",
    xMin = -5,
    xMax = 5,
    yMin = -5,
    yMax = 5,
  } = options;

  // Chu·∫©n h√≥a c√¥ng th·ª©c
  let formulaRaw = formula
    .toLowerCase()
    .replace(/‚àí/g, "-") // d·∫•u tr·ª´ unicode
    .replace(/√ó/g, "*") // d·∫•u nh√¢n unicode
    .replace(/√∑/g, "/") // d·∫•u chia unicode
    .replace(/\s+/g, ""); // xo√° kho·∫£ng tr·∫Øng

  // X√°c ƒë·ªãnh bi·∫øn ph·ª• thu·ªôc
  let depVar = null;
  const vars = ["x", "y", "z"];
  let indepVars = [];

  for (let v of vars) {
    if (formulaRaw.startsWith(v + "=")) {
      depVar = v;
      indepVars = vars.filter((w) => w !== v);
      break;
    }
  }

  if (!depVar) {
    alert("‚ùó Vui l√≤ng nh·∫≠p c√¥ng th·ª©c d∆∞·ªõi d·∫°ng: z = f(x, y)");
    return;
  }

  const exprBody = formulaRaw.split("=")[1];
  let expr;
  try {
    expr = math.compile(exprBody);
  } catch (e) {
    alert("L·ªói c√¥ng th·ª©c: " + e.message);
    return;
  }

  // Xo√° mesh c≈© n·∫øu c√≥
  if (surfaceMesh) worldGroup.remove(surfaceMesh);

  const geometry = new THREE.BufferGeometry();
  const stepX = (xMax - xMin) / resolution;
  const stepY = (yMax - yMin) / resolution;
  const countX = resolution + 1;
  const countY = resolution + 1;
  const points = [];

  for (let i = 0; i <= resolution; i++) {
    const u = xMin + i * stepX;
    for (let j = 0; j <= resolution; j++) {
      const v = yMin + j * stepY;
      let x = 0,
        y = 0,
        z = 0;
      const varsObj = {};
      varsObj[indepVars[0]] = u;
      varsObj[indepVars[1]] = v;
      try {
        const result = expr.evaluate(varsObj);
        if (depVar === "x") {
          x = result;
          y = u;
          z = v;
        } else if (depVar === "y") {
          x = u;
          y = result;
          z = v;
        } else {
          x = u;
          y = v;
          z = result;
        }
      } catch (e) {
        x = y = z = NaN;
      }
      points.push(x, y, z);
    }
  }

  geometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(points, 3)
  );

  // === UV mapping ===
  const uv = [];
  for (let i = 0; i <= resolution; i++) {
    const u = xMin + i * stepX;
    for (let j = 0; j <= resolution; j++) {
      const v = yMin + j * stepY;
      const uCoord = (u - xMin) / (xMax - xMin);
      const vCoord = (v - yMin) / (yMax - yMin);
      uv.push(uCoord, vCoord);
    }
  }
  geometry.setAttribute("uv", new THREE.Float32BufferAttribute(uv, 2));

  if (mode === "surface") {
    const indices = [];
    for (let i = 0; i < countX - 1; i++) {
      for (let j = 0; j < countY - 1; j++) {
        const a = i * countY + j;
        const b = a + 1;
        const c = a + countY;
        const d = c + 1;
        indices.push(a, b, d, a, d, c);
      }
    }
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    let material;
    if (lightMode === "wireframe") {
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
      });
    } else {
      const texLoader = new THREE.TextureLoader();
      const texture = texLoader.load(
        "https://threejsfundamentals.org/threejs/resources/images/checker.png"
      );
      material = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        map: texture,
        metalness: 0.5,
        roughness: lightMode === "soft" ? 0.9 : 0.3,
        flatShading: lightMode === "strong",
        side: THREE.DoubleSide,
      });
    }
    surfaceMesh = new THREE.Mesh(geometry, material);
  } else {
    const group = new THREE.Group();
    for (let i = 0; i < countX; i++) {
      const linePoints = [];
      for (let j = 0; j < countY; j++) {
        const idx = i * countY + j;
        linePoints.push(
          new THREE.Vector3(
            points[idx * 3],
            points[idx * 3 + 1],
            points[idx * 3 + 2]
          )
        );
      }
      const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
      group.add(
        new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffff00 }))
      );
    }
    for (let j = 0; j < countY; j++) {
      const linePoints = [];
      for (let i = 0; i < countX; i++) {
        const idx = i * countY + j;
        linePoints.push(
          new THREE.Vector3(
            points[idx * 3],
            points[idx * 3 + 1],
            points[idx * 3 + 2]
          )
        );
      }
      const geo = new THREE.BufferGeometry().setFromPoints(linePoints);
      group.add(
        new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffaa00 }))
      );
    }
    surfaceMesh = group;
  }

  worldGroup.add(surfaceMesh);
  if (formulaLabel) worldGroup.remove(formulaLabel);
  formulaLabel = createFormulaLabel(formulaRaw, new THREE.Vector3(0, 0, 0));
  worldGroup.add(formulaLabel);
}

function plotPrimitive() {
  const choice = document.getElementById("primitiveShape").value;
  let mesh;
  const material = new THREE.MeshStandardMaterial({ color: 0x33ffff });

  switch (choice) {
    case "cube":
      mesh = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), material);
      break;
    case "sphere":
      mesh = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), material);
      break;
    case "cylinder":
      mesh = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 15, 32), material);
      break;
    case "cone":
      mesh = new THREE.Mesh(new THREE.ConeGeometry(5, 15, 32), material);
      break;
    case "circle":
      mesh = new THREE.Mesh(new THREE.CircleGeometry(8, 32), material);
      break;
    case "ellipse":
      const ellipse = new THREE.Shape();
      ellipse.absellipse(0, 0, 8, 4, 0, Math.PI * 2, false, 0);
      const ellipseGeom = new THREE.ShapeGeometry(ellipse);
      mesh = new THREE.Mesh(ellipseGeom, material);
      break;
    case "triangle":
      const triShape = new THREE.Shape();
      triShape.moveTo(0, 10);
      triShape.lineTo(-8.66, -5);
      triShape.lineTo(8.66, -5);
      triShape.lineTo(0, 10);
      const triGeom = new THREE.ShapeGeometry(triShape);
      mesh = new THREE.Mesh(triGeom, material);
      break;
    case "pentagon":
      mesh = polygonMesh(5, 6, material);
      break;
    case "hexagon":
      mesh = polygonMesh(6, 6, material);
      break;
    case "pyramid":
      const geom = new THREE.ConeGeometry(7, 10, 4);
      mesh = new THREE.Mesh(geom, material);
      break;
    case "plane":
      mesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), material);
      break;
    default:
      alert("H√£y ch·ªçn kh·ªëi h√¨nh.");
      return;
  }

  mesh.position.set(
    Math.random() * 20 - 10,
    Math.random() * 20 - 10,
    Math.random() * 20 - 10
  );
  worldGroup.add(mesh);
}

function moveCameraTo(points) {
  const center = new THREE.Vector3();
  points.forEach((p) => center.add(p));
  center.divideScalar(points.length);

  camera.position.set(center.x + 10, center.y + 10, center.z + 10);
  camera.lookAt(center);
}

// H√†m h·ªó tr·ª£ t·∫°o ƒëa gi√°c 2D ƒë·ªÅu (pentagon, hexagon,...)
function polygonMesh(sides, radius, material) {
  const shape = new THREE.Shape();
  for (let i = 0; i <= sides; i++) {
    const angle = (i / sides) * Math.PI * 2;
    const x = radius * Math.cos(angle);
    const y = radius * Math.sin(angle);
    if (i === 0) shape.moveTo(x, y);
    else shape.lineTo(x, y);
  }
  const geometry = new THREE.ShapeGeometry(shape);
  return new THREE.Mesh(geometry, material);
}

let customMotionFunc = null;
let lastCompiledCode = "";

// Gi·ªØ v·ªã tr√≠ g·ªëc ban ƒë·∫ßu cho c√°c hi·ªáu ·ª©ng nh∆∞ bounce
const originalPositions = new Map();
Object.values(allObjects).forEach((obj) => {
  originalPositions.set(obj, obj.position.clone());
});

function animate(time) {
  requestAnimationFrame(animate);
  controls.update();

  // Xoay c·∫£ worldGroup theo g√≥c nh√¨n
  switch (displayParams.viewAngle) {
    case "top":
      worldGroup.rotation.set(-Math.PI / 2, 0, 0); // nh√¨n t·ª´ tr√™n xu·ªëng
      break;
    case "front":
      worldGroup.rotation.set(0, 0, 0); // nh√¨n ch√≠nh di·ªán
      break;
    case "right":
      worldGroup.rotation.set(0, Math.PI / 2, 0); // nh√¨n t·ª´ b√™n ph·∫£i
      break;
    case "isometric":
      worldGroup.rotation.set(-Math.PI / 4, Math.PI / 4, 0); // g√≥c xi√™n 3D
      break;
    case "custom":
      // kh√¥ng √©p g√≥c, cho xoay t·ª± do b·∫±ng OrbitControls
      break;
  }
  // √Åp d·ª•ng hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông n·∫øu c√≥
  Object.values(allObjects).forEach((obj) => {
    if (!obj.visible) return;

    switch (sampleParams.motionEffect) {
      case "rotateY":
        obj.rotation.y += 0.01;
        break;
      case "rotateX":
        obj.rotation.x += 0.01;
        break;
      case "bounce":
        const orig = originalPositions.get(obj);
        obj.position.y = orig.y + Math.sin(time * 0.005) * 0.5;
        break;
      case "wave":
        obj.rotation.z = Math.sin(time * 0.003) * 0.3;
        obj.position.y = Math.sin(time * 0.002) * 0.4;
        break;
      case "spin":
        obj.rotation.x += 0.01;
        obj.rotation.y += 0.01;
        break;
      case "shake":
        const origShake = originalPositions.get(obj);
        obj.position.x = origShake.x + Math.sin(time * 0.02) * 0.3;
        break;
      case "circle":
        const origCircle = originalPositions.get(obj);
        obj.position.x = origCircle.x + Math.cos(time * 0.002) * 1;
        obj.position.z = origCircle.z + Math.sin(time * 0.002) * 1;
        break;
      case "waveZ":
        obj.rotation.x = Math.sin(time * 0.002) * 0.3;
        obj.position.z = Math.sin(time * 0.003) * 0.4;
        break;
      case "blink":
        if (obj.material) {
          obj.material.transparent = true; // ƒê·∫£m b·∫£o b·∫≠t ch·∫ø ƒë·ªô trong su·ªët
          obj.material.opacity =
            0.5 + 0.5 * Math.sin(performance.now() * 0.005);
        }
        break;
      case "float":
        obj.position.y = Math.sin(time * 0.002) * 0.5;
        break;
      case "rotate":
        obj.rotation.y += 0.01;
        break;
      case "pulse":
        const s = 1 + 0.3 * Math.sin(time * 0.004);
        obj.scale.set(s, s, s);
        break;
      case "orbit":
        obj.position.x = Math.sin(time * 0.001) * 5;
        obj.position.z = Math.cos(time * 0.001) * 5;
        obj.lookAt(0, 0, 0);
        break;
      case "flashColor":
        const c = 0.5 + Math.sin(time * 0.01) * 0.5;
        obj.material.color.setRGB(c, 0.2, 1 - c);
        break;
    }

    // ‚ú® Ch·∫°y hi·ªáu ·ª©ng ng∆∞·ªùi d√πng vi·∫øt
    if (sampleParams.customMotionCode.trim()) {
      try {
        // C·ªë t·∫°o tr∆∞·ªõc function 1 l·∫ßn duy nh·∫•t (n·∫øu kh√°c v·ªõi l·∫ßn tr∆∞·ªõc)
        if (sampleParams.customMotionCode !== lastCompiledCode) {
          customMotionFunc = new Function(
            "obj",
            "time",
            sampleParams.customMotionCode
          );
          lastCompiledCode = sampleParams.customMotionCode;
        }
        if (typeof customMotionFunc === "function") {
          customMotionFunc(obj, time);
        }
      } catch (err) {
        console.warn("L·ªói trong custom motion code:", err.message);
        customMotionFunc = null;
      }
    }
  });
  if (autoRotate) scene.rotation.y += 0.001;

  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
});

//////////////
// // C√°c h√†m ƒë∆∞·ª£c d√πng trong HTML c·∫ßn g√°n v√†o window
// window.drawVectorFromInput = drawVectorFromInput;
// window.plotPrimitive = plotPrimitive;
// window.plotSurface = plotSurface;
// window.plotPolar = plotPolar;
// window.plotCustom3D = plotCustom3D;
window.updateLightMode = updateLightMode;
// window.toggle = toggle;
window.gridHelper = gridHelper;
window.axisTicksGroup = axisTicksGroup;
window.sphere = sphere; // n·∫øu b·∫°n ƒë·∫∑t `sphereLine` ƒë·∫°i di·ªán cho m·∫∑t c·∫ßu 3D
window.heart = heart;
window.torus = torus;
window.spiral = spiral;
window.wave = wave;
window.saddle = saddle;
window.ellipsoid = ellipsoid;
window.paraboloid = paraboloid;
window.sincosWave = sincosWave;
window.mobius = mobius;
window.cone = cone;
window.cycloid = cycloid;
window.line = heart; // n·∫øu `line` d√πng cho ƒë∆∞·ªùng cong t√πy ch·ªânh
window.setViewDirection = setViewDirection;
window.oLabel = oLabel;
window.xLabel = xLabel;
window.yLabel = yLabel;
window.zLabel = zLabel;
window.computeIntegral1D = computeIntegral1D;
